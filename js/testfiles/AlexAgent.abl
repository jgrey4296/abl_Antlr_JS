package com.bbn.ssim.simulation;
// the package corresponds to where generated Java files are placed.

import java.lang.*;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import abl.runtime.BehavingEntity;
//import abl.runtime.BehaviorWME;
import abl.runtime.CompletedGoalWME;
import abl.runtime.LaunchTestBedBehaviorWME;
import abl.runtime.ParallelBehaviorWME;
import wm.WME;
import wm.WorkingMemory;
import com.bbn.ssim.agent.PlayerAgent;
import com.bbn.ssim.social.SocialInterpretation;
import com.bbn.ssim.drools.NBestSocialInterpretations;
import com.bbn.ssim.event.Location;
import com.bbn.ssim.event.Orientation;
import com.bbn.ssim.cif.*;
import com.bbn.ssim.sarnoff.Gesture;
import com.bbn.ssim.sarnoff.MiBA_Gesture;
import com.bbn.ssim.sarnoff.MiBA_SJ;
import java.util.Random;
import java.util.Iterator;


behaving_entity AlexAgent {
//behaving_entity HiveMindDirector {

	// ## Property registration

	// unique ID for a behavior-set	 
	property int uid;			

	// index for a behavior step in a behavior-set
	property int stepIndex;			
	
	// character name to manage idle and background behaviors.
	property String character;

	// declared ABT node properties
	//property BehaviorWME resourceOwner;
	
		
	// ## Act registration
	 
	/**
	 * ACT: performAction: perform an animation on a character
	 * String name: the name of the agent to animate
	 * String target: recipient at which the action is directed
	 * String act: The act to perform (see the UnityAgentAction enum)
	 * Object extra: additional content (such as an utterance) - blank string in general
	 */
	register act performAction(String, String, String, Object) with PerformAction;
	 
   /**
    * ACT: performActionEx: perform an animation on a character (with extended configuration options)
    * String name: The name of the agent to animate
    * String target: Recipient at which the action is directed
    * String act: The act to perform (see the UnityAgentAction enum)
    * Object extra: Additional content (such as an utterance) - blank string in general
    * AnimationLoopMode loopMode: What happens at the end of the animation?
    * float crossFadeDuration: Number of seconds over which the cross-fade should occur, or -1 for default
    * float speed: Normalized animation playback speed
    * float startTime: Where in the animation to start playback, in seconds
    * float endTime: Where in the animation to start playback, in seconds
    */
   register act performActionEx(String, String, String, Object, AnimationLoopMode, float, float, float, float) with PerformAction;
    
	/**
	 * ACT: headTrack: head track a character, or Location
	 * String name: the name of the agent to do the headtracking
	 * String target: the name of the agent, or location, to head track
	 */
	register act headTrack(String, String) with HeadTrack;
	register act headTrack(String, Location) with HeadTrack;
	register act headTrack(String, String, MiBA_SJ) with HeadTrack;
        
	/**
	 * ACT: headTrackOff: turn head track off for a character
	 * String name: the name of the agent
	 */
	register act headTrackOff(String) with HeadTrack;
	 
	/**
	 * ACT: clearFace: clear any set facial expression for a character
	 * String name: the name of the agent to clear the face
	 */
	register act clearFace(String) with ClearFace;
	 
   /**
    * ACT: moveToCartesianPoint
    * Causes agent to move to a cartesian point
    * String agentId: the ID of the agent to move
    * Location destination: location the agent will move to
	* boolean shuffle: whether to take small, shuffling steps, and not re-orient
    */
   register act moveToCartesianPoint(String, Location, boolean) with MoveToCartesianPoint;
		

   /**
    * ACT: teleportToCartesianPoint
    * Causes agent to teleport to a cartesian point
    * String agentId: the ID of the agent to teleport
    * Location destination: location the agent will teleport to
    */
   register act teleportToCartesianPoint(String, Location) with TeleportToCartesianPoint;
		
	
   /**
    * ACT: moveToNamedPoint
    * Causes agent to move to a named point
    * String agentId: the ID of the agent to move
    * String pointId: the ID of the point to which to move
	* boolean shuffle: whether to take small, shuffling steps, and not re-orient
    */
   register act moveToNamedPoint(String, String, boolean) with MoveToNamedPoint;
		
	
   /**
    * ACT: moveToDistanceAndAngle
    * Causes agent to move to a given distance at given angle from target.
    * String agentId: the ID of the agent to move
    * String targetId: the ID of the target agent
    * float angle: angle from target for the destination point
    * float dist: distance from target for the destination point
	* boolean shuffle: whether to take small, shuffling steps, and not re-orient
    */
   register act moveToDistanceAndAngle(String, String, float, float, boolean) with MoveToPointOnCircumference;


   /**
    * ACT: orientYAxis
    * Causes agent to orient to given angle
    * String agentId: the ID of the agent to rotate
    * float angle: angle the agent will orient to
    * boolean instant: whether to snap to the new angle instantly, as opposed to rotating to it over time
    */
   register act orientYAxis(String, float, boolean) with OrientYAxis;


   /**
    * ACT: cameraPanTo: cause the camera to pan and zoom
    * String targetName: name of the agent or object on which to focus
    * float fov: the target field of view
    * float duration: the time in seconds over which to pan and zoom
    */
   register act cameraPanTo(String, float, float) with CameraPanTo;
		
	
   /**
    * ACT: attachObject
    * Causes agent to attach or detach an object
    * String agentId: the ID of the agent 
    * String attachmentId: the ID of the object to attach (if any)
    * boolean enabled: attach or not
    */
   register act attachObject(String, String, boolean) with AttachObject;

	
	// ## WME Registration
	
	// fixme: this is bad Abl form to have one sensor create multiple types of wme
	register wme PhysicalAgentWME with PhysicalAgentSensor;

	
	// ## Log
	Log log = LogFactory.getLog("AblAgent.HiveMindDirector");
	
	
	// ## Global random number generator
	Random randGen = new Random();
		
	// Random seed
	Random randomNumGen = new Random(System.currentTimeMillis());
	
	// player agent name
	String playerName = PlayerAgent.getPlayerId();
	
	SiuWME nullSiu;
	
	// ## Demo constants
		
	int demoSetupCtr = 0;
	boolean bStaggerGroupArrivalInDemo = false;
	
	// demo points
	Location demoOrigin;
	
	CharactersWME friendsList1;
	CharactersWME friendsList2;
	CharactersWME friendsList3;
	CharactersWME friendsList4;
	CharactersWME friendsList5;
	CharactersWME friendsEmpty;
	
	// ## Constants

	// performance priorities
	int cPerformancePriorityLow = 0;
	int cPerformancePriorityMedLow = 1;
	int cPerformancePriorityMedMedLow = 2;
	int cPerformancePriorityMed = 3;
	int cPerformancePriorityMedMedHigh = 4;
	int cPerformancePriorityMedHigh = 5;
	int cPerformancePriorityHigh = 6;
	int cPerformancePriorityHigher = 7;
	int cPerformancePriorityHighest = 8;
	int cPerformancePriorityVeryHighest = 9;

	// performance states
	int cPerformanceStateNew = PerformanceManager.cPerformanceStateNew;
	int cPerformanceStateWaiting = PerformanceManager.cPerformanceStateWaiting;
	int cPerformanceStatePerforming = PerformanceManager.cPerformanceStatePerforming;

	// performance types
	int cPerformanceTypeExpression = PerformanceManager.cPerformanceTypeExpression;
	int cPerformanceTypeStaging = PerformanceManager.cPerformanceTypeStaging;

	// default timeout for waiting for an expected player signal
	int cPlayerSignalTimeout = 30000;
	
	// a shorter timeout
	int cPlayerSignalShortTimeout = 10000;

	// how long until an un-absorbed gesture can still be considered valid to use
	int cStaleGestureTimeout = 10000;

	// how long until an un-absorbed gesture can still be considered valid to use - short timeout
	int cStaleGestureShortTimeout = 3000;
	
	// how long until a behavior requesting a body resource gets the resource anyhow. Meant to prevent deadlock.
	int cBodyResourceWMERequestOverrideTimeout = 5000;
	
	// how recently a previous SIU occurred to consider it recent. 
	// Note this is real time, including any time spent by the developer at a breakpoint...
	int cRecentSIUTimeout = 90000;
	
	// don't repeat non-critical gestures more often than this
	int cRepetitiveGestureTimeout = 7000;
	
	// the distance to the formation point that a character will not move if they are within
	double cFormationPointWiggleRoom = 0.5;
	double cFormationOrientationWiggleRoom = 10.0;
	double cFormationOrientationNoise = 20.0;
	
	// Interpersonal distances 
	double cCloseConversationDistance = 1.5;
	double cPersonalSpaceDistance = 2.0;
	double cExchangeObjectDistance = 2.5;
	double cApproachGroupDistance = 2.5;
	double cDirectedGestureDistance = SocialSignalWME.cDirectedGestureDistance;
	double cQueueDistance = 4.0;
	double cCloseAwarenessDistance = 4.0;
	double cFarAwarenessDistance = 8.0;
	double cFarDistance = 10.0;
	double cAudibleDistance = 12.0;
	
	double cCharacterHeight = 3.5;
	double cHeldObjectOffset = 0.3;
	
	// fixme: replace with proper enum
	int eBodyResourceID_body = 0;

	// Use this to indicate that you want an animation to play to its natural end
	float cAnimDefaultCrossfadeDuration = -1f;
	float cAnimDefaultSpeed = 1f;
	float cAnimDefaultStartTime = 0f;
	float cAnimDefaultEndTime = -1f;
	float cAttitudeDefaultDuration = -2f;	// not -1, to distinguish from cAnimDefaultEndTime 

	// animation loop modes
	AnimationLoopMode eLoopModeLoop = AnimationLoopMode.Loop;
	AnimationLoopMode eLoopModeClampForever = AnimationLoopMode.ClampForever;
	AnimationLoopMode eLoopModeDefault = AnimationLoopMode.Default;
		
	// Objects to attach
	String idCard_mesh = "idCard_mesh";
	
	// Items that NPCs hold -- to keep track of who is holding them
	String cObjectPhoto = "photo";
	
	// SIU names
	String siuNameGreet = "SIU_Greet";
	String siuNameGroupFormation = "SIU_GroupFormation";
	String siuNameGroupSmalltalk = "SIU_GroupSmalltalk";
	String siuNameBriefChat = "SIU_BriefChat";
	String siuNameApproach = "SIU_Approach";
	String siuNameStudyOwnObject = "SIU_studyOwnObject";
	String siuNameGroupStudyObject = "SIU_GroupStudyObject";
	String siuNameGroupPassObject = "SIU_groupPassObject";
	String siuNameGiveObject = "SIU_GiveObject";
	String siuNameRequestObject = "SIU_RequestObject";
	String siuNameGroupMirror = "SIU_GroupMirror";
	String siuNameGroupBriefAttention = "SIU_GroupBriefAttention";
	String siuNameGiveObjectToPlayer = "SIU_GiveObjectToPlayer";
	String siuNameTakeObjectFromPlayer = "SIU_TakeObjectFromPlayer";
	String siuNameGroupConfused = "SIU_GroupConfused";
	String siuNameGroupReactToQuestion = "SIU_GroupReactToQuestion";
	String siuNameGroupReactToAppeal = "SIU_GroupReactToAppeal";
	String siuNameGroupAnswerQuestion = "SIU_GroupAnswerQuestion";
	String siuNamePersonalSpace = "SIU_PersonalSpace";

	
	// Rule Names
	String ruleNameGreetPlayerToGroupNomination = "rule_GreetPlayerToGroupNomination";
	String ruleNameApproachNomination = "rule_ApproachNomination";
	String ruleNameMirrorNomination = "rule_MirrorNomination";
	String ruleNamePersonalSpaceViolationNomination = "rule_PersonalSpaceViolationNomination";
	String ruleNameGiveHeldObjectNomination = "rule_GiveHeldObjectNomination";
	String ruleNameOfferHeldObjectNomination = "rule_OfferHeldObjectNomination";
	String ruleNameShowHeldObjectNomination = "rule_ShowHeldObjectNomination";
	String ruleNameRequestObjectFromCharacterHoldingItNomination = "rule_RequestObjectFromCharacterHoldingItNomination";
	String ruleNamePointToHeldObjectAtGroupNomination = "rule_PointToHeldObjectAtGroupNomination";
	String ruleNamePointLeftOrRightNomination = "rule_PointLeftOrRightNomination";
	
	
	
	
	
	// social interpretations of player actions
	SocialInterpretation socialInterpretationApproach = SocialInterpretation.APPROACH;	
	SocialInterpretation socialInterpretationVeryClose = SocialInterpretation.VERY_CLOSE;	
	SocialInterpretation socialInterpretationGreetingWaveFriendly = SocialInterpretation.FRIENDLY_GREETING_GESTURE;
	SocialInterpretation socialInterpretationExtendHand = SocialInterpretation.SHOW_OBJECT;
	SocialInterpretation socialInterpretationPointAtHeldObject = SocialInterpretation.POINT_AT_HELD_OBJECT; 
	SocialInterpretation socialInterpretationPointLeft = SocialInterpretation.POINT_LEFT;
	SocialInterpretation socialInterpretationPointRight = SocialInterpretation.POINT_RIGHT;
	SocialInterpretation socialInterpretationEmotionalAppeal = SocialInterpretation.EMOTIONAL_APPEAL;
	
	// old	
	SocialInterpretation socialInterpretationGreetingSpeechFriendly = SocialInterpretation.FRIENDLY_GREETING_SPEECH;
	SocialInterpretation socialInterpretationGreetingSpeechNeutral = SocialInterpretation.NEUTRAL_GREETING_SPEECH;
	SocialInterpretation socialInterpretationEngage = SocialInterpretation.ENGAGE;
	SocialInterpretation socialInterpretationRequestIDGesture = SocialInterpretation.REQUEST_ID_GESTURE;
	SocialInterpretation socialInterpretationRequestIDSpeech = SocialInterpretation.REQUEST_ID_SPEECH;
	SocialInterpretation socialInterpretationOfferIDTwoHanded = SocialInterpretation.OFFER_ID;	// fixme replace with two-handed
	SocialInterpretation socialInterpretationExamineID = SocialInterpretation.EXAMINE_ID;
	SocialInterpretation socialInterpretationThanks = SocialInterpretation.THANKS;
	SocialInterpretation socialInterpretationDismiss = SocialInterpretation.DISMISS;
	SocialInterpretation socialInterpretationOfferAssistance = SocialInterpretation.OFFER_ASSISTANCE;	
	SocialInterpretation socialInterpretationBeckon = SocialInterpretation.BECKON;
	SocialInterpretation socialInterpretationWrongBeckon = SocialInterpretation.CONFUSING_GESTURE;
	SocialInterpretation socialInterpretationIndicateIDRequirement = SocialInterpretation.INDICATE_ID_REQUIREMENT;
	SocialInterpretation socialExplanationRequest = SocialInterpretation.EXPLANATION_REQUEST;
	SocialInterpretation socialUnkindRefusal = SocialInterpretation.UNKIND_REFUSAL;
	SocialInterpretation socialUnkindRefusalHighlyAgitated = SocialInterpretation.UNKIND_REFUSAL_HIGHLY_AGITATED;
	SocialInterpretation socialInterpretationGenericInsult = SocialInterpretation.GENERIC_INSULT;
	SocialInterpretation socialApology = SocialInterpretation.APOLOGY;
	SocialInterpretation socialMoveRequest = SocialInterpretation.MOVE_REQUEST;
	SocialInterpretation socialInterpretationCalmSelfDown = SocialInterpretation.CALM_SELF_DOWN;
	SocialInterpretation socialInterpretationAcknowledgeRepair = SocialInterpretation.ACKNOWLEDGE_REPAIR;	
	SocialInterpretation socialInterpretationLeave = SocialInterpretation.LEAVE;	
	
	String gestureNameSmallWave = MiBA_Gesture.SMALL_WAVE_HOLDING_OBJECT.toString();
	String gestureNameShowHeldObject = MiBA_Gesture.SHOW_HELD_OBJECT.toString();
	String gestureNameShowHeldObjectVaryingAngles = MiBA_Gesture.SHOW_HELD_OBJECT_VARYING_ANGLES.toString();
	String gestureNameSmallBowHandsTogether = MiBA_Gesture.SMALL_BOW_HANDS_TOGETHER.toString();
	String gestureNameEmotionalAppeal = MiBA_Gesture.EMOTIONAL_APPEAL.toString();
	//String gestureNamePointingLeft = MiBA_Gesture.POINTING_LEFT_HAND.toString();
	//String gestureNamePointingRight = MiBA_Gesture.POINTING_RIGHT_HAND.toString();
	//String gestureNameFoldArms = MiBA_Gesture.FOLD_ARMS.toString();
	//String gestureNameExtendRightHand = MiBA_Gesture.EXTEND_RIGHT_HAND.toString();
	/*
	String gestureNameZzz = MiBA_Gesture.RIGHT_HAND_STOP.toString();
	String gestureNameZzz = MiBA_Gesture.DISMISS_SWING_RIGHT_ARM_SIDEWAYS.toString();
	String gestureNameZzz = MiBA_Gesture.BECKON_SWEEP_RIGHT_ARM_TOWARD_CENTERLINE.toString();
	String gestureNameZzz = MiBA_Gesture.BECKON_ROTATE_LOWER_ARM_IN_VERTICAL_PLANE.toString();
	String gestureNameZzz = MiBA_Gesture.EXTEND_BOTH_HANDS.toString();
	String gestureNameZzz = MiBA_Gesture.HEAD_NOD.toString();
	*/
	
	// social interpretations of player actions
	MiBA_SJ playerSkeletonNode_leftHand = MiBA_SJ.LEFT_HAND;	
	MiBA_SJ playerSkeletonNode_rightHand = MiBA_SJ.RIGHT_HAND;
	
	// SIU category types	
	AblEnums siuCategory_generic = AblEnums.SIUCATEGORY_GENERIC;
	AblEnums siuCategory_cutscene = AblEnums.SIUCATEGORY_CUTSCENE;
	AblEnums siuCategory_transaction = AblEnums.SIUCATEGORY_TRANSACTION;

	// CiF effects
	String cifEffect_affinity = "affinity";
	String cifEffect_otherness = "otherness";
	String cifEffect_madeEyeContact = "made eye contact";
	String cifEffect_engagedWith = "engaged with";
	String cifEffect_inLine = "in line";
	String cifEffect_withinConversationDistance = "within conversation distance";
	String cifEffect_frustrated = "frustrated";
	String cifEffect_expressFrustration = "express frustration";
	String cifEffect_suspiciousOf = "suspicious of";
	String cifEffect_introducedFriends = "introduced friends";
	String cifEffect_hasBeenIntroducedTo = "has been introduced to";
	String cifEffect_expressInabilityToHelp = "expressed inability to help";
	String cifEffect_hasAskedToExplainOnBehalfOf = "has asked to explain on behalf of";
	String cifEffect_getEntryOnBehalfOf = "get entry on behalf of";
	String cifEffect_isHoldingId = "is holding id";
	String cifEffect_hasExplainedIdRules = "has explained id rules";
	String cifEffect_hasBeenRequestedToShowId = "has been requested to show id";
	String cifEffect_hasCheckedIdSuccessful = "has checked id successful";
	String cifEffect_requestedEntranceWithoutId = "requested entrance without id";
	String cifEffect_directedToStandSomewhere = "directed to stand somewhere";
	String cifEffect_sentToWaitingArea = "sent to waiting area";
	String cifEffect_allowedEntry = "allowed entry";
	String cifEffect_deniedEntry = "denied entry";
	String cifEffect_deniedEntryGamePlayed = "denied entry game played";

	// CiF traits
	String cifTrait_friendly = "friendly";
	String cifTrait_disagreeable = "disagreeable";
	String cifTrait_spontaneous = "spontaneous";
	String cifTrait_lowEnglishSkill = "low english skill";
	String cifTrait_highEnglishSkill = "high english skill";
	
	// Attitude Type Enums
	String eAttitudeType_hostile = "attitudeHostile";
	String eAttitudeType_leader = "attitudeLeader";
	String eAttitudeType_sympathetic = "attitudeSympathetic";
	
	// barely supported, only for giveObject
	String eAttitudeType_exasperation = "attitudeExasperation";
	
	// old, unsupported
	//String eAttitudeType_compliance = "attitudeCompliance";
	//String eAttitudeType_frustration = "attitudeFrustration";
	//String eAttitudeType_jovial = "attitudeJovial";
	//String eAttitudeType_serious = "attitudeSerious";
	//String eAttitudeType_curious = "attitudeCurious";
	//String eAttitudeType_nervous = "attitudeNervous";
   
	// Attitude Perform Types
	String eAttitudePerform_speak = "performSpeak";
	String eAttitudePerform_listen = "performListen";
	String eAttitudePerform_notice = "performNotice";
	String eAttitudePerform_confused = "performConfused";
	String eAttitudePerform_giveObject = "performGiveObject";
	
	// Attitude Perform Params
   	String eAttitudeParam_firstGlance = "firstGlance";
   	
   //Attitude Utility Consts
   int cAttitudeUtility_sameAnimationPenalty = 20;
   int cAttitudeUtility_sameAttitudePenalty = 1;
   int cAttitudeUtility_uniquenessThreshold = 80;
   
   // Dialogue Variation Parameters
   String smallTalk_Default = "smallTalkDefault";
   String smallTalk_DiscussDistant = "smallTalkDiscussDistant";
   String smallTalk_DiscussClose = "smallTalkDiscussClose";
   String smallTalk_DiscussTopic = "smallTalkDiscussTopic";
   
   // NPC animations

	String animationStartledDenial = UnityAgentAction.STARTLED_DENIAL.name();
	String animationArmsCrossedEmotional1 = UnityAgentAction.ARMSCROSSED_EMOTIONAL_REACTION.name();
	String animationArmsCrossedEmotional2 = UnityAgentAction.ARMSCROSSED_EMOTIONALREACTION_02.name();
	String animationHeadShakesNo1 = UnityAgentAction.HEADSHAKE_NO_STRONG_01.name();
	String animationHeadShakesNo2 = UnityAgentAction.HEADSHAKE_NO_STRONG_02.name();
	String animationArmsCrossedRefusal1 = UnityAgentAction.GESTURE_NEGATE01.name();
	String animationArmsCrossedRefusal1Idle = UnityAgentAction.GESTURE_NEGATE01_LOOP.name();
	String animationArmsCrossedRefusal2 = UnityAgentAction.GESTURE_NEGATE02.name();
	String animationArmsCrossedRefusal2Idle = UnityAgentAction.GESTURE_NEGATE02_LOOP.name();
	String animationGestureExplain1 = UnityAgentAction.GESTURE_EXPLAIN_01.name();
	String animationGestureAngryQuick1 = UnityAgentAction.GESTURE_ANGRYQUICK_01.name();
	String animationGestureAngryQuick2 = UnityAgentAction.GESTURE_ANGRYQUICK_02.name();
	String animationGestureAngryQuick3 = UnityAgentAction.GESTURE_ANGRYQUICK_03.name();
	String animationAssertiveStop = UnityAgentAction.ASSERTIVE_STOP.name();
	String animationAssertiveStopIdle = UnityAgentAction.ASSERTIVE_STOP_LOOP.name();
	
	String animationListenHeadCockLeft1 = UnityAgentAction.LISTENING_A_2.name();
	String animationListenHeadCockLeft2 = UnityAgentAction.LISTENING_B_1.name();
	String animationListenHeadCockRight1 = UnityAgentAction.LISTENING_A_1.name();
	String animationListenHeadCockRight2 = UnityAgentAction.LISTENING_B_2.name();
	String animationTalkingGestureEmphatic1 = UnityAgentAction.TALKING_GESTURES_EXCITED_01.name();
	String animationTalkingGestureEmphatic2 = UnityAgentAction.TALKING_GESTURES_EXCITED_02.name();
	String animationTalkingGestureEmphatic3 = UnityAgentAction.TALKING_GESTURES_EXCITED_03.name();
	String animationTalkingGestureEmphatic3b = UnityAgentAction.TALKING_GESTURES_EXCITED_03_MIRRORED.name();
	String animationTalkingGestureBigAffirmative1 = UnityAgentAction.GESTURE_PEDAGOGIC_AFFIRMATIVES_A.name();
	String animationTalkingGestureBigAffirmative2 = UnityAgentAction.GESTURE_PEDAGOGIC_AFFIRMATIVES_B.name();
	String animationListeningHoldChin = UnityAgentAction.TALKING_GESTURES_SERIOUS_01.name();

	String animationTalkingGestureSerious1 = UnityAgentAction.TALKING_GESTURES_SERIOUS_02.name();
	String animationTalkingGestureSerious1b = UnityAgentAction.TALKING_GESTURES_SERIOUS_01_MIRRORED.name();
	String animationTalkingGestureSerious2 = UnityAgentAction.TALKING_GESTURES_SERIOUS_03.name();
    String animationTalkingNeutral1 = UnityAgentAction.TALKING_NEUTRAL1.name();
	String animationTalkingNeutral1b = UnityAgentAction.TALKING_NEUTRAL1_MIRRORED.name();
    String animationTalkingNeutral2 = UnityAgentAction.TALKING_NEUTRAL2.name();
	String animationTalkingNeutral2b = UnityAgentAction.TALKING_NEUTRAL2_MIRRORED.name();
    String animationTalkingNeutral3 = UnityAgentAction.TALKING_NEUTRAL3.name();
    String animationTalkingAnnoyed2 = UnityAgentAction.TALKING_ANNOYED2.name();
    String animationTalkingAnnoyed3 = UnityAgentAction.TALKING_ANNOYED3.name();
    String animationTalkingFrustrated1 = UnityAgentAction.TALKING_FRUSTRATED_1.name();
    String animationTalkingFrustrated2 = UnityAgentAction.TALKING_FRUSTRATED_2.name();
    String animationTalkingFrustrated3 = UnityAgentAction.TALKING_FRUSTRATED_3.name();
   
	String animationBigHeadNodBow1 = UnityAgentAction.GESTURE_GREETINGS_SMALL_UPPERBODY_BOWS_A.name();
	String animationBigHeadNodBow2 = UnityAgentAction.GESTURE_GREETINGS_SMALL_UPPERBODY_BOWS_B.name();
	String animationNoticeGestureStarting = UnityAgentAction.NOTICE_GESTURE_STARTING.name();
	String animationNoticeHeldObject1 = UnityAgentAction.NOTICE_HELD_OBJECT_A.name();
	String animationNoticeHeldObject2 = UnityAgentAction.NOTICE_HELD_OBJECT_B.name();
	String animationNoticeHeldObject3 = UnityAgentAction.NOTICE_HELD_OBJECT_C.name();
	String animationNoticingInDistanceAway1 = UnityAgentAction.NOTICING_IN_DISTANCE_AWAY.name();
	String animationNoticingInDistanceAway2 = UnityAgentAction.REACTING_IN_DISTANCE_APPROACHING.name();
	String animationNoticeSpeechOnset1 = UnityAgentAction.NOTICING_SPEECH_ONSET_A.name();
	String animationNoticeSpeechOnset2 = UnityAgentAction.NOTICING_SPEECH_ONSET_B.name();
	String animationNoticeSpeechOnset3 = UnityAgentAction.NOTICING_SPEECH_ONSET_C.name();
	String animationInterrupted1 = UnityAgentAction.INTERRUPTED_A.name();
	String animationInterrupted2 = UnityAgentAction.INTERRUPTED_B.name();
	String animationInterrupted3 = UnityAgentAction.INTERRUPTED_C.name();
	String animationInterrupted4 = UnityAgentAction.INTERRUPTED_D.name();
	String animationShrug = UnityAgentAction.IDLE_SHRUG.name();
	String animationShortShrug = UnityAgentAction.SHORT_SHRUG.name();
	String animationShortShrugArmsCrossed = UnityAgentAction.SHRUG_ARMS_CROSSED.name();
	String animationScratchChin = UnityAgentAction.IDLE_FIDGET01.name();
	String animationConfused3 = UnityAgentAction.CONFUSED_03.name();
	String animationConfused4 = UnityAgentAction.CONFUSED_04.name();
	String animationDontUnderstand = UnityAgentAction.GESTURE_DONT_UNDERSTAND.name();
	String animationLookAtHeldObject = UnityAgentAction.HAND_CARD_LOOKAT.name();
	String animationLookAtHeldObjectIdle = UnityAgentAction.LOOKAT_IDLELOOP.name();
	String animationLowerArmFromLookAt = UnityAgentAction.LOOKAT_LOWER.name();
	String animationSlightLowerArmFromLookAt = UnityAgentAction.LOOKAT_SLIGHT_LOWER.name();
	String animationSlightLowerArmIdle = UnityAgentAction.LOOKAT_SLIGHT_LOWER_IDLE_LOOP.name();
	String animationAkimboLeftArm = UnityAgentAction.AKIMBO_LEFT_ONLY.name();
	String animationAkimboRightArm = UnityAgentAction.AKIMBO_RIGHT_ONLY.name();
	String animationAkimboBothArms = UnityAgentAction.AKIMBO.name();
	String animationArmsCrossed = UnityAgentAction.ARMS_CROSSED.name();
	String animationSmallWaveLeftArm1 = UnityAgentAction.SMALLWAVE_L01.name();
	String animationSmallWaveLeftArm2 = UnityAgentAction.SMALLWAVE_L02.name();
	String animationSmallWaveRightArm1 = UnityAgentAction.SMALLWAVE_R01.name();
	String animationSmallWaveRightArm2 = UnityAgentAction.SMALLWAVE_R02.name();
	String animationWavingRightArm = UnityAgentAction.GESTURE_GREETINGS_SMALLWAVE.name();
	String animationPersonalSpaceGesture = UnityAgentAction.PERSONALSPACE_ATEST.name();	
	String animationPersonalSpaceStepBack = UnityAgentAction.PERSONAL_SPACE_STEPBACK.name();
	String animationPersonalSpaceIdle = UnityAgentAction.PERSONAL_SPACE_IDLE.name();
	String animationHandCardAgitated = UnityAgentAction.HAND_CARD_AGITIATED.name();
	String animationHandCardHesistant = UnityAgentAction.HAND_CARD_HESITANT.name();
	String animationPointIntoDistanceL = UnityAgentAction.POINT_INTO_DISTANCE_L.name();
	String animationPointIntoDistanceLEmphasis = UnityAgentAction.POINT_INTO_DISTANCE_L_EMPHASIS.name();
	String animationPointIntoDistanceLIdle = UnityAgentAction.POINT_INTO_DISTANCE_L_LOOP.name();
	String animationPointIntoDistanceR = UnityAgentAction.POINT_INTO_DISTANCE_R.name();
	String animationPointIntoDistanceREmphasis = UnityAgentAction.POINT_INTO_DISTANCE_R_EMPHASIS.name();
	String animationPointIntoDistanceRIdle = UnityAgentAction.POINT_INTO_DISTANCE_R_LOOP.name();
	String animationPointQuestion = UnityAgentAction.GESTURE_POINT_QUESTION.name();
	String animationPointQuestionIdle = UnityAgentAction.GESTURE_POINT_QUESTION_LOOP.name();
  
	String animationBowSmallGreet = UnityAgentAction.BOW_SMALL_GREET.name();
	
	// the 3 primary give/take animations
	String animationOfferObject = UnityAgentAction.OFFER_OBJECT.name();		// extend hand
	String animationOfferObjectIdle = UnityAgentAction.HAND_CARD_IDLE_LOOP.name();		// idle at extended hand
	// from/to pocket	
	String animationPullOutObject = UnityAgentAction.PULL_OUT_OBJECT.name();	// IDcardReveal
	String animationReachAndTakeObject = UnityAgentAction.REACH_AND_TAKE_OBJECT.name();	// handCard_take -- hand at side, raise arm and reach forward, bring arm back down
	
	String animationIdle_Agitated1 = UnityAgentAction.IDLE_AGITATED_1.name();
	String animationIdle_Agitated2 = UnityAgentAction.IDLE_AGITATED_2.name();
	String animationIdle_ArmsCrossed = UnityAgentAction.ARMSCROSSED_IDLE.name();
	String animationIdle_AngryAkimbo1 = UnityAgentAction.IDLE_ANGRY_AKIMBO_1.name();
	
	String animationIdle_Conversation = UnityAgentAction.IDLE_CONVERSATION.name();
	String animationIdle_Restless = UnityAgentAction.IDLE_RESTLESS.name();
	String animationIdle_Impatient = UnityAgentAction.IDLE_IMPATIENT.name();
	String animationIdle_SpacingOut1 = UnityAgentAction.IDLE_SPACINGOUT_1.name();
	String animationIdle_SpacingOut2 = UnityAgentAction.IDLE_SPACINGOUT_2.name();
	String animationIdle_AvoidingGazeStart1 = UnityAgentAction.IDLE_AVOIDING_GAZE_START_1.name();
	String animationIdle_AvoidingGazeEnd1 = UnityAgentAction.IDLE_AVOIDING_GAZE_END_1.name();
	String animationIdle_AvoidingGazeLoop1 = UnityAgentAction.IDLE_AVOIDING_GAZE_LOOP_1.name();
	String animationConfused = UnityAgentAction.CONFUSED.name();
	String animationConfused2 = UnityAgentAction.CONFUSED2.name();
	String animationConfusedIdle = UnityAgentAction.CONFUSEDIDLE.name();

	String animationLaugh = UnityAgentAction.LAUGH.name();	
	String animationExasperated = UnityAgentAction.EXASPERATED.name();
	String animationFrustrated = UnityAgentAction.EXPRESS_FRUSTRATION.name();
    String animationPointToLeft = UnityAgentAction.POINT_TO_LEFT.name();
	
	String animationHeadNodBig = UnityAgentAction.HEADNODBIG.name(); // headNodBig01
	String animationHeadNodSmiling = UnityAgentAction.HEADNODSMILING.name();	// headNodBigFriendly02
	String animationHeadNodOpenSmiling = UnityAgentAction.HEADNODOPENSMILING.name(); // headNodBigFriendly01
	String animationHeadNodSmallSerious = UnityAgentAction.HEADNODSMALLSERIOUS.name(); 	// headNodSmallAnnoyed
	String animationHeadNodSerious = UnityAgentAction.HEADNODSERIOUS.name();		// noticeHeldObject01
	String animationHeadShake = UnityAgentAction.HEADSHAKE.name();

	String animationFaceIdle = UnityAgentAction.FACE_IDLE.name();
	String animationFaceSmile = UnityAgentAction.FACE_SMILE.name();
	String animationFaceSmile2 = UnityAgentAction.FACE_FRIENDLY_02.name();
	String animationFaceBigSmile = UnityAgentAction.FACE_BIGSMILE.name();
    String animationFaceVeryAnnoyed = UnityAgentAction.FACE_VERYANNOYED.name();
    String animationFaceAngry = UnityAgentAction.FACE_ANGRY.name();
    String animationFaceAngry2 = UnityAgentAction.FACE_ANGRY_03.name();
    String animationFaceStony = UnityAgentAction.FACE_STONY.name();
    String animationFaceShocked = UnityAgentAction.FACE_SHOCKED.name();
    String animationFaceUnsure = UnityAgentAction.FACE_UNSURE.name();
    String animationFaceAnxious = UnityAgentAction.FACE_ANXIOUS.name();
    String animationFaceAnxious2 = UnityAgentAction.FACE_ANXIOUS_02.name();
    String animationFaceNervous = UnityAgentAction.FACE_NERVOUS.name();
    String animationFaceNervous2 = UnityAgentAction.FACE_SLIGHTLYCONFUSED_02.name();
    String animationFaceNervous3 = UnityAgentAction.FACE_SLIGHTLYCONFUSED_03.name();
    
    String animationGestureCough1 = UnityAgentAction.GESTURE_COUGH_1.name();
    String animationHandsHeldStand = UnityAgentAction.HANDS_HELD_STAND.name();
    String animationHandCardTwoHanded = UnityAgentAction.HAND_CARD_TWO_HANDED.name();
    
    String animationExasperated1 = UnityAgentAction.EXASPERATED_1.name();
    String animationExasperated3 = UnityAgentAction.EXASPERATED_3.name();
    String animationFrustratedAngry1 = UnityAgentAction.FRUSTRATED_ANGRY_1.name();
    String animationFrustratedAngry3 = UnityAgentAction.FRUSTRATED_ANGRY_3.name();
    String animationFrustrated1 = UnityAgentAction.FRUSTRATED_1.name();

	String animationTurnBackRightAndGesture0 = UnityAgentAction.TURNBACKRIGHT_AND_GESTURE0.name();
    
    String animationListening = UnityAgentAction.LISTENING_AFFIRMATIVE.name();
    
    String animationListeningAngry1 = UnityAgentAction.LISTENING_ANGRY1.name();
    String animationListeningAngry2 = UnityAgentAction.LISTENING_ANGRY2.name();
    String animationListeningFrustrated1 = UnityAgentAction.LISTENING_FRUSTRATED1.name();
    
	String animationAngryArguing3 = UnityAgentAction.ANGRY_ARGUING_3.name();
	String animationAngryArguing4 = UnityAgentAction.ANGRY_ARGUING_4.name();
	String animationAngryArguing5 = UnityAgentAction.ANGRY_ARGUING_5.name();
  
	String animationAngryArguingID1 = UnityAgentAction.ANGRY_ARGUING_ID_1.name();
  
	String animationThumbsUp = UnityAgentAction.THUMBS_UP.name();
	String animationReleaseLaugh = UnityAgentAction.RELEASE_LAUGH.name();

	String animationGetAttentionWave = UnityAgentAction.SECOND_WAVE.name();
	String animationGetAttentionWave2 = UnityAgentAction.GET_ATTENTION_BOTH_ARMS_WAVING_01.name();
	String animationGetAttentionWave3 = UnityAgentAction.GET_ATTENTION_BOTH_ARMS_WAVING_02.name();
  
	String animationWalk = UnityAgentAction.WALK_TXNIN.name();

	// dialog names
	String dialogue_gender_male = "Male";
	String dialogue_tone_neutral = "Neutral";
	String dialogue_tone_dominant = "Dominant";
	String dialogue_tone_cooperative = "Cooperative";
	
	String dialogue_eng_HelloCorporal = "HelloCorporal";
	
	String dialogue_thai_Hello = "A";
	String dialogue_thai_YoureWelcome = "B";
	String dialogue_thai_IWasToldICouldGetWorkIfICameHere = "C";
	String dialogue_thai_INeedTheWork = "D1";
	String dialogue_thai_WhyWontYouLetMeIn = "D2";
	String dialogue_thai_IDontHaveMyCardIForgotIt = "E1";
	String dialogue_thai_CantYouPleaseLetMeInAnyway = "E2";
	String dialogue_thai_INeedThisWorkWhyCantYouAllowMeThis = "F1";
	String dialogue_thai_YouAmericansAreAlwaysTryingToControlUsTellingUsWhatToDo = "F2";
	String dialogue_thai_ItReallyPissesMeOff = "F3";
	String dialogue_thai_IToldYouIForgotMyPass = "G1";
	String dialogue_thai_YouComeHereActLikeYouOwnOurCountryAndYouCantEvenSpeakOurLanguage = "G2";
	String dialogue_thai_TheseAreMyFriendsTheyCanVouchForMe = "H1";
	String dialogue_thai_WhyDontYouLetMeIn = "H2";
	String dialogue_thai_ThisJobIsImportantToMe = "H3";
	String dialogue_thai_INeedTheWork2 = "H4";
	String dialogue_thai_JustBecauseYouHaveAGunYouThinkYouCanBossEverybodyAround = "H5";
	String dialogue_thai_WhyCantYouLetHimIn = "I1";
	String dialogue_thai_HesOurFriend = "I2";
	String dialogue_thai_HeForgotHisPass = "I3";
	String dialogue_thai_WhyDoesItMatterSoMuch = "I4";
	String dialogue_thai_YouJustLikeOrderingOtherPeopleAroundDontYou = "I5";
	String dialogue_thai_HeyYouShouldLetHimIn = "J1";
	String dialogue_thai_DontWorryHeDoesntHaveHisPass = "J2";
	String dialogue_thai_ItllBeFineHesAGoodGuy = "J3";
	String dialogue_thai_BeNiceToHim = "J4";
	
    String oiDialog_mentor1 = "Mentor-5-3-13-Line1";
    String oiDialog_mentor2a = "Mentor-5-3-13-Line2a";
    String oiDialog_mentor2b = "Mentor-5-3-13-Line2b";
    String oiDialog_mentor3 = "Mentor-5-3-13-Line3";
    
    // ## Episodic memory events    
	String event_gaveObject = "event_gaveObject";
	String event_tookObject = "event_tookObject";
	String event_attention = "event_attention";
	String event_coach = "event_coach";
	
    // ## Episodic memory params    
	String eventParam_attention_point = "eventParam_attention_point";
	String eventParam_coach_mirroredGreeting = "eventParam_coach_mirroredGreeting";
	

	/**
	 * createSocialSignalWME
	 */

	sequential behavior createSocialSignalWME(SocialInterpretation interpretation, String initiator, String recipient) {
		subgoal createSocialSignalWME(interpretation, initiator, recipient, "");
	}
	 
	// simply refresh timestamp of existing common proximity WMEs, so we don't have hundreds of them created
	sequential behavior createSocialSignalWME(SocialInterpretation interpretation, String initiator, String recipient, String param) {
		precondition { 	(interpretation == SocialInterpretation.VERY_CLOSE)
						previousProximityWME=(SocialSignalWME chosenInterpretation==interpretation
																sender==initiator 
																primaryRecipient==recipient) }
		specificity 2;
		mental_act {
			log.info("Updating timestamp for existing SocialSignalWME " +interpretation+ " from " +initiator+ " to " +recipient);
			previousProximityWME.updateTimestamp();
		}
	}
	
	sequential behavior createSocialSignalWME(SocialInterpretation interpretation, String initiator, String recipient, String param) {
		specificity 1;
		mental_act {
			log.info("Creating new SocialSignalWME " +interpretation+ " from " +initiator+ " to " +recipient);
			SocialSignalWME signalWME = new SocialSignalWME(interpretation, initiator, recipient);
			signalWME.setParam(param);
			BehavingEntity.getBehavingEntity().addWME(signalWME);			
		}
	}

	/**
	 * createEpisodicMemoryWME
	 */
	sequential behavior createEpisodicMemoryWME(String characterName, String episodeName) {
		subgoal createEpisodicMemoryWME(characterName, "", episodeName, "");
	}
	
	sequential behavior createEpisodicMemoryWME(String characterName, String recipientName, String episodeName) {
		subgoal createEpisodicMemoryWME(characterName, recipientName, episodeName, "");
	}
	
	sequential behavior createEpisodicMemoryWME(String characterName, String recipientName, String episodeName, String episodeParam) {
		mental_act {
			//if (recipientName.equals("")) log.info(characterName + " creating episodic memory for " +episodeName);
			//else log.info(characterName + " creating episodic memory for " +episodeName+ " to " +recipientName);
			EpisodicMemoryWME epMemWME = new EpisodicMemoryWME(characterName, recipientName, episodeName);
			if (episodeParam.equals("") == false) epMemWME.setEpisodeParam(episodeParam); 	
			BehavingEntity.getBehavingEntity().addWME(epMemWME);			
		}
	}
	
	
	/**
	 * searchEpisodicMemory()
	 * Search for the existence of a previously terminated SIU that matches the parameters and more recent than the timeout given 
	 */
	sequential behavior searchEpisodicMemory(String siuName, String initiatorName, String responderName, int cRecentSIUTimeout) {
		precondition { 	executeSiuWME=(ExecuteSiuWME initiatorWME::initiator  responderWME::responder) 
						(executeSiuWME.getState() == SiuExecutionState.TERMINATED) 
						(executeSiuWME.getBehaviorSetName().equals(siuName)) 
						(executeSiuWME.isRecentWithinLast(cRecentSIUTimeout) == true) 
						(initiator.getName().equals(initiatorName)) 
						(responder.getName().equals(responderName)) 
						}
		succeed_step;
	}
	


    /**
     *  findClosestCharacterInCharactersWME
     */
	sequential behavior findClosestCharacterInCharactersWME(CharactersWME charactersWME, ReturnValueWME retValWME) {
		Iterator iterator;
		mental_act { 
			iterator = charactersWME.getCharacterWMEs().iterator();
			retValWME.setString("");
			retValWME.setFloat(0); 
		}
		with (ignore_failure) subgoal findClosestCharacterInCharactersWME_main(iterator, retValWME);
	}

	
	sequential behavior findClosestCharacterInCharactersWME_main(Iterator iterator, ReturnValueWME retValWME) {
		with (persistent when_succeeds)
			subgoal findClosestCharacterInCharactersWME_senseLoop(iterator, retValWME);
	}

	sequential behavior findClosestCharacterInCharactersWME_senseLoop(Iterator iterator, ReturnValueWME retValWME) {
		precondition { (iterator.hasNext()) }
		CharacterWME characterWME;
		String myName;
		mental_act { 
			characterWME = iterator.next();
			myName = characterWME.getName(); 
		}
		subgoal findClosestCharacterInCharactersWME_sense(myName, retValWME);
	}

	sequential behavior findClosestCharacterInCharactersWME_sense(String myName, ReturnValueWME retValWME) {
		precondition {	myPhysicalWME = (PhysicalAgentWME)
                     	(myPhysicalWME.getId().equals(myName)) 
						playerPhysicalWME = (PhysicalAgentWME)
                     	(playerPhysicalWME.getId().equals(playerName)) 
                     	}
        mental_act {
        	float dist;
        	dist = (float)Staging.getXZDistanceBetweenPoints(myPhysicalWME.getLocation(), playerPhysicalWME.getLocation());
        	//log.info("Comparing " +myName+ " dist " +dist+ " to last dist " +retValWME.getFloat()+ " for " +retValWME.getString());
        	if (retValWME.getString().equals("") || (dist < retValWME.getFloat())) {
				retValWME.setString(myName);
				retValWME.setFloat(dist);
			} 
        }
	}


	
	/**
	 * Set effect_only on the grandparent of this behavior
	 * The calling behavior (e.g. genericIdle) is our parent
	 * By convention, our parent's parent is an SIU behavior step, that we want to make effect_only
	 */
	sequential behavior setParentEffectOnly(boolean bVal) {
		mental_act {
			BehaviorWME parentBehavior = getReflectionWME().getParent().getParent().getParent(); 
			GoalStepWME parentGoalStep = parentBehavior.getParent();
			BehaviorWME grandparentBehavior = parentGoalStep.getParent(); 
			GoalStepWME grandparentGoalStep = grandparentBehavior.getParent();
			log.info("Setting effect_only to " +bVal+ " for " +grandparentGoalStep.getSignature()); 
			grandparentGoalStep.setEffectOnly(bVal); 
		}
	}


	/**
	 * waitForActiveStep -- utility that waits until a SIU behavior step is chosen to be the active step
	 */	 
	sequential behavior waitForActiveStep(int myUid, BehaviorSetStatusWME behaviorSetStatusWME, 
											String siuNickname, String siuSignature) { 

		//mental_act { log.info(siuNickname+ " waiting to start"); }

		// ## wait to begin
		/* FIXME: If the Abl compiler could compare property values in test expressions, we could write this success_test this way
		with (success_test { 
				(GoalStepWME uid == myUid  signature == siuSignature  stepIndex::stepIndexProperty)  
				(stepIndexProperty == behaviorSetStatusWME.getCurrentStepIndex()) } ) 
			wait;
		*/				
		
		// ## wait to begin
		with (success_test { 
				(GoalStepWME 
					uid != null  uid::uid  
					signature == siuSignature 
					stepIndex != null  stepIndex::stepIndexProperty)	
				(((Integer)uid).intValue() == myUid)
				(((Integer)stepIndexProperty).intValue() == behaviorSetStatusWME.getCurrentStepIndex()) } )
			wait;
	}
	

	/**
	 * demon_advanceBehaviorSetStep
	 */	 
	sequential behavior demon_advanceBehaviorSetStep(int myUid) {
		precondition { behaviorSetStatusWME = (BehaviorSetStatusWME) (behaviorSetStatusWME.uidEquals(myUid)) }	

		int currentStepIndex;
		mental_act { currentStepIndex = behaviorSetStatusWME.getCurrentStepIndex(); }
		 
		// wait until there is no unfinished behavior-set step behavior with the current step index
		// FIXME: If the Abl compiler could compare property values in test expressions, we could write this success_test this way
		// with (success_test { !(GoalStepWME uid == myUid  stepIndex == currentStepIndex) } ) wait;
		// FIXME: instead we have to do all this
		with (ignore_failure) subgoal demon_advanceBehaviorSetStep_BANDAIDWAIT(myUid, currentStepIndex);
		
		// increment the current step index		
		mental_act { 
			++currentStepIndex;
			//log.info("Increment step counter for behavior-set uid " +myUid+ " to " +currentStepIndex);			
			behaviorSetStatusWME.setCurrentStepIndex(currentStepIndex);			
		}
	}

	// only fail once it can't find a behavior with the current stepIndex
	sequential behavior demon_advanceBehaviorSetStep_BANDAIDWAIT(int myUid, int currentStepIndex) {
		with (persistent when_succeeds) subgoal demon_advanceBehaviorSetStep_BANDAIDTEST(myUid, currentStepIndex);
	}	 
	sequential behavior demon_advanceBehaviorSetStep_BANDAIDTEST(int myUid, int currentStepIndex) {
		precondition { 	(GoalStepWME uid != null  uid::uid  stepIndex != null  stepIndex::stepIndex) 
						(((Integer)uid).intValue() == myUid)
						(((Integer)stepIndex).intValue() == currentStepIndex) }
		succeed_step;
	}


	/**
	 * waitFor()
	 * Generic wait behavior
	 */
	sequential behavior waitFor(int milliseconds) {
		long finish;
		mental_act { 
			finish = System.currentTimeMillis() + milliseconds; 
		}
		
		with ( success_test { (System.currentTimeMillis() > finish) } ) wait;
	}
	
	/**
  	 * waitFor()
	 * Long variant
	 */
	sequential behavior waitFor(long milliseconds) {
		long finish;
		mental_act { 
			finish = System.currentTimeMillis() + milliseconds; 
		}

		with ( success_test { (System.currentTimeMillis() > finish) } ) wait;
	}
	
	/**
  	 * waitFor()
	 * Float variant, in seconds
	 */
	sequential behavior waitFor(float seconds) {
		long finish;
		mental_act { 
			finish = System.currentTimeMillis() + (long)(seconds*1000); 
		}

		with ( success_test { (System.currentTimeMillis() > finish) } ) wait;
	}

	/**
  	 * waitForRand()
	 * Generic wait behavior, between start and endMillis
	 */
	sequential behavior waitForRand(int startMillis, int endMillis) {
		int waitTime;
		mental_act {
			if (startMillis < 0) startMillis = 0;
			
			if (endMillis <= startMillis) {
				waitTime = startMillis;
			} else {
				waitTime = startMillis + randGen.nextInt(endMillis - startMillis);
			}
		}
		
		subgoal waitFor(waitTime);
	}

	/**
  	 * waitThenFail()
	 * Generic wait behavior that explicitly fails if the time runs out
	 */
	sequential behavior waitThenFail(int milliseconds) {
		long finish;
		mental_act { 
			finish = System.currentTimeMillis() + milliseconds; 
		}

		with ( success_test { (System.currentTimeMillis() > finish) } ) wait;
		fail_step;
	}

	
	/**
	* timeoutWait()
	*/
	sequential behavior timeoutWait(int timeout, String msg1, String msg2, String msg3) {
		subgoal waitFor(timeout);
		mental_act { log.info("WARNING: " +msg1+ " " +msg2+ " " +msg3); }										
	}




	/**
  	 * print()
	 * Generic print behavior 
	 */
	sequential behavior print(String a)
	{
		mental_act {
			log.info(a);
		}
	}

	/**
	 * profiler behaviors
	 */	 
	
	sequential behavior startProfiler() {
		mental_act { AblProfiler.getInstance();}
	}
	
	sequential behavior profilerContentsToLog() {
		subgoal waitFor(10000);
		mental_act { AblProfiler.getInstance().printLog();}
	}

	
	/**
	 * printPlayerPosition
	 */	 
	sequential behavior printPlayerPosition() {
		precondition {	playerPhysicalWME = (PhysicalAgentWME)
                     	(playerPhysicalWME.getId().equals(playerName)) }
		mental_act { log.info("Player is at " +playerPhysicalWME.getLocation()); }
		subgoal waitFor(2000);
	}
	
	  
 	/**
	 * stepToPoint() checking if player is in group or not
	 */	 	
   sequential behavior stepToPoint(String myName, Location dest, GroupWME groupWME) {
		precondition {	//(false) // COMMENT IN TO DO INSTANTANEOUS JUMPCUT
						playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName))
            			(groupWME.contains(playerCharacterWME))
            			}
		specificity 2;
		subgoal stepToPoint_NEW(myName, dest);
	}
	
   sequential behavior stepToPoint(String myName, Location dest, GroupWME groupWME) {
		specificity 1;
		subgoal teleportToPoint(myName, dest);
	}
	
		  
 	/**
	 * stepToPoint()
	 */	 	
   sequential behavior stepToPoint_NEW(String myName, Location dest) {
		precondition { characterWME=(CharacterWME) (characterWME.getName().equals(myName)) }
		
		MovementCompleteWME movementCompleteWME; 
		long timestamp;     
      
      	mental_act { 
         	__$thisEntity.deleteAllWMEClass("MovementCompleteWME");
         	log.info(myName+ " starting step towards point: " + dest);
			characterWME.setCurrentAnim(animationWalk);
			timestamp = System.currentTimeMillis();
		}  
            
		act moveToCartesianPoint(myName, dest, true);
      
		// wait for the walk to complete!
		subgoal movement_waitWithTimeout(myName, 7000, "step");
                        
		mental_act { 
			log.info(myName+ " finished step towards point: " +dest);
			if (System.currentTimeMillis() - timestamp > 5000) log.info("-------- WARNING: " +myName+ " step took " +(System.currentTimeMillis() - timestamp)+ "ms");
			characterWME.setCurrentAnim("");      		
		}                              

   }

 	/**
	 * movement_waitWithTimeout()
	 */	 	
	parallel behavior movement_waitWithTimeout(String myName, int timeout, String movementName) {
		number_needed_for_success 1;
	
		// wait for the movement to complete
		subgoal movement_wait(myName, movementName);			
	
		// timeout in case we never receive the MovementCompleteWME
		subgoal timeoutWait(timeout, "Never received MovementCompleteWME for", myName, movementName);
	}

	sequential behavior movement_wait(String myName, String movementName) {
		MovementCompleteWME movementCompleteWME;
		
		// wait for the movement to complete
		with (success_test {	movementCompleteWME = (MovementCompleteWME)        
								(movementCompleteWME.getId().equals(myName)) } ) wait;								

		mental_act {
			__$thisEntity.deleteWME(movementCompleteWME); 
		}                              
	}
	  
  
 	/**
	 * walkToPoint()
	 */	 	
   sequential behavior walkToPoint(String myName, Location dest) {
		precondition { characterWME=(CharacterWME) (characterWME.getName().equals(myName)) }
		
		long timestamp;     
      
      	mental_act { 
         	__$thisEntity.deleteAllWMEClass("MovementCompleteWME");
         	log.info(myName+ " starting walk towards point: " + dest);
			characterWME.setCurrentAnim(animationWalk);
			timestamp = System.currentTimeMillis();
		}  
            
      act moveToCartesianPoint(myName, dest, false);	// false means turn towards destination before starting to walk
      
		// wait for the walk to complete!
		subgoal movement_waitWithTimeout(myName, 20000, "walk");
                        
		mental_act {
			log.info(myName+ " finished walk towards point: " +dest); 
			if (System.currentTimeMillis() - timestamp > 5000) log.info("-------- WARNING: " +myName+ " walk took " +(System.currentTimeMillis() - timestamp)+ "ms");
			characterWME.setCurrentAnim("");      		
		}                              

   }


 	/**
	 * turnToAngle() checking if player is in group or not
	 */	 	
	sequential behavior turnToAngle(String myName, double angleToOrientTo, GroupWME groupWME) {
		precondition {	//(false) // COMMENT IN TO DO INSTANTANEOUS JUMPCUT
						playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName))
            			(groupWME.contains(playerCharacterWME))
            			}
		specificity 2;
		subgoal turnToAngle_NEW(myName, angleToOrientTo);
	}
	
	sequential behavior turnToAngle(String myName, double angleToOrientTo, GroupWME groupWME) {
		specificity 1;
		subgoal jumpcutToAngle(myName, angleToOrientTo);
	}
	
		  
 	/**
	 * turnToAngle()
	 */	 	
   sequential behavior turnToAngle_NEW(String myName, double angleToOrientTo) {
		precondition { characterWME=(CharacterWME) (characterWME.getName().equals(myName)) }
		
      MovementCompleteWME movementCompleteWME;      
      float angle;            
		long timestamp;
		      
      	mental_act { 
         	__$thisEntity.deleteAllWMEClass("MovementCompleteWME");
			angle = (float)angleToOrientTo;
			log.info(myName+ " turning to " +angle+ " degrees");
			characterWME.setCurrentAnim(animationWalk);
			timestamp = System.currentTimeMillis();
		}  
            
      act orientYAxis(myName, angle, false);	// false means animate the turn, instead of jumpcut
      
		// wait for the turn to complete!
		subgoal movement_waitWithTimeout(myName, 7000, "turn");
                        
		mental_act {
			log.info(myName+ " finished turn to " +angle+ " degrees"); 
			if (System.currentTimeMillis() - timestamp > 5000) log.info("-------- WARNING: " +myName+ " turn took " +(System.currentTimeMillis() - timestamp)+ "ms");
			characterWME.setCurrentAnim("");      		
		}                              
   }


	/**
	 * turnToFacingPoint()
	 */	 	
   sequential behavior turnToFacingPoint(String myName, Location pt) {
		precondition { myPhysicalWME = (PhysicalAgentWME) (myPhysicalWME.getId().equals(myName)) 
                     	charWME = (CharacterWME) (charWME.getName().equals(myName) == true)
                     	groupWME=(GroupWME) (groupWME.contains(charWME))
                     	}
        double angle;
		mental_act { 
			angle = Staging.getXZAngleBetweenPoints(myPhysicalWME.getLocation(), pt);
			angle += Staging.randRange(-3.0, 3.0);
		}
																							
		subgoal turnToAngle(myName, angle, groupWME);
	}


	
	/**
	 * teleportToPoint()
	 */	 	
   sequential behavior teleportToPoint(String myName, Location dest) {
      mental_act { log.info(myName+ " teleporting to point: " + dest); }
      act teleportToCartesianPoint(myName, dest);
   }


	/**
	 * jumpcutToAngle()
	 * jumpcut to an angle in degrees 
	 */	 	
   sequential behavior jumpcutToAngle(String myName, double angleToOrientTo) {
      float angle;            
      mental_act { 
		angle = (float)angleToOrientTo;
		log.info(myName+ " jumpcut orienting to " +angle+ " degrees");
      }              
      act orientYAxis(myName, angle, true);
      
      // fixme: needed so that sensing can catch up
      subgoal waitFor(300);
   }
 
 

	/**
	 * jumpcutToFacingPoint()
	 */	 	
   sequential behavior jumpcutToFacingPoint(String myName, Location pt) {
		precondition {	myPhysicalWME = (PhysicalAgentWME)
                     	(myPhysicalWME.getId().equals(myName))
                     }
        double angle;
		mental_act { 
			angle = Staging.getXZAngleBetweenPoints(myPhysicalWME.getLocation(), pt);
			angle += Staging.randRange(-3.0, 3.0);
		}
																							
		subgoal jumpcutToAngle(myName, angle);
	}

 
		
	/**
	 * headTrack() - target can be a character, location, or player node (e.g. player's hand)
	 * If called for the player to do the head tracking, ignore it
	 */

	// ## character version

	sequential behavior headTrack(String myName, String targetName) {
		subgoal headTrack(myName, targetName, true);
	}
	
	// do nothing if player is to do the headtracking
	sequential behavior headTrack(String myName, String targetName, boolean bPermanentTarget) {
		precondition { (myName.equals(playerName)) }
		specificity 3;
		succeed_step;
 	} 	

	// look straightahead if head tracking self
	sequential behavior headTrack(String myName, String targetName, boolean bPermanentTarget) {
		precondition { (myName.equals(targetName)) }
		specificity 2;
		mental_act { log.info("### WARNING: " +myName+ " requested to headtrack self"); }
		subgoal headTrackOff(myName);
 	} 	

	sequential behavior headTrack(String myName, String targetName, boolean bPermanentTarget) {
		precondition { characterWME=(CharacterWME) (characterWME.getName().equals(myName)) }
		specificity 1;
		mental_act {		 

			characterWME.setHeadtrackTarget(targetName);
		
			// if this is the permanent (not temporary) target, cache it in case we look away temporarily later
			if (bPermanentTarget) {
				//*/log.info(myName + " headtracking " +targetName); 
				characterWME.setHeadtrackTargetCache(targetName);
				characterWME.setBLookingAtTemporaryHeadtrack(false);
				
			} else {
				//*/log.info(myName + " temporary headtracking " +targetName); 
				characterWME.setBLookingAtTemporaryHeadtrack(true);
			}			
		}
		
		act headTrack(myName, targetName);
		subgoal setAwareness(myName, targetName);
 	}


	// ## location version

	sequential behavior headTrack(String myName, Location targetLocation) {
		subgoal headTrack(myName, targetLocation, true);
	}
	
	// ignore request for player to do headtracking
	sequential behavior headTrack(String myName, Location targetLocation, boolean bPermanentTarget) {
		precondition { (myName.equals(playerName)) }
		specificity 2;
		succeed_step;
 	} 	
	sequential behavior headTrack(String myName, Location targetLocation, boolean bPermanentTarget) {
		precondition {	characterWME=(CharacterWME)
                     	(characterWME.getName().equals(myName))
                     } 
		specificity 1;
		mental_act { 

      		characterWME.setHeadtrackTarget("location");
      		characterWME.setHeadtrackLocation(targetLocation);

			// if this is the permanent (not temporary) target, cache it in case we look away temporarily later
			if (bPermanentTarget) { 
				//*/log.info(myName + " headtracking location " +targetLocation); 
				characterWME.setHeadtrackLocationCache(targetLocation);
				characterWME.setBLookingAtTemporaryHeadtrack(false);
			} else {
				//*/log.info(myName + " temporary headtracking location " +targetLocation); 
				characterWME.setBLookingAtTemporaryHeadtrack(true);
			}			
		}
		
		act headTrack(myName, targetLocation);
 	}
 		

	// ## node version

	sequential behavior headTrack(String myName, MiBA_SJ headTrackPlayerNode) {
		subgoal headTrack(myName, headTrackPlayerNode, true);
	}
	
	// ignore request for player to do headtracking
	sequential behavior headTrack(String myName, MiBA_SJ headTrackPlayerNode, boolean bPermanentTarget) {
		precondition { (myName.equals(playerName)) }
		specificity 2;
		succeed_step;
 	} 	
	sequential behavior headTrack(String myName, MiBA_SJ headTrackPlayerNode, boolean bPermanentTarget) {
		precondition {	characterWME=(CharacterWME)
                     	(characterWME.getName().equals(myName))
                     } 
		specificity 1;
		mental_act { 

      		characterWME.setHeadtrackTarget("node");
      		characterWME.setHeadtrackNode(headTrackPlayerNode);

			// if this is the permanent (not temporary) target, cache it in case we look away temporarily later
			if (bPermanentTarget) { 
				//*/log.info(myName + " headtracking player node " +headTrackPlayerNode); 
				characterWME.setHeadtrackNodeCache(headTrackPlayerNode);
				characterWME.setBLookingAtTemporaryHeadtrack(false);
			} else {
				//*/log.info(myName + " temporary headtracking node " +headTrackPlayerNode); 
				characterWME.setBLookingAtTemporaryHeadtrack(true);
			}			
		}
		
		act headTrack(myName, playerName, headTrackPlayerNode);
 	}
 	

	/**
	 * headTrackOthersHeldObject() 
	 * If character isn't holding an object, just do normal headtracking
	 */
	sequential behavior headTrackOthersHeldObject(String myName, String targetName, MiBA_SJ headTrackPlayerNode) {
		subgoal headTrackOthersHeldObject(myName, targetName, headTrackPlayerNode, true);
	}
   
   // if they are not holding an object, just do normal headtracking
   sequential behavior headTrackOthersHeldObject(String myName, String targetName, MiBA_SJ headTrackPlayerNode, boolean bPermanentTarget, boolean useNode) {
		precondition {	targetCharacterWME=(CharacterWME)
                        (targetCharacterWME.getName().equals(targetName) &&
                         targetCharacterWME.getObjectHeld().equals("") == true)
                     } 
		specificity 3;
   		subgoal headTrack(myName, targetName, bPermanentTarget);
   }
   
   // if player node requested, do it
   sequential behavior headTrackOthersHeldObject(String myName, String targetName, MiBA_SJ headTrackPlayerNode, boolean bPermanentTarget, boolean useNode) {
		precondition { (targetName.equals(playerName) && useNode) }
		specificity 2;
   		subgoal headTrack(myName, headTrackPlayerNode, bPermanentTarget);
   }
   
   // BANDAID - head track a point in space representing an object held in the hands of the target.
   sequential behavior headTrackOthersHeldObject(String myName, String targetName, MiBA_SJ headTrackPlayerNode, boolean bPermanentTarget, boolean useNode) {
      precondition { targetPhysicalWME = (PhysicalAgentWME)
                        (targetPhysicalWME.getId().equals(targetName))
                        characterWME=(CharacterWME)
                        (characterWME.getName().equals(myName))
                     } 
      specificity 1;
      Location lookToPoint;    
      Location objectOffset;
      mental_act {
             
         lookToPoint = new Location(targetPhysicalWME.getLocation().getX(), cCharacterHeight, targetPhysicalWME.getLocation().getZ());
         //lookToPoint now has them looking at the target's head. Subtract a little from the Y Axis to simulate having them look at the target's 'hand'
         objectOffset = new Location(0, cHeldObjectOffset, 0);
         lookToPoint.subtract(objectOffset);

      		characterWME.setHeadtrackTarget("location");
      		characterWME.setHeadtrackLocation(lookToPoint);
         
			// if this is the permanent (not temporary) target, cache it in case we look away temporarily later
         if (bPermanentTarget) {
            //*/log.info(myName + " headtracking " +targetName+ " (using location)"); 
            characterWME.setHeadtrackTargetCache("location");
            characterWME.setHeadtrackLocationCache(lookToPoint);
            characterWME.setBLookingAtTemporaryHeadtrack(false);
            
         } else {
            //*/log.info(myName + " temporary headtracking " +targetName+ " (using location)"); 
            characterWME.setBLookingAtTemporaryHeadtrack(true);
         }        
      }
      
      act headTrack(myName, lookToPoint);
      subgoal setAwareness(myName, targetName);
   }
   
   
	/**
	 * headTrackOwnHeldObject() - e.g. look at photo held in own hand
	 */
   // BANDAID - head track a point in space representing an object held in the character's own hand.
   //, but it's not dynamically updated! Will probably ultimately replace this with a straight up animation.
   sequential behavior headTrackOwnHeldObject(String myName, boolean bPermanentTarget) {
      precondition { characterPhysicalWME = (PhysicalAgentWME)
                        (characterPhysicalWME.getId().equals(myName))
                        characterWME=(CharacterWME)
                        (characterWME.getName().equals(myName))
                     } 
      specificity 1;
      Location lookToPoint;    
      mental_act { 
      
         lookToPoint = new Location(characterPhysicalWME.getLocation().getX(), 0.5, characterPhysicalWME.getLocation().getZ());

      		characterWME.setHeadtrackTarget("location");
      		characterWME.setHeadtrackLocation(lookToPoint);
         
			// if this is the permanent (not temporary) target, cache it in case we look away temporarily later
         if (bPermanentTarget) {
            //*/log.info(myName + " headtracking own held object"); 
            characterWME.setHeadtrackTargetCache("location");
            characterWME.setHeadtrackLocationCache(lookToPoint);
            characterWME.setBLookingAtTemporaryHeadtrack(false);
            
         } else {
            //*/log.info(myName + " temporary headtracking own held object"); 
            characterWME.setBLookingAtTemporaryHeadtrack(true);
         }        
      }
      
      act headTrack(myName, lookToPoint);
      //subgoal setAwareness(myName, targetName);
   }


	/**
	 * headTrackOff()
	 */
	// ignore request for player
	sequential behavior headTrackOff(String myName) {
		precondition { (myName.equals(playerName)) }
		specificity 2;
		succeed_step;
 	}
 	
	sequential behavior headTrackOff(String myName) {
		precondition {	characterWME=(CharacterWME)
                     	(characterWME.getName().equals(myName))
                     }
		specificity 1;
		mental_act { 
			//*/log.info(myName + " turning headtracking off"); 
			characterWME.setHeadtrackTargetCache("off");
			characterWME.setBLookingAtTemporaryHeadtrack(false);
		}
		act headTrackOff(myName);
 	}



	/**
	 * restoreCachedHeadTrack()
	 */
	
	// null version (head track was off)
	sequential behavior restoreCachedHeadTrack(String myName) {
		precondition {	characterWME=(CharacterWME)
                     	(characterWME.getName().equals(myName) &&
                     	 characterWME.getHeadtrackTargetCache().equals("off"))
                     }
        specificity 4;
        //mental_act { log.info(myName+ " restoring headtrack to off"); } 
		subgoal headTrackOff(myName);
    }
	
	// location version
	sequential behavior restoreCachedHeadTrack(String myName) {
		precondition {	characterWME=(CharacterWME)
                     	(characterWME.getName().equals(myName) &&
                     	 characterWME.getHeadtrackTargetCache().equals("location"))
                     }
        specificity 3;
        Location location;
        mental_act { 
        	//log.info(myName+ " restoring headtrack to a location"); 
        	location = characterWME.getHeadtrackLocationCache(); 
        }
		subgoal headTrack(myName, location);
	}
	
	// node version
	sequential behavior restoreCachedHeadTrack(String myName) {
		precondition {	characterWME=(CharacterWME)
                     	(characterWME.getName().equals(myName) &&
                     	 characterWME.getHeadtrackTargetCache().equals("node"))
                     }
        specificity 2;
        MiBA_SJ headTrackPlayerNode;
        mental_act { 
        	//log.info(myName+ " restoring headtrack to a node"); 
        	headTrackPlayerNode = characterWME.getHeadtrackNodeCache(); 
        }
		subgoal headTrack(myName, headTrackPlayerNode);
	}
	
	// character version
	sequential behavior restoreCachedHeadTrack(String myName) {
		precondition {	characterWME=(CharacterWME)
                     	(characterWME.getName().equals(myName))
                     }
        specificity 1;
        String target;
        mental_act { 
        	//log.info(myName+ " restoring headtrack to " +target); 
        	target = characterWME.getHeadtrackTargetCache(); 
        }
		subgoal headTrack(myName, target);
	}
	


	/**
	 * clearFace()
	 */
	sequential behavior clearFace(String myName) {
		subgoal clearFace(myName);
 	}
 	
	// ignore request for player
	sequential behavior clearFace(String myName) {
		precondition { (myName.equals(playerName)) }
		specificity 2;
		succeed_step;
 	}
 	
	sequential behavior clearFace(String myName) {
		specificity 1;
		mental_act { log.info(myName + " clear face -- DISABLED FOR NOW"); }
		//mental_act { log.info(myName + " clear face"); }
		//act clearFace(myName);
 	}
 	
 	

	/**
	 * glanceAmongCharacters()
	 */	 
	sequential behavior glanceAmongCharacters(String myName, CharactersWME charactersWME) {
        Iterator iterator;
		mental_act { iterator = charactersWME.iterator(); } 
		with (ignore_failure) subgoal glanceAmongCharacters_main(iterator, myName);
	}
	
	// loop idiom
	sequential behavior glanceAmongCharacters_main(Iterator iterator, String myName) {
		with (persistent when_succeeds) subgoal glanceAmongCharacters_loop(iterator, myName);
	}
				
	sequential behavior glanceAmongCharacters_loop(Iterator iterator, String myName) {
		precondition { (iterator.hasNext()) }						
		CharacterWME otherCharacterWME;
		String otherCharacterName;
		mental_act { 
			otherCharacterWME = iterator.next();
			otherCharacterName = otherCharacterWME.getName(); 
		}
		subgoal headTrack(myName, otherCharacterName);
		subgoal waitForRand(800, 1200);
	}
	


	/**
	 * headNod()
	 */
	sequential behavior headNod(String headNodAnim, String fromName, String toName) {
		subgoal performAnimation_portion(fromName, toName, headNodAnim, 0.26f, cAnimDefaultEndTime);		
	}

	parallel behavior headNod(String headNodAnim, String fromName, String toName, String baseAnim, float startTime, float endTime) {	
		with (priority_modifier 2) subgoal headTrackOff(fromName);
		with (priority_modifier 1) subgoal headNod(headNodAnim, fromName, toName);
		subgoal performAnimation_portion(fromName, toName, baseAnim, startTime, endTime); 		
	}	
 

	/**
	 * printAngleToPlayer()
	 */	 	
	sequential behavior printAngleToPlayer(String myName) {
		precondition {	myPhysicalWME = (PhysicalAgentWME)
                     	(myPhysicalWME.getId().equals(myName))
						playerPhysicalWME = (PhysicalAgentWME)
                     	(playerPhysicalWME.getId().equals(playerName))
                     	}
		mental_act {			
			double angle = (float)Staging.normalize0to360(
	                     Staging.getXZAngleBetweenPoints(myPhysicalWME.getLocation(), 
	                                                     playerPhysicalWME.getLocation()));
			log.info(myName+ " angle to player: " +angle);
		}
	}


 	
	/**
	 * managePlayerArmExtendedFlag()
	 * set or clear armExtended flag for player
	 */
	sequential behavior managePlayerArmExtendedFlag(SocialInterpretation interpretation, boolean bVerbal) {
		precondition { playerCharacter=(CharacterWME) (playerCharacter.getName().equals(playerName)) }		
		mental_act {
			boolean bOrigArmExtended = playerCharacter.getBArmExtended();

			// if this is a non-verbal signal
			if (bVerbal == false) { 
				
				if (interpretation == socialInterpretationExtendHand) {
					playerCharacter.setBArmExtended(true);
				}
	
				else if (interpretation == socialInterpretationGreetingWaveFriendly ||
						interpretation == socialInterpretationExamineID ||
						interpretation == socialInterpretationBeckon ||
						interpretation == socialInterpretationWrongBeckon ||
						interpretation == socialMoveRequest ||
						interpretation == socialInterpretationCalmSelfDown ||
						interpretation == socialInterpretationDismiss) {
					playerCharacter.setBArmExtended(false);
				}
				
				if (bOrigArmExtended != playerCharacter.getBArmExtended()) {
					if (bOrigArmExtended) log.info("Player's arm is now not extended");  
					else log.info("Player's arm is now extended");  
				}
			}
		}
	}
	 
			
			
	/**
	 * speakDialogue()
	 */
	// ignore if audioName is null, for easier authoring
	sequential behavior speakDialogue(String speaker, String audioName, boolean bComposableFilename, String gender, String tone) {
		precondition { (audioName.equals("") == true) }
		specificity 2;
		succeed_step;
	}
	
	sequential behavior speakDialogue(String speaker, String audioName, boolean bComposableFilename, String gender, String tone) {
		specificity 1;
		
		// if requested, construct the audio name, e.g. "MaleNeutralE2"
		mental_act {
			if (bComposableFilename) audioName = gender + tone + audioName;
			
			log.info(speaker+ " speaking " +audioName);
		}
		
		act performAction(speaker, "", "UTTER_CANNED_AUDIO", audioName); 
		
		//mental_act { log.info("Waiting for " +speaker+ " audio " +audioName+ " to complete"); } 		

		subgoal speakDialogue_waitWithTimeout(speaker, audioName);

		//mental_act { log.info("Done waiting for " +speaker+ " audio " +audioName+ " to complete"); } 		
	}


	parallel behavior speakDialogue_waitWithTimeout(String fromName, String audioName) {
		number_needed_for_success 1;
	
		// wait for the audio to complete
		subgoal speakDialogue_wait(fromName, audioName);			
	
		// timeout in case we never receive the AudioCompleteWME
		subgoal timeoutWait(8000, "Never received AudioCompleteWME for", fromName, audioName);
	}

	sequential behavior speakDialogue_wait(String fromName, String audioName) {
		AudioCompleteWME audioCompleteWME;
		
		// wait for the audio to complete
		with (success_test {	audioCompleteWME = (AudioCompleteWME)			
								(audioCompleteWME.getAgentId().equals(fromName)) 
								(audioCompleteWME.getAudioId().equals(audioName)) 
								} ) wait;
								
		mental_act {
			log.info("audioCompleteWME " + audioCompleteWME);
			log.info("audioCompleteWME.getAgentId() " + audioCompleteWME.getAgentId());
			log.info("audioCompleteWME.getAudioId() " + audioCompleteWME.getAudioId());
			__$thisEntity.deleteWME(audioCompleteWME); 
		}
	}
	
		
	/**
	 * speakDialogueAfterRandomDelay()
	 */
	// ignore if audioName is null, for easier authoring
	sequential behavior speakDialogueAfterRandomDelay(String fromName, String audioName, int waitStartMillis, int waitEndMillis,
														boolean bComposableFilename, String gender, String tone) {
		precondition { (audioName.equals("") == true) }		
		specificity 2;								
		succeed_step;						
	}
															
	sequential behavior speakDialogueAfterRandomDelay(String fromName, String audioName, int waitStartMillis, int waitEndMillis,
														boolean bComposableFilename, String gender, String tone) {
		specificity 1;
		subgoal waitForRand(waitStartMillis, waitEndMillis);
		subgoal speakDialogue(fromName, audioName, bComposableFilename, gender, tone);
	}
	
	 	
	/**
	 * speakCoachDialogue()
	 */
	sequential behavior speakCoachDialogue(String audioName) {
		mental_act { log.info("Speaking coach audio " +audioName); } 
		
     	act performAction("Coach", "", "UTTER_CANNED_AUDIO", audioName);
     	
		subgoal waitFor(5000);	// fixme: replace with completionWME
     }

	
	/**
	 * performAnimation()
	 */
	// ignore if animName is null, for easier authoring
	sequential behavior performAnimation(String fromName, String toName, String animName) {
		precondition { (animName.equals("") == true) }
		specificity 2;
		succeed_step;
	}
	sequential behavior performAnimation(String fromName, String toName, String animName) {
		specificity 1;
		subgoal performAnimation(fromName, toName, animName, true,
									cAnimDefaultStartTime, cAnimDefaultEndTime, cAnimDefaultSpeed,
									cAnimDefaultCrossfadeDuration, eLoopModeDefault);	
	}
		
	sequential behavior performAnimation(String fromName, String toName, String animName, boolean bGrabBodyResource) {
		subgoal performAnimation(fromName, toName, animName, bGrabBodyResource,
									cAnimDefaultStartTime, cAnimDefaultEndTime, cAnimDefaultSpeed,
									cAnimDefaultCrossfadeDuration, eLoopModeDefault);	
	}
			
	sequential behavior performAnimation(String fromName, String toName, String animName, boolean bGrabBodyResource,
											float startTime, float endTime, float speed,
											float crossFadeDuration, AnimationLoopMode loopMode) {
		precondition { characterWME=(CharacterWME) (characterWME.getName().equals(fromName)) }
		boolean bWaitForBodyResource;
		int duration;

		// this hack made animations wait till current walk is complete
		//subgoal demoHackAnimWait(characterWME);
		
		with (ignore_failure) subgoal printWarningAboutInterruptingLocomotion(characterWME);
			
		with (ignore_failure) subgoal deleteAllAnimationCompletionWMEsFor(fromName, animName);										
		
		mental_act { 
			characterWME.setCurrentAnim(animName);
			
			// fixme remove
			duration = 1000000;
			if (endTime != cAnimDefaultEndTime) duration = (int)(endTime*1000); 

			if (animName.substring(0,4).equals("FACE") == false) {
				log.info(fromName+ " animating " +animName);
			}
		}
		
		act performActionEx(fromName, 
							fromName/*toName*/,	// using toName here causes agent to face toName, which we want to do separately 
							animName, "",
							loopMode, crossFadeDuration,
							speed, startTime, endTime);
				
		// wait for the animation to complete
		subgoal performAnimation_waitWithTimeout(fromName, animName, duration);
	}


	/*
	// DEMO HACK: don't allow turns or walks to be interrupted by new animations
	parallel behavior demoHackAnimWait(CharacterWME characterWME) {
		number_needed_for_success 1;		
		with (success_test { (characterWME.getCurrentAnim().equals(animationWalk) == false) } ) wait;
		subgoal demoHackAnimWait_wait(characterWME);
	}
	
	sequential behavior demoHackAnimWait_wait(CharacterWME characterWME) {
		subgoal waitFor(5000);
		mental_act { log.info("---------- WARNING: " +characterWME.getName()+ " locomotion/turn wait timeout"); }		
	}
	*/
	

	sequential behavior printWarningAboutInterruptingLocomotion(CharacterWME characterWME) {
		precondition { (characterWME.getCurrentAnim().equals(animationWalk) == true) }
		mental_act { log.info("---------- WARNING: " +characterWME.getName()+ " interrupting locomotion with animation"); }		
	}
	
		
	parallel behavior performAnimation_waitWithTimeout(String fromName, String animName, int duration) {
		number_needed_for_success 1;
		
		// wait for the animation to complete
		subgoal performAnimation_wait(fromName, animName);
		
		// fixme: BANDAID until animation duration is fixed
		subgoal waitFor(duration);
		
		// timeout in case we never receive the AnimationCompleteWME
		subgoal timeoutWait(10000, "Never received AnimationCompleteWME for", fromName, animName);
	}

	sequential behavior performAnimation_wait(String fromName, String animName) {
		specificity 1;
		AnimationCompleteWME animationCompleteWME;
	
		// wait for the animation to complete
		with (success_test {	animationCompleteWME = (AnimationCompleteWME)			
								(animationCompleteWME.getAgentId().equals(fromName))
								(animationCompleteWME.getAnimationName().equals(animName)) 
								} ) wait;
								
		mental_act { __$thisEntity.deleteWME(animationCompleteWME); }
	}
			

	/**
	 * performAnimation_portion()
	 */
	sequential behavior performAnimation_portion(String fromName, String toName, String animName,
													float startTime, float endTime) {
		subgoal performAnimation(fromName, toName, animName, false,
											startTime, endTime, cAnimDefaultSpeed,
											cAnimDefaultCrossfadeDuration, eLoopModeDefault);
	}
	
	
	/**
	 * performAnimationAfterRandomDelay()
	 */
	sequential behavior performAnimationAfterRandomDelay(String fromName, String toName, String animName, int waitStartMillis, int waitEndMillis) {
		subgoal waitForRand(waitStartMillis, waitEndMillis);
		subgoal performAnimation(fromName, toName, animName);
	}

	/**
	 * performAnimation_randomSpeed()
	 */
	sequential behavior performAnimation_randomSpeed(String fromName, String toName, String animName, boolean bGrabBodyResource,
			float startTime, float endTime, float speed,
			float crossFadeDuration, AnimationLoopMode loopMode,
			float minSpeed, float maxSpeed) {
		float calculatedSpeed;
		
		mental_act { calculatedSpeed = speed * minSpeed + randGen.nextFloat() * (maxSpeed - minSpeed) ; }
		subgoal performAnimation(fromName, toName, animName, bGrabBodyResource, startTime, endTime, calculatedSpeed, crossFadeDuration, loopMode);
	}
	
	
	/**
	 * performAnimation_randomDuration()
	 */
	parallel behavior performAnimation_randomDuration(String fromCharacterName, String toCharacterName, String animName,
											int minDuration, int maxDuration, boolean bGrabResource) {
		number_needed_for_success 1;
		subgoal performAnimation(fromCharacterName, toCharacterName, animName, bGrabResource);					
		subgoal waitForRand(minDuration, maxDuration);
	}
		
		
	/**
	 * deleteAllAnimationCompletionWMEsFor()
	 * Before starting an animation, clean up any old unabsorbed AnimationCompletionWMEs for this animation 
	 */
	sequential behavior deleteAllAnimationCompletionWMEsFor(String fromName, String animName) {
		with (persistent when_succeeds) subgoal deleteAllAnimationCompletionWMEsFor_loop(fromName, animName); 
	}
	sequential behavior deleteAllAnimationCompletionWMEsFor_loop(String fromName, String animName) {
		precondition { 	animationCompleteWME=(AnimationCompleteWME)
						(animationCompleteWME.getAgentId().equals(fromName))
						(animationCompleteWME.getAnimationName().equals(animName)) } 
		mental_act {		
			//ac log.info("Deleted spurious AnimationCompleteWME " +animationCompleteWME.getAgentId()+ " " +animationCompleteWME.getAnimationName()); 
			__$thisEntity.deleteWME(animationCompleteWME); 
		}						
	}
		 	
		 	
		 	
			
	/**
	 * testbed_setFacialExpressionTendency()
	 */	 	
	sequential behavior testbed_setFacialExpressionTendency(CharacterWME characterWME) {
		
		mental_act {
			boolean bHostile;
			String faceAnim;
			
			bHostile = characterWME.hasAttitude(eAttitudeType_hostile);
			
			if (bHostile) {
				//log.info(characterWME.getName()+ " HOSTILE FACE *****");			
				faceAnim = animationFaceVeryAnnoyed;
				if (Staging.percentChance(30)) faceAnim = animationFaceAngry;
				//else if (Staging.percentChance(10)) faceAnim = animationFaceVeryAnnoyed;
			
			} else {					
				faceAnim = animationFaceSmile;
				if (Staging.percentChance(10)) faceAnim = animationFaceSmile2;
				else if (Staging.percentChance(10)) faceAnim = animationFaceBigSmile;
				else if (Staging.percentChance(10)) faceAnim = animationFaceVeryAnnoyed;
				else if (Staging.percentChance(10)) faceAnim = animationFaceStony;
				else if (Staging.percentChance(10)) faceAnim = animationFaceUnsure;
				else if (Staging.percentChance(10)) faceAnim = animationFaceAnxious;
				else if (Staging.percentChance(10)) faceAnim = animationFaceAnxious2;
				else if (Staging.percentChance(8)) faceAnim = animationFaceNervous;
				else if (Staging.percentChance(8)) faceAnim = animationFaceNervous2;
				else if (Staging.percentChance(8)) faceAnim = animationFaceNervous3;
			}
						  
			characterWME.setFacialExpressionTendency(faceAnim);
			log.info(characterWME.getName()+ " set facial expression tendency to " +faceAnim);
		}
	}
			
			
	/**
	 * attitudeMain() - LISTENING
	 */	 	
	sequential behavior attitudeMain(String myName, String performanceEnum, float requestedDuration, String param) {
		precondition {	(performanceEnum.equals(eAttitudePerform_listen)) 
						myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
						}
		specificity 2;						 
		String anim;
		float duration;
		boolean bHostile;
				
		mental_act {
			bHostile = myCharacterWME.hasAttitude(eAttitudeType_hostile);
		
			if (bHostile) {
				//log.info(myName+ " HOSTILE ANIM *****");			
				anim = animationIdle_Agitated2;
				duration = (float)Staging.randRange(4.0, 6.0);
				if (Staging.percentChance(50)) anim = animationIdle_ArmsCrossed;  			  				
				else if (Staging.percentChance(10)) anim = animationAkimboBothArms;  			  
				else if (Staging.percentChance(20)) anim = animationIdle_AngryAkimbo1;  			  
				else if (Staging.percentChance(10)) anim = animationIdle_Agitated2;  			  
			
			} else {			
				anim = animationIdle_Impatient;
				duration = (float)Staging.randRange(4.0, 6.0);
				if (Staging.percentChance(3)) anim = animationTalkingGestureSerious1;  
				else if (Staging.percentChance(3)) anim = animationTalkingGestureSerious1b;  
				else if (Staging.percentChance(3)) anim = animationScratchChin;  
				else if (Staging.percentChance(3)) anim = animationGestureCough1;
				else if (Staging.percentChance(10)) anim = animationAkimboLeftArm;  			  
				else if (Staging.percentChance(10)) anim = animationAkimboRightArm;  			  
				else if (Staging.percentChance(10)) anim = animationAkimboBothArms;  			  
				else if (Staging.percentChance(10)) anim = animationIdle_AngryAkimbo1;  			  
				else if (Staging.percentChance(10)) anim = animationIdle_Agitated1;  			  
				else if (Staging.percentChance(10)) anim = animationIdle_Agitated2;  			  
				else if (Staging.percentChance(10)) anim = animationIdle_ArmsCrossed;  			  
				else if (Staging.percentChance(10)) anim = animationNoticingInDistanceAway1;  
				else if (Staging.percentChance(10)) anim = animationNoticingInDistanceAway2;  
				else if (Staging.percentChance(10)) anim = animationIdle_Impatient;  			  
				else if (Staging.percentChance(10)) anim = animationIdle_Restless;  			  
				else if (Staging.percentChance(10)) anim = animationIdle_SpacingOut1;  			  
				else if (Staging.percentChance(10)) anim = animationIdle_SpacingOut2;  			  
			}
					
			// if requested, override computed duration
			if (requestedDuration != cAttitudeDefaultDuration) duration = requestedDuration;
		}		
		
		subgoal performAnimation_portion(myName, myName, anim, cAnimDefaultStartTime, duration);
	}


	/**
	 * attitudeMain() - SPEAKING
	 */	 	
	sequential behavior attitudeMain(String myName, String performanceEnum, float requestedDuration, String param) {
		precondition {	(performanceEnum.equals(eAttitudePerform_speak)) 
						myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
						} 
		specificity 2;						 
		String anim;
		float duration;
		boolean bHostile;
				
		mental_act {
			bHostile = myCharacterWME.hasAttitude(eAttitudeType_hostile);

			if (bHostile) {
				anim = animationIdle_Agitated2;
				duration = (float)Staging.randRange(4.0, 6.0);
				if (Staging.percentChance(50)) anim = animationIdle_Agitated2;  			  
				if (Staging.percentChance(50)) anim = animationIdle_ArmsCrossed;  			  
				else if (Staging.percentChance(20)) anim = animationIdle_AngryAkimbo1;  			  
				else if (Staging.percentChance(20)) anim = animationAkimboBothArms;  			  
				else if (Staging.percentChance(5)) anim = animationTalkingNeutral1;  			  
				else if (Staging.percentChance(5)) anim = animationTalkingNeutral1b;  			  
				else if (Staging.percentChance(5)) anim = animationTalkingGestureSerious2;  			  
				else if (Staging.percentChance(5)) anim = animationInterrupted1;
				else if (Staging.percentChance(5)) anim = animationInterrupted2;
			
			} else {
				anim = animationTalkingGestureEmphatic1;
				duration = (float)Staging.randRange(4.0, 6.0);
				if (Staging.percentChance(10)) anim = animationTalkingGestureEmphatic1;  			  
				else if (Staging.percentChance(10)) anim = animationTalkingGestureEmphatic2;  			  
				else if (Staging.percentChance(10)) anim = animationTalkingGestureEmphatic3;  			  
				else if (Staging.percentChance(8)) anim = animationTalkingGestureSerious1;  			  
				else if (Staging.percentChance(8)) anim = animationTalkingGestureSerious1b;  			  
				else if (Staging.percentChance(10)) anim = animationTalkingGestureSerious2;  			  
				else if (Staging.percentChance(5)) anim = animationTalkingNeutral1;  			  
				else if (Staging.percentChance(5)) anim = animationTalkingNeutral1b;  			  
				else if (Staging.percentChance(5)) anim = animationTalkingNeutral2;  			  
				else if (Staging.percentChance(5)) anim = animationTalkingNeutral2b;  			  
				else if (Staging.percentChance(10)) anim = animationTalkingNeutral3;  			  
				else if (Staging.percentChance(10)) anim = animationTalkingFrustrated2;  			  
			}				
					
			// if requested, override computed duration
			if (requestedDuration != cAttitudeDefaultDuration) duration = requestedDuration;
		}		
		
		subgoal performAnimation_portion(myName, myName, anim, cAnimDefaultStartTime, duration);
	}



	/**
	 * attitudeMain() - NOTICING
	 */	 	
	sequential behavior attitudeMain(String myName, String performanceEnum, float requestedDuration, String param) {
		precondition {	(performanceEnum.equals(eAttitudePerform_notice)) 
						myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
						} 
		specificity 2;						 
		String anim;
		float duration;
		boolean bFirstGlance;
		mental_act {
			anim = animationNoticeHeldObject1;
			duration = (float)Staging.randRange(2.0, 5.0);
			bFirstGlance = param.equals(eAttitudeParam_firstGlance);
			
			if (!bFirstGlance && Staging.percentChance(3)) anim = animationTalkingGestureSerious1;  
			else if (!bFirstGlance && Staging.percentChance(3)) anim = animationScratchChin;  
			else if (!bFirstGlance && Staging.percentChance(3)) anim = animationGestureCough1;
			else if (Staging.percentChance(10)) anim = animationNoticeHeldObject1;  
			else if (Staging.percentChance(10)) anim = animationNoticeHeldObject2;  
			else if (Staging.percentChance(10)) anim = animationNoticeHeldObject3;  
			else if (Staging.percentChance(5)) { anim = animationIdle_Agitated2; duration = (float)Staging.randRange(4.0, 6.0); }  			  
			else if (Staging.percentChance(5)) { anim = animationIdle_ArmsCrossed; duration = (float)Staging.randRange(4.0, 6.0); }  			  
			else if (Staging.percentChance(5)) { anim = animationAkimboLeftArm; duration = (float)Staging.randRange(4.0, 6.0); }  			  
			else if (Staging.percentChance(5)) { anim = animationAkimboRightArm; duration = (float)Staging.randRange(4.0, 6.0); }  			  
			else if (Staging.percentChance(5)) { anim = animationAkimboBothArms; duration = (float)Staging.randRange(4.0, 6.0); }  			  
			else if (Staging.percentChance(8)) anim = animationNoticeGestureStarting;  
			else if (Staging.percentChance(8)) anim = animationNoticeSpeechOnset1;  
			else if (Staging.percentChance(8)) anim = animationNoticeSpeechOnset2;  
			else if (Staging.percentChance(8)) anim = animationNoticeSpeechOnset3;  
			else if (Staging.percentChance(8)) anim = animationNoticingInDistanceAway1;  
			else if (Staging.percentChance(8)) anim = animationNoticingInDistanceAway2;  
			else if (Staging.percentChance(8)) anim = animationInterrupted1;
			else if (Staging.percentChance(8)) anim = animationInterrupted2;
			else if (Staging.percentChance(8)) anim = animationInterrupted4;

					
			// if requested, override computed duration
			if (requestedDuration != cAttitudeDefaultDuration) duration = requestedDuration;
		}		
		
		subgoal performAnimation_portion(myName, myName, anim, cAnimDefaultStartTime, duration);
	}


	/**
	 * attitudeMain() - CONFUSED
	 */	 	
	sequential behavior attitudeMain(String myName, String performanceEnum, float requestedDuration, String param) {
		precondition {	(performanceEnum.equals(eAttitudePerform_confused)) 
						myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
						} 
		specificity 2;						 
		String anim;
		float duration;
		mental_act {
			anim = animationConfused3;
			duration = cAnimDefaultEndTime; //(float)Staging.randRange(4.0, 6.0);
			if (Staging.percentChance(15)) anim = animationConfused2;  			  
			else if (Staging.percentChance(15)) anim = animationConfused3;  			  
			else if (Staging.percentChance(15)) anim = animationConfused4;  			  
			else if (Staging.percentChance(15)) anim = animationHeadShakesNo1;  			  
			else if (Staging.percentChance(15)) anim = animationHeadShakesNo2;  			  
			else if (Staging.percentChance(15)) anim = animationInterrupted3;  			  
			else if (Staging.percentChance(15)) anim = animationDontUnderstand;  			  
					
			// if requested, override computed duration
			if (requestedDuration != cAttitudeDefaultDuration) duration = requestedDuration;
		}		
		
		subgoal performAnimation_portion(myName, myName, anim, cAnimDefaultStartTime, duration);
	}
			

	/**
	 * attitudeMain() - CASE NOT FOUND
	 */	 	
	sequential behavior attitudeMain(String myName, String performanceEnum, float requestedDuration, String param) {
		specificity 1;						 
		mental_act { log.info("ERROR: " +myName+ " unknown attitude perform case " +performanceEnum); }
	}			


	/**
	 * attitudeInsert() - GiveObject Exasperated, Post-Sequential insert
	 * Pull the card away, laugh and then hand it back
	 */	 	
	sequential behavior attitudeInsert(String myName, String performanceEnum, String insertionPoint) {
		precondition {	(performanceEnum.equals(eAttitudePerform_giveObject))
						(insertionPoint.equals("post"))					    
						attitudeWME=(AttitudeControlWME)
					    (attitudeWME.getName().equals(myName) &&
					    	attitudeWME.getType().equals(eAttitudeType_exasperation))
					    }
		subgoal performAnimation_portion(myName, myName, animationReachAndTakeObject, 1f, 2f);
		subgoal performAnimation(myName, myName, animationLaugh);
		subgoal performAnimation(myName, myName, animationOfferObject);

		mental_act { attitudeWME.incrementNumTimesExpressed(animationReachAndTakeObject); }
	}

 
 			 

 		 
	/**
	 * testbed_getRandomDialog()
	 */	 	
	sequential behavior testbed_getRandomDialog(ReturnValueWME retValWME, boolean bShortDialog) {		
	
        mental_act {        	
        	String audio;
        	String tone;

        	if (Staging.percentChance(10)) audio = dialogue_thai_Hello;
        	else if (Staging.percentChance(10)) audio = dialogue_thai_YoureWelcome;
        	else if (Staging.percentChance(10) && !bShortDialog) audio = dialogue_thai_IWasToldICouldGetWorkIfICameHere;
        	else if (Staging.percentChance(10)) audio = dialogue_thai_INeedTheWork;
        	else if (Staging.percentChance(10)) audio = dialogue_thai_WhyWontYouLetMeIn;
        	else if (Staging.percentChance(10)) audio = dialogue_thai_IDontHaveMyCardIForgotIt;
        	else if (Staging.percentChance(10)) audio = dialogue_thai_CantYouPleaseLetMeInAnyway;
        	else if (Staging.percentChance(10) && !bShortDialog) audio = dialogue_thai_INeedThisWorkWhyCantYouAllowMeThis;
        	else if (Staging.percentChance(10) && !bShortDialog) audio = dialogue_thai_YouAmericansAreAlwaysTryingToControlUsTellingUsWhatToDo;
        	else if (Staging.percentChance(10)) audio = dialogue_thai_ItReallyPissesMeOff;
        	else if (Staging.percentChance(10)) audio = dialogue_thai_IToldYouIForgotMyPass;
        	else if (Staging.percentChance(10) && !bShortDialog) audio = dialogue_thai_YouComeHereActLikeYouOwnOurCountryAndYouCantEvenSpeakOurLanguage;
        	else if (Staging.percentChance(10) && !bShortDialog) audio = dialogue_thai_TheseAreMyFriendsTheyCanVouchForMe;
        	else if (Staging.percentChance(10)) audio = dialogue_thai_WhyDontYouLetMeIn;
        	else if (Staging.percentChance(10)) audio = dialogue_thai_ThisJobIsImportantToMe;
        	else if (Staging.percentChance(10)) audio = dialogue_thai_INeedTheWork2;
        	else if (Staging.percentChance(10) && !bShortDialog) audio = dialogue_thai_JustBecauseYouHaveAGunYouThinkYouCanBossEverybodyAround;
        	else if (Staging.percentChance(10)) audio = dialogue_thai_WhyCantYouLetHimIn;
        	else if (Staging.percentChance(10)) audio = dialogue_thai_HesOurFriend;
        	else if (Staging.percentChance(10)) audio = dialogue_thai_HeForgotHisPass;
        	else if (Staging.percentChance(10)) audio = dialogue_thai_WhyDoesItMatterSoMuch;
        	else if (Staging.percentChance(10) && !bShortDialog) audio = dialogue_thai_YouJustLikeOrderingOtherPeopleAroundDontYou;
        	else if (Staging.percentChance(10)) audio = dialogue_thai_HeyYouShouldLetHimIn;
        	else if (Staging.percentChance(10)) audio = dialogue_thai_DontWorryHeDoesntHaveHisPass;
        	else if (Staging.percentChance(10)) audio = dialogue_thai_ItllBeFineHesAGoodGuy;
        	else audio = dialogue_thai_BeNiceToHim;

			tone = dialogue_tone_cooperative;	        		
        	if (Staging.percentChance(5)) tone = dialogue_tone_dominant;
        	else if (Staging.percentChance(30)) tone = dialogue_tone_neutral;
        	
        	retValWME.setString(audio);
        	retValWME.setString2(tone);
		}
	}			 
 

	/**
	 * performWithAttitude()
	 */	 	
	sequential behavior performWithAttitude(String myName, String performanceEnum, float requestedDuration) {
		subgoal performWithAttitude(myName, performanceEnum, requestedDuration, "");
	}
	
	sequential behavior performWithAttitude(String myName, String performanceEnum, float requestedDuration, String param) {
	   
		// potentially express an attitude before the main/core animation
		with (ignore_failure)
	   		subgoal attitudeInsert(myName, performanceEnum, "pre");
	   
		// the main/core animation to perform
		subgoal attitudeMain(myName, performanceEnum, requestedDuration, param);
	   
		// potentially express an attitude after the main/core animation
		with (ignore_failure)
			subgoal attitudeInsert(myName, performanceEnum, "post");
	      
	}
	
	
	/**
	 * addAttitude()
	 */	 	
	sequential behavior addAttitude(String name, String attitude) {
		precondition { 	attitudeWME=(AttitudeControlWME)
						(attitudeWME.getName().equals(name))
						(attitudeWME.getType().equals(attitude))
						}
		specificity 2;
		mental_act { log.info(name+ " already has an AttitudeControlWME of type" + attitude + "; ignoring addAttitude() request"); }
	}
	
	sequential behavior addAttitude(String name, String attitude) {
		precondition { characterWME=(CharacterWME) (characterWME.getName().equals(name)) } 
		specificity 1;
		AttitudeControlWME attitudeWME;
		mental_act {
			attitudeWME = new AttitudeControlWME(name, attitude);
			characterWME.addAttitude(attitudeWME);	
			__$thisEntity.addWME(attitudeWME);
			log.info("addAttitude() AttitudeControlWME registered for " + name + " of type " + attitude);
		}
	}
	

	/**
	 * addGroupAttitude()
	 * the group version of addAttitude that grabs a group
	 * TO DO: figure out how to select a particular group
	 */
	sequential behavior addGroupAttitude(String attitude) {
		precondition { groupWME=(GroupWME) } // a group WME exists to add an attitude to
		CharactersWME allCharsWME;
		mental_act {
			allCharsWME = groupWME.getAllCharactersWME();
			log.info("## starting addGroupAttitude " + attitude); 
		} 
		
		with (ignore_failure) subgoal addGroupAttitude_main(allCharsWME,attitude);
	}
	
	
   sequential behavior addGroupAttitude_main(CharactersWME allCharsWME, String attitude) {
		Iterator iterator;
		mental_act { iterator = allCharsWME.iterator(); }
		with (persistent when_succeeds) subgoal addGroupAttitude_loop(iterator, attitude);
	}
			
	sequential behavior addGroupAttitude_loop(Iterator iterator, String attitude) {
		precondition { (iterator.hasNext()) }
		CharacterWME character;						
		String charName;
		mental_act { 
			character = iterator.next();
			charName = character.getName(); 
		}
		with (ignore_failure) subgoal addAttitude(charName, attitude);
	}
	
	
	/**
	 * removeAttitude()
	 */	 	
   sequential behavior removeAttitude(String name, String attitude) {
      precondition {    attitudeWME=(AttitudeControlWME)
                  		(attitudeWME.getName().equals(name))
                  		(attitudeWME.getType().equals(attitude))
						characterWME=(CharacterWME) (characterWME.getName().equals(name)) 
                  }
      specificity 2;
      mental_act { 
		log.info(name+ " has an AttitudeControlWME of type " + attitude + "; going to remove it."); 
		characterWME.removeAttitude(attitudeWME);	
		__$thisEntity.deleteWME(attitudeWME);
      }
      
   }
   
   sequential behavior removeAttitude(String name, String attitude) {
      specificity 1;
      mental_act {
         log.info("removeAttitude() AttitudeControlWME was NOT registered for " + name + " of type " + attitude + ".. ignoring call to end it");
      }
   }
		
		
	/**
	 * removeGroupAttitude()
	 * the group version of removeAttitude that grabs a group
	 * TO DO: figure out how to select a particular group
	 */
	sequential behavior removeGroupAttitude(String attitude) {
		precondition { groupWME=(GroupWME) } // TO DO: Find the group that has the attitude
		CharactersWME allCharsWME;
		mental_act {
			allCharsWME = groupWME.getAllCharactersWME();
			log.info("## starting removeGroupAttitude " + attitude); 
		} 
		
		with (ignore_failure) subgoal removeGroupAttitude_main(allCharsWME,attitude);
	}
	
   sequential behavior removeGroupAttitude_main(CharactersWME allCharsWME, String attitude) {
		Iterator iterator;
		mental_act { iterator = allCharsWME.iterator(); }
		with (persistent when_succeeds) subgoal removeGroupAttitude_loop(iterator, attitude);
	}
			
	sequential behavior removeGroupAttitude_loop(Iterator iterator, String attitude) {
		precondition { (iterator.hasNext()) }	
		CharacterWME character;					
		String charName;
		mental_act { 
			character = iterator.next();
			charName = character.getName(); 
		}
		with (ignore_failure) subgoal removeAttitude(charName, attitude);
	}


	
 	/**
	 * computeAttitudeProbability()
	 */	 	
	//This behavior looks at how much the passed in attitudeWME has already been expressed
	//and how many times the passed in animation has been expressed as part of this attitudeWME.
	//The more it has been expressed, the lower the value will be that is stored in the returnValueWME, which in turn
	//will decrease the probability that this attitude/animation combination will be expressed in the future.
	
	sequential behavior computeAttitudeProbability(AttitudeControlWME attitudeWME, String attitudeAnimation){
	   float threshold;
	   float ratio;
	   float sameAttitudePenaltyTotal;
	   float numTimesAttitudeExpressed;
	   ReturnValueWME returnValueWME;
	   
	   mental_act{
	      returnValueWME = new ReturnValueWME();
	      
	      threshold = 100;
	      numTimesAttitudeExpressed = attitudeWME.getNumTimesExpressed();
	      //Only need to bother doing calculations if the attitude has been expressed at least once.
	      if(numTimesAttitudeExpressed > 0){
	         
	         //lower the threshold by:  [(# of times we've seen this attitude) / (# of times this attitude has been expressed)] * sameAnimationPenalty
	         ratio = (float) attitudeWME.getNumTimesAnimationExpressed(attitudeAnimation) / numTimesAttitudeExpressed;
	         threshold -=  ratio * cAttitudeUtility_sameAnimationPenalty;
	         
	         log.info("inside of computeAttitudeProbability! (middle) ratio: " + ratio + " threshold: " + threshold);
	         
	         //lower the threshold by: # of times this attidue has been expressed * sameAttitudePenalty.
	         sameAttitudePenaltyTotal = numTimesAttitudeExpressed * cAttitudeUtility_sameAttitudePenalty;
	         threshold -= sameAttitudePenaltyTotal;
	         
	         log.info("inside of computeAttitudeProbability! (end) penaltyTotal: " + sameAttitudePenaltyTotal + " threshold: " + threshold);
	      }
	      
	      log.info("inside of computeAttitudeProbability! threshold value going into returnValueWME: " + threshold);
	      returnValueWME.setFloat(threshold);
	   }
	   
	   //So, we've computed the probability -- let's make sure that it is unique enough!
	   subgoal verifyProbability(returnValueWME, attitudeWME, attitudeAnimation);
	}
	  

 	/**
	 * verifyProbability()
	 */	 	
	// in which the probability is "not good" (i.e. below the threshold) and so we 'return' with a fail_step
	sequential behavior verifyProbability(ReturnValueWME returnValueWME, AttitudeControlWME attitudeWME, String attitudeAnimation){
	   specificity 10;
	   precondition{
	      (returnValueWME.getFloat() < cAttitudeUtility_uniquenessThreshold)
	   }
	   
	   //Oh oh! This expression of this attitude isn't unique enough! 
	   mental_act{
	      log.info("verifyProbability: return value of " + returnValueWME.getFloat() + " was below the threshold of " + cAttitudeUtility_uniquenessThreshold + " NOT playing " + attitudeAnimation + " in attitude " + attitudeWME.getType());
	   }
	   fail_step;
	}
	
 	/**
	 * verifyProbability()
	 */	 	
	// if we get here, then that means that the above verifyProbability didn't have it's precondition met.
	//Which means we can successfully play the animation without worry!
	sequential behavior verifyProbability(ReturnValueWME returnValueWME, AttitudeControlWME attitudeWME, String attitudeAnimation){
	   specificity 2;
	   precondition{
	      (returnValueWME.getFloat() >= cAttitudeUtility_uniquenessThreshold)
	   }
	   
	   mental_act{
	      log.info("verifyProbability: return value of " + returnValueWME.getFloat() + " was OK! playing " + attitudeAnimation + " in attitude " + attitudeWME.getType());
	   }
	}
		 

 
	/**
	 * awarenessMgr()
	 * One of these are running per character
	 */	 	
	parallel behavior awarenessMgr(String myName) {
		precondition { 	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
						playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName)) 
						}
		specificity 2;						
		with (priority 101) mental_act { log.info("** " +myName+ " awarenessMgr started"); }
		with (priority 100, persistent) subgoal awarenessMgr_testFarDistAny(myName); 
		with (priority 100, persistent) subgoal awarenessMgr_testCloseDistTo(myName, myCharacterWME,
																				playerName, playerCharacterWME); 
	}
	
	parallel behavior awarenessMgr(String myName) {
		specificity 1;
		with (priority_modifier 1) mental_act { log.info("** " +myName+ " awarenessMgr failed to start"); }
	}
	
		
	/**
	 * awarenessMgr_testFarDistAny()
	 * Find any character close by that we weren't aware of recently
	 */	 	
	sequential behavior awarenessMgr_testFarDistAny(String myName) {
		precondition { characterWME=(CharacterWME) (characterWME.getName().equals(myName)) } 
		long howRecent;
		mental_act {
			if (characterWME.getCurrentAnim().equals(animationWalk)) howRecent = 1500;
			else howRecent = 60000;
		}
		subgoal awarenessMgr_testFarDistAny_test(myName, howRecent); 
	}
	
	sequential behavior awarenessMgr_testFarDistAny_test(String myName, long howRecent) {
		precondition { 	awarenessWME=(AwarenessWME)
						(myName.equals(awarenessWME.getCharacterName()) &&
						 awarenessWME.isMoreRecentThan(awarenessWME.getTimestampFarDist(), howRecent) == false)
						myPhysicalWME=(PhysicalAgentWME)
                     	(myPhysicalWME.getId().equals(myName))
						targetPhysicalWME=(PhysicalAgentWME)
                     	(targetPhysicalWME.getId().equals(awarenessWME.getTargetName()))
                     	(Staging.getXZDistanceBetweenPoints(myPhysicalWME.getLocation(), 
                     											targetPhysicalWME.getLocation()) 
                     										< cFarAwarenessDistance)
					 }
		specificity 2;
		String targetName;					 
		mental_act {
			targetName = awarenessWME.getTargetName();
			//log.info(myName+ " now far-distance aware of " +targetName);
			awarenessWME.setTimestampFarDist();
		}

		subgoal temporaryGlanceIfNotEngagedWith(myName, targetName);
	}
	
	// restore headtrack if needed, and wait a second before next poll
	sequential behavior awarenessMgr_testFarDistAny_test(String myName, long howRecent) {
		specificity 1;
		with (ignore_failure) subgoal awarenessMgr_restoreHeadtrack(myName);
		subgoal waitForRand(1000, 3000);
	}
	
	
	/**
	 * awarenessMgr_testCloseDistTo()
	 * If given target is close by, that we weren't aware of recently
	 */	 	
	 
	// IF ALREADY IN GROUP TOGETHER with target, regularly test for VeryClose 
	sequential behavior awarenessMgr_testCloseDistTo(String myName, CharacterWME myCharacterWME, 
														String targetName, CharacterWME targetCharacterWME) {
		precondition {	(targetName.equals(playerName))
						
						// IF ALREADY IN GROUP TOGETHER
                     	groupWME=(GroupWME) (groupWME.contains(myCharacterWME) && groupWME.contains(targetCharacterWME))
                     	
						myPhysicalWME=(PhysicalAgentWME) (myPhysicalWME.getId().equals(myName))
						targetPhysicalWME=(PhysicalAgentWME) (targetPhysicalWME.getId().equals(targetName))
						awarenessWME=(AwarenessWME)
						(myName.equals(awarenessWME.getCharacterName()) && 
						 targetName.equals(awarenessWME.getTargetName()))
						}
		specificity 2;
		boolean bVeryClose;
		
		mental_act { 
			log.info("Awareness check: " +myName+ " already in group with " +targetName); 
			
			// check very close status
			bVeryClose = false;
			if (Staging.getXZDistanceBetweenPoints(myPhysicalWME.getLocation(), 
	                     								targetPhysicalWME.getLocation()) 
													< cPersonalSpaceDistance) {
				log.info(myName+ " now very-close-distance aware of " +targetName);
				awarenessWME.setTimestampVeryCloseDist();
				bVeryClose = true;
			}											
		}
		
		// possibly launch reaction to being very close
		with (ignore_failure) subgoal awarenessMgr_VeryCloseDistTo(myName, targetName, bVeryClose);
		
		// wait till next poll
		subgoal waitFor(1000);
	}

	sequential behavior awarenessMgr_VeryCloseDistTo(String myName, String targetName, boolean bVeryClose) {
		precondition { (bVeryClose == true) }
		
		// manufacture a veryclose signal
		mental_act{
		   //log.info("CIF RULE testing -- creating veryClose socialInterpretation signal");
		}
		subgoal createSocialSignalWME(socialInterpretationVeryClose, targetName, myName);
	}

	
	// IF NOT IN GROUP with target, regularly test for close 
	sequential behavior awarenessMgr_testCloseDistTo(String myName, CharacterWME myCharacterWME, 
														String targetName, CharacterWME targetCharacterWME) {
		specificity 1;
		long howRecent;
		mental_act {
			if (myCharacterWME.getCurrentAnim().equals(animationWalk)) howRecent = 1500;
			else howRecent = 3000;
		}
		subgoal awarenessMgr_testCloseDistTo_test(myName, myCharacterWME, targetName, targetCharacterWME, howRecent); 
	}
	
	// IF CLOSE NOW and NOT RECENTLY CLOSE, and IF NOT IN GROUP with target, may create APPROACH signal
	sequential behavior awarenessMgr_testCloseDistTo_test(String myName, CharacterWME myCharacterWME, 
															String targetName, CharacterWME targetCharacterWME, 
															long howRecent) {
		precondition { 	awarenessWME=(AwarenessWME)
						(myName.equals(awarenessWME.getCharacterName()) &&
						 targetName.equals(awarenessWME.getTargetName()) &&
						 awarenessWME.isMoreRecentThan(awarenessWME.getTimestampCloseDist(), howRecent) == false)
						 
						myPhysicalWME=(PhysicalAgentWME) (myPhysicalWME.getId().equals(myName))
						targetPhysicalWME=(PhysicalAgentWME) (targetPhysicalWME.getId().equals(awarenessWME.getTargetName()))
                     	(Staging.getXZDistanceBetweenPoints(myPhysicalWME.getLocation(), 
                     											targetPhysicalWME.getLocation()) 
                     										< cCloseAwarenessDistance)
					 }
		specificity 2;
		subgoal awarenessMgr_testCloseDistTo_test_part2(myName, myCharacterWME, targetName, targetCharacterWME, awarenessWME);
	}
	
	// wait a second before next poll
	sequential behavior awarenessMgr_testCloseDistTo_test(String myName, CharacterWME myCharacterWME, 
															String targetName, CharacterWME targetCharacterWME, 
															long howRecent) {
		specificity 1;
		subgoal waitFor(1000);
	}

	
	// also check: IF TARGET IN ANOTHER GROUP, and TARGET IS CLOSER TO THAT GROUP THAN MINE, 
	// then wait a second till next poll 
	// Fixes bug where approach signals thrash between two nearby groups
	sequential behavior awarenessMgr_testCloseDistTo_test_part2(String myName, CharacterWME myCharacterWME, 
																String targetName, CharacterWME targetCharacterWME,
																AwarenessWME awarenessWME) {
        precondition {	targetOtherGroupWME=(GroupWME) 
                     	(targetOtherGroupWME.contains(myCharacterWME) == false &&
                     	 targetOtherGroupWME.contains(targetCharacterWME) == true)
        				myGroupWME=(GroupWME) 
                     	(myGroupWME.contains(myCharacterWME) == true &&
                     	 myGroupWME.contains(targetCharacterWME) == false)
                     	 
						targetPhysicalWME=(PhysicalAgentWME)
                     	(targetPhysicalWME.getId().equals(targetName))
                     	(Staging.getXZDistanceBetweenPoints(targetPhysicalWME.getLocation(), targetOtherGroupWME.getOrigin()) < 
                     	 Staging.getXZDistanceBetweenPoints(targetPhysicalWME.getLocation(), myGroupWME.getOrigin()))  
                     	 }  
		specificity 2;
		mental_act {
			log.info(myName+ " close to " +targetName+ " but not as close as their current group");
		}
		subgoal waitFor(1000);
	}

	// else CREATE APPROACH SIGNAL
	sequential behavior awarenessMgr_testCloseDistTo_test_part2(String myName, CharacterWME myCharacterWME, 
																String targetName, CharacterWME targetCharacterWME,
																AwarenessWME awarenessWME) {
		specificity 1;
		mental_act {
			log.info(myName+ " now close-distance aware of " +targetName);
			awarenessWME.setTimestampCloseDist();
		}

		// manufacture an approach signal
		subgoal createSocialSignalWME(socialInterpretationApproach, targetName, myName);
	}
	

		
	// ------------------------------------------------------------------
	// ------------------------------------------------------------------
		
	/**
	 * setAwareness()
	 * set awareness of a character
	 */	 	
	sequential behavior setAwareness(String myName, String targetName) {
		precondition { 	awarenessWME=(AwarenessWME)
						(myName.equals(awarenessWME.getCharacterName()) &&
						 targetName.equals(awarenessWME.getTargetName()))
					 }
		specificity 2;
		mental_act {
			//log.info("** " +myName+ " setting awareness of " +targetName);
			awarenessWME.setTimestampFarDist();			
		}
	}

	// in case awareness mgr not running	
	sequential behavior setAwareness(String myName, String targetName) {
		specificity 1;
		succeed_step;
	}
	
	/**
	 * awarenessMgr_restoreHeadtrack()
	 * set awareness of a character
	 */	 	
	sequential behavior awarenessMgr_restoreHeadtrack(String myName) {
		precondition {	characterWME=(CharacterWME)
                     	(characterWME.getName().equals(myName))
                     	(characterWME.getBLookingAtTemporaryHeadtrack())
                     } 
		subgoal restoreCachedHeadTrack(myName);
	}

	/**
	 * temporaryGlanceIfNotEngagedWith()
	 * If not already in a group formation with
	 */	 	
	sequential behavior temporaryGlanceIfNotEngagedWith(String myName, String targetName) {
		precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName))
						targetCharacterWME=(CharacterWME) (targetCharacterWME.getName().equals(targetName))	 
                     	groupWME=(GroupWME) 
                     	(groupWME.formationContains(myCharacterWME) &&
                     	 groupWME.formationContains(targetCharacterWME))  
                     }                     	
		specificity 2;
		succeed_step;
	}
	
	sequential behavior temporaryGlanceIfNotEngagedWith(String myName, String targetName) {
		specificity 1;
		
		// DON'T CACHE this temporary glance headtrack
		subgoal headTrack(myName, targetName, false);
		subgoal waitForRand(800, 1200);
	}
	 	

	// ------------------------------------------------------------------
	// ------------------------------------------------------------------
		
	/**
	 * awarenessMgr_setup()
	 * create awarenessWMEs per character towards each other character
	 * spawn a awarenessMgr per character
	 */	 	
	sequential behavior awarenessMgr_setup() {	
		with (ignore_failure) subgoal awarenessMgr_setup_main();
	}
	
	sequential behavior awarenessMgr_setup_main() {
		precondition { charactersWME=(CharactersWME) } 
		Iterator iterator;
		mental_act { iterator = charactersWME.iterator(); }
		with (persistent when_succeeds) subgoal awarenessMgr_setup_loop(iterator);
	}
			
	sequential behavior awarenessMgr_setup_loop(Iterator iterator) {
		precondition { (iterator.hasNext()) }						
		CharacterWME characterWME;
		String characterName;
		mental_act { 
			characterWME = iterator.next();
			characterName = characterWME.getName();
		}
		
		with (ignore_failure) subgoal awarenessMgr_setup_launch(characterName);
	}
	
	sequential behavior awarenessMgr_setup_launch(String characterName) {
		precondition { (characterName.equals(playerName) == false) }
		//mental_act { log.info("** " +characterName+ " setting up an AwarenessMgr"); }
		subgoal awarenessWME_setup(characterName);
		spawngoal awarenessMgr(characterName);		
	}
	
	/**
	 * awarenessWME_setup()
	 * create awarenessWMEs per character towards each other character
	 */	 	
	sequential behavior awarenessWME_setup(String myName) {		
		with (ignore_failure) subgoal awarenessWME_setup_main(myName);
	}
	
	sequential behavior awarenessWME_setup_main(String myName) {
		precondition { charactersWME=(CharactersWME) } 
		Iterator iterator;
		mental_act { iterator = charactersWME.iterator(); }
		with (persistent when_succeeds) subgoal awarenessWME_setup_loop(myName, iterator);
	}
			
	sequential behavior awarenessWME_setup_loop(String myName, Iterator iterator) {
		precondition { (iterator.hasNext()) }						
		CharacterWME characterWME;
		String characterName;
		mental_act { 
			characterWME = iterator.next();
			characterName = characterWME.getName();
		}
		
		with (ignore_failure) subgoal awarenessWME_setup_createWME(myName, characterName);
	}
	
	sequential behavior awarenessWME_setup_createWME(String myName, String targetName) {
		precondition {	(targetName.equals(myName) == false)
						characterWME=(CharacterWME) (characterWME.getName().equals(myName))  
		
						(targetName.equals(playerName) == true ||
							
							// fixme: so that an awarenessWME isn't created for every other NPC 
							Staging.percentChance(20) ||
							
							// but be sure to be aware of my friends 
							characterWME.getFriendsCharactersWME().containsCharacter(targetName)
							) 
						}
						
		AwarenessWME awarenessWME;
		mental_act { 
			log.info(myName+ " creating AwarenessWME for " +targetName);
			awarenessWME = new AwarenessWME(myName, targetName);	
			BehavingEntity.getBehavingEntity().addWME(awarenessWME);			
		}
	}
	

	/**
	 * waitForBodyResourceWME()
	 */
	sequential behavior waitForBodyResourceWME(PersonWME character, String reason, 
												boolean bWaitForBodyResource, boolean bGrabBodyResource) {
		String characterName = character.getName();
		int characterUid;
		mental_act { characterUid = BodyResourceWME.getUidForString(characterName); }
		subgoal waitForBodyResourceWME(characterName, characterUid, reason, bWaitForBodyResource, bGrabBodyResource);
	}
	
	sequential behavior waitForBodyResourceWME(String characterName, String reason, 
												boolean bWaitForBodyResource, boolean bGrabBodyResource) {
		int characterUid;
		mental_act { characterUid = BodyResourceWME.getUidForString(characterName); }
		subgoal waitForBodyResourceWME(characterName, characterUid, reason, bWaitForBodyResource, bGrabBodyResource);
	}


	// do nothing if we don't actually need to wait for the resource, e.g. for facial expressions
	sequential behavior waitForBodyResourceWME(String myCharacterName, int myCharacterUid, String reason, 
												boolean bWaitForBodyResource, boolean bGrabBodyResource) {
		precondition { (bWaitForBodyResource == false) }
		specificity 2;
		succeed_step;
	}
	
	sequential behavior waitForBodyResourceWME(String myCharacterName, int myCharacterUid, String reason, 
												boolean bWaitForBodyResource, boolean bGrabBodyResource) {
		specificity 1;
		//br mental_act { log.info(myCharacterName+ " waiting for body resource WME for " +reason); }
		subgoal waitForBodyResourceWME_par(myCharacterName, myCharacterUid, reason);
		mental_act {
			if (bGrabBodyResource) { 
				//old
				BehavingEntity.getBehavingEntity().addWME(new BodyResourceWME(myCharacterName, "body")); 			
				//new
				//BehavingEntity.getBehavingEntity().addWME(new BodyResourceWME(null, myCharacterName, eBodyResourceID_body, 0)); 
				
				//br log.info(myCharacterName+ " got body resource WME for " +reason);
			}
		}
	}

	// fixme - don't want this timeout
	parallel behavior waitForBodyResourceWME_par(String myCharacterName, int myCharacterUid, String reason) {
		number_needed_for_success 1;
		with (success_test { !(BodyResourceWME characterUid == myCharacterUid) } ) wait;
		subgoal waitForBodyResourceWME_releaseBandaid(myCharacterName, myCharacterUid, reason);
	}   

	// bandaid for deadlock
	sequential behavior waitForBodyResourceWME_releaseBandaid(String myCharacterName, int myCharacterUid, String reason) {
		subgoal waitFor(cBodyResourceWMERequestOverrideTimeout);
		subgoal releaseBodyResourceWME(myCharacterName, myCharacterUid, "deadlock");
	}



	/**
	* releaseBodyResourceWME()
	*/
	sequential behavior releaseBodyResourceWME(PersonWME character, String reason) {
		String characterName = character.getName();
		int characterUid;
		mental_act { characterUid = BodyResourceWME.getUidForString(character.getName()); }
		subgoal releaseBodyResourceWME(characterName, characterUid, reason);
	}	
	
	sequential behavior releaseBodyResourceWME(String myCharacterName, int myCharacterUid, String reason) {
		precondition { bodyResourceWme = (BodyResourceWME characterUid == myCharacterUid) }
		specificity 2;
		mental_act { 
			__$thisEntity.deleteWME(bodyResourceWme); 
			//br log.info(myCharacterName+ " released body resource WME for " +reason); 
		}
	}	
	sequential behavior releaseBodyResourceWME(String myCharacterName, int myCharacterUid, String reason) {
		specificity 1;
		succeed_step;
	}
    
	sequential behavior releaseBodyResourceWME(String myCharacterName, String reason) {
		precondition { bodyResourceWme = (BodyResourceWME characterName == myCharacterName) }
		specificity 2;
		mental_act { 
			__$thisEntity.deleteWME(bodyResourceWme); 
			//br log.info(myCharacterName+ " released body resource WME for " +reason); 
		}
	}
	sequential behavior releaseBodyResourceWME(String myCharacterName, String reason) {
		specificity 1;
		succeed_step;
	}
    
      
	/**
	 * cif_globalListener()
	 */	 	
	sequential behavior cif_globalListener() {

		SocialSignalWME signalWME;
		SocialInterpretation interpretation;
		String gestureName;
		String initiator;
		String recipient;
		
		mental_act { log.info("cif_globalListener waiting for new signals"); }
				
     	with (success_test {	(SocialSignalWME self::signalWME  
     								//sender==playerName	// NPCs can now generate Point signals, that other NPCs react to
     								sender::initiator)
     								
								(signalWME.getChosenInterpretation() == null)
						        } ) wait;

		mental_act { 
			Gesture gesture;
			Iterator iterator;
			
			// fixme: for now, just choose one of the interpretations in the signal
			//iterator = signalWME.getSignal().iterator();
			//if (iterator.hasNext()) interpretation = (SocialInterpretation)(iterator.next());
			interpretation = signalWME.getFirstSocialInterpretation();
			
			// closest recipient will serve to identify the group to whom the (group) signal is directed
			recipient = signalWME.getClosestRecipient();

			signalWME.setChosenInterpretation(interpretation); 
			
			// Get name of raw MiBA gesture
			gesture = signalWME.getSourceEventGestureType();
			if (gesture == null) gestureName = "";
			else gestureName = gesture.toString();
			
			log.info("### CIF GLOBAL LISTENER chose interpretation " +interpretation+ " from " +initiator+ " to " +recipient+ " out of received signal " +signalWME+ " gesture " +gestureName);
		}
		
		subgoal TriggerVolitionDetermination();
		
		spawngoal cif_adhoc_globalReaction(signalWME, interpretation, gestureName, initiator/*playerName*/, recipient);
	}
	
	
	/**
	 * cif_regenerateMostRecentSignalIf()
	 * If the given signal was the most recent one, and within a time limit, regenerate it
	 * This is useful for a single ExtendHand signal performing two functions: an offer, and the give itself
	 */	 	
    sequential behavior cif_regenerateMostRecentSignalIf(SocialInterpretation interpretation, String initiator, String recipient, int howRecent) {
     	precondition { (SocialSignalWME.getIfMostRecentGestureFromIs(interpretation, initiator, recipient, howRecent) == true) }
    	specificity 2;
		subgoal createSocialSignalWME(interpretation, initiator, recipient);    	
    }
    
    sequential behavior cif_regenerateMostRecentSignalIf(SocialInterpretation interpretation, String initiator, String recipient, int howRecent) {
    	specificity 1;
		mental_act { log.info("No recent " +interpretation+ " signal to regenerate from " +initiator+ " to " +recipient); } 
    } 
	

	// ### addNewlyGreetedCharacterToFormation
    // if the initiator of a Greet SIU is not in the formation yet, 
    // and the group is not hostile (i.e., for now, there is a non-hostile responder in the group),
    // then add the initiator to the formation
    rule addNewlyGreetedCharacterToFormation {
    	siuGreet=(SiuWME initiator::initiator executing==true)(siuGreet.getName().equals(siuNameGreet))
    	group=(GroupWME) (group.contains(initiator))
    	(!group.isCharacterInFormation(initiator))
    	responder=(CharacterWME)
    	(group.isCharacterInFormation(responder))
    	(!responder.hasAttitude(eAttitudeType_hostile))
    	->({group.addFormationCharacter(initiator);})
	       ({System.out.println("CiF rule: addNewlyGreetedCharacterToFormation for " +initiator);})
    }
    
    
    // ### approachNomination
    rule approachNomination {
       signalWME=(SocialSignalWME seenByVolition==false closestRecipient::recipient sender::initiator)
       (signalWME.getFirstSocialInterpretation() == socialInterpretationApproach)
       ->
       (CiFSiuLaunchWME ruleName=ruleNameApproachNomination signalWME=signalWME initiator=initiator recipient=recipient)
       ( { System.out.println("CiF rule: SIU approach nominated for: " + initiator + " and " +recipient); } )
    }
    
    // ### approachVolition
    rule approachVolition {
       ciFSiuLaunchWME=(CiFSiuLaunchWME candidate==true) (ruleNameApproachNomination.equals(ciFSiuLaunchWME.getRuleName()))
       ->
       (VolitionWME score=10 ciFSiuLaunchWME=ciFSiuLaunchWME)
       ({ciFSiuLaunchWME.addScore(10);})
    }


    // ### greetPlayerToGroupNomination
    // higher specificity than MIRROR
    rule greetPlayerToGroupNomination {
       signalWME=(SocialSignalWME seenByVolition==false closestRecipient::recipient sender::initiator)
       // interpretation=(signalWME.getFirstSocialInterpretation()) // fixme - want to be able to set local variables, and not call getFirstSocialInterpretation() 3 times below 
       (signalWME.getFirstSocialInterpretation() == socialInterpretationGreetingWaveFriendly ||
        signalWME.getFirstSocialInterpretation() == socialInterpretationGreetingSpeechFriendly ||
        signalWME.getFirstSocialInterpretation() == socialInterpretationGreetingSpeechNeutral)
	   (initiator.equals(playerName))
	   
	   //fixme: want to also check timestamp, but how to in a negate test? 
       !(EpisodicMemoryWME characterName==recipient recipientName==initiator episodeName==siuNameGreet)
       
       playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName))
       recipientCharacterWME=(CharacterWME) (recipientCharacterWME.getName().equals(recipient))
       groupWME=(GroupWME) (groupWME.contains(recipientCharacterWME) && groupWME.contains(playerCharacterWME))
       ->
       (CiFSiuLaunchWME ruleName=ruleNameGreetPlayerToGroupNomination signalWME=signalWME initiator=initiator recipient=recipient)
       (CiFRuleUtilWME name="nominationInGreetMirrorChain")
       ( { System.out.println("CiF rule: SIU greet nominated for: " + initiator + " and " +recipient); } )
    }

    // ### greetPlayerToGroupVolition
    rule greetPlayerToGroupVolition {
       ciFSiuLaunchWME=(CiFSiuLaunchWME candidate==true) (ruleNameGreetPlayerToGroupNomination.equals(ciFSiuLaunchWME.getRuleName()))
       ->
       (VolitionWME score=10 ciFSiuLaunchWME=ciFSiuLaunchWME)
       ({ciFSiuLaunchWME.addScore(10);})
    }
    

    // ### mirrorNomination
    // lower specificity than GREET
    rule mirrorNomination {
       !(CiFRuleUtilWME name=="nominationInGreetMirrorChain")	// enforce rule specificity
    
       signalWME=(SocialSignalWME seenByVolition==false closestRecipient::recipient sender::initiator)
       (signalWME.getFirstSocialInterpretation() == socialInterpretationGreetingWaveFriendly)
	   (initiator.equals(playerName))
       
       playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName))
       recipientCharacterWME=(CharacterWME) (recipientCharacterWME.getName().equals(recipient))
       groupWME=(GroupWME) (groupWME.contains(recipientCharacterWME) && groupWME.contains(playerCharacterWME))
       ->
       (CiFSiuLaunchWME ruleName=ruleNameMirrorNomination signalWME=signalWME initiator=initiator recipient=recipient)
       (CiFRuleUtilWME name="nominationInGreetMirrorChain")
       ( { System.out.println("CiF rule: SIU mirror nominated for: " + initiator + " and " +recipient); } )
    }

    // ### mirrorVolition
    rule mirrorVolition {
       ciFSiuLaunchWME=(CiFSiuLaunchWME candidate==true) (ruleNameMirrorNomination.equals(ciFSiuLaunchWME.getRuleName()))
       ->
       (VolitionWME score=10 ciFSiuLaunchWME=ciFSiuLaunchWME)
       ({ciFSiuLaunchWME.addScore(10);})
    }

    
    // ### personalSpaceViolationNomination
    rule personalSpaceViolationNomination {
       (BehavingEntity.truePrintln("1. inside of personal space violation...")) 
       signalWME=(SocialSignalWME seenByVolition==false closestRecipient::recipient sender::initiator)
             (BehavingEntity.truePrintln("2. inside of personal space violation... does it contain the interpretation we want? " + signalWME.contains(socialInterpretationVeryClose))) 
             (BehavingEntity.truePrintln("2. OK, what about the general contents of signal? is it empty: " + signalWME.getSignal().isEmpty()))
             (BehavingEntity.truePrintln("2. What is the size: " + signalWME.getSignal().getSize()))
             (BehavingEntity.truePrintln("2. What is in element 0:: " + signalWME.getSignal().getIndex(0)))
       (signalWME.getFirstSocialInterpretation() == socialInterpretationVeryClose)
       (BehavingEntity.truePrintln("3. inside of personal space violation...")) 
       (initiator.equals(playerName))
       (BehavingEntity.truePrintln("4. inside of personal space violation...")) 
       playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName))
       (BehavingEntity.truePrintln("5. inside of personal space violation...")) 
       recipientCharacterWME=(CharacterWME) (recipientCharacterWME.getName().equals(recipient))
       (BehavingEntity.truePrintln("6. inside of personal space violation...")) 
       groupWME=(GroupWME) (groupWME.contains(recipientCharacterWME) && groupWME.contains(playerCharacterWME))
       (BehavingEntity.truePrintln("7. inside of personal space violation...")) 
       // I am hostile, not leader, not sympathetic
       (recipientCharacterWME.hasAttitude(eAttitudeType_hostile) == true &&
          recipientCharacterWME.hasAttitude(eAttitudeType_leader) == false &&
          recipientCharacterWME.hasAttitude(eAttitudeType_sympathetic) == false)
       (BehavingEntity.truePrintln("8. inside of personal space violation...")) 
       // haven't done personal space SIU already                                          
       !(EpisodicMemoryWME characterName==recipient recipientName==initiator episodeName==siuNamePersonalSpace)
       (BehavingEntity.truePrintln("9. inside of personal space violation...")) 
       ->
       (CiFSiuLaunchWME ruleName=ruleNamePersonalSpaceViolationNomination signalWME=signalWME initiator=initiator recipient=recipient)
       ( { System.out.println("CiF rule: SIU personal space violation nominated for: " + initiator + " and " +recipient); } )
    }
    
    // ### personalSpaceViolationVolition
    rule personalSpaceViolationVolition {
       ciFSiuLaunchWME=(CiFSiuLaunchWME candidate==true) (ruleNamePersonalSpaceViolationNomination.equals(ciFSiuLaunchWME.getRuleName()))
       ->
       (VolitionWME score=10 ciFSiuLaunchWME=ciFSiuLaunchWME)
       ({ciFSiuLaunchWME.addScore(10);})
    }
    

    
    // ### giveHeldObjectNomination
    // higher specificity than OFFER and SHOW.
    rule giveHeldObjectNomination {
    
       signalWME=(SocialSignalWME seenByVolition==false closestRecipient::recipient sender::initiator)
       (signalWME.getFirstSocialInterpretation() == socialInterpretationExtendHand)
      (initiator.equals(playerName))
       
       // player IS holding an object
       playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName))
       (playerCharacterWME.getObjectHeld().equals("") == false)
       
       // interpret extend hand signal as a Give if an NPC is requesting the player's held object
       requestObjectSiuWME=(SiuWME name==siuNameRequestObject)
       (requestObjectSiuWME.getState() == SiuExecutionState.EXECUTING)
       
             // IS THE PRIMARY RECIPIENT OF THE SIGNAL THE NPC REQUESTING THE OBJECT
             (requestObjectSiuWME.getInitiator().getName().equals(signalWME.getPrimaryRecipient())) 
             
       recipientCharacterWME=(CharacterWME) (recipientCharacterWME.getName().equals(recipient)) 
             groupWME=(GroupWME) (groupWME.contains(recipientCharacterWME) && 
                               groupWME.contains(playerCharacterWME))
       ->
       (CiFSiuLaunchWME ruleName=ruleNameGiveHeldObjectNomination signalWME=signalWME initiator=initiator recipient=recipient paramSiuWME=requestObjectSiuWME)
       (CiFRuleUtilWME name="nominationInGiveOfferShowObjectChain")
       ( { System.out.println("CiF rule: SIU give object nominated for: " + initiator + " and " +recipient); } )
    } 
    
    // ### giveHoldObjectVolition
    rule giveHeldObjectVolition {
       ciFSiuLaunchWME=(CiFSiuLaunchWME candidate==true) (ruleNameGiveHeldObjectNomination.equals(ciFSiuLaunchWME.getRuleName()))
       ->
       (VolitionWME score=10 ciFSiuLaunchWME=ciFSiuLaunchWME)
       ({ciFSiuLaunchWME.addScore(10);})
    }
    
  
    
    // ### offerHeldObjectNomination
    // LOWER specificity than GIVE,HIGHER specificty than SHOW.
    rule offerHeldObjectNomination {
       !(CiFRuleUtilWME name=="nominationInGiveOfferShowObjectChain")  // enforce rule specificity
       signalWME=(SocialSignalWME seenByVolition==false closestRecipient::recipient sender::initiator)
       (signalWME.getFirstSocialInterpretation() == socialInterpretationExtendHand)
      (initiator.equals(playerName))
       
       // player IS holding an object
       playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName))
       (playerCharacterWME.getObjectHeld().equals("") == false) 
       
       recipientCharacterWME=(CharacterWME) (recipientCharacterWME.getName().equals(recipient))                 
       // hostile NPC won't take it
       (recipientCharacterWME.hasAttitude(eAttitudeType_hostile) == false)
       
             groupWME=(GroupWME) (groupWME.contains(recipientCharacterWME) && 
                               groupWME.contains(playerCharacterWME))
             
             // IS THE PRIMARY RECIPIENT OF THE SIGNAL NON-NULL
             (signalWME.getPrimaryRecipient() != null)  
       ->
       (CiFSiuLaunchWME ruleName=ruleNameOfferHeldObjectNomination signalWME=signalWME initiator=initiator recipient=recipient)
       (CiFRuleUtilWME name="nominationInGiveOfferShowObjectChain")
       ( { System.out.println("CiF rule: SIU offer object nominated for: " + initiator + " and " +recipient); } )
    } 
    
    // ### offer held object volition
    rule offerHeldObjectVolition {
       ciFSiuLaunchWME=(CiFSiuLaunchWME candidate==true) (ruleNameOfferHeldObjectNomination.equals(ciFSiuLaunchWME.getRuleName()))
       ->
       (VolitionWME score=10 ciFSiuLaunchWME=ciFSiuLaunchWME)
       ({ciFSiuLaunchWME.addScore(10);})
    }
    
    
    
    // ### show held object nomination
    // LOWER specificity than GIVE and OFFER.
    rule showHeldObjectNomination {
       !(CiFRuleUtilWME name=="nominationInGiveOfferShowObjectChain")  // enforce rule specificity
       signalWME=(SocialSignalWME seenByVolition==false closestRecipient::recipient sender::initiator)
       (signalWME.getFirstSocialInterpretation() == socialInterpretationExtendHand)
      (initiator.equals(playerName))
       
       // player IS holding an object
       playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName))
       (playerCharacterWME.getObjectHeld().equals("") == false)
       
       recipientCharacterWME=(CharacterWME) (recipientCharacterWME.getName().equals(recipient)) 
             groupWME=(GroupWME) (groupWME.contains(recipientCharacterWME) && 
                               groupWME.contains(playerCharacterWME))
       ->
       (CiFSiuLaunchWME ruleName=ruleNameShowHeldObjectNomination signalWME=signalWME initiator=initiator recipient=recipient)
       (CiFRuleUtilWME name="nominationInGiveOfferShowObjectChain")
       ( { System.out.println("CiF rule: SIU show object nominated for: " + initiator + " and " +recipient); } )
    }
    
    // ### show held object volition
    rule showHeldObjectVolition {
       ciFSiuLaunchWME=(CiFSiuLaunchWME candidate==true) (ruleNameShowHeldObjectNomination.equals(ciFSiuLaunchWME.getRuleName()))
       ->
       (VolitionWME score=10 ciFSiuLaunchWME=ciFSiuLaunchWME)
       ({ciFSiuLaunchWME.addScore(10);})
    }
    
    
    // ### request object from character holding it nomination
    rule requestObjectFromCharacterHoldingItNomination {

       signalWME=(SocialSignalWME seenByVolition==false closestRecipient::recipient sender::initiator)
       (signalWME.getFirstSocialInterpretation() == socialInterpretationExtendHand)
      (initiator.equals(playerName))
       
       // player is NOT holding an object
       playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName))
       (playerCharacterWME.getObjectHeld().equals("") == true) 
       
       // recipient IS holding an object
       // signal needs to be directed at a character holding an object                  
       recipientCharacterWME=(CharacterWME) 
       (recipientCharacterWME.getName().equals(signalWME.getPrimaryRecipient()) &&
       recipientCharacterWME.getObjectHeld().equals("") == false)  
        
       groupWME=(GroupWME) (groupWME.contains(recipientCharacterWME) && 
       groupWME.contains(playerCharacterWME))
       ->
       (CiFSiuLaunchWME ruleName=ruleNameRequestObjectFromCharacterHoldingItNomination signalWME=signalWME initiator=initiator recipient=recipient)
       ( { System.out.println("CiF rule: SIU request object nominated for: " + initiator + " and " +recipient); } )
    }
    
    // ### show held object volition
    rule requestObjectFromCharacterHoldingItVolition {
       ciFSiuLaunchWME=(CiFSiuLaunchWME candidate==true) (ruleNameRequestObjectFromCharacterHoldingItNomination.equals(ciFSiuLaunchWME.getRuleName()))
       ->
       (VolitionWME score=10 ciFSiuLaunchWME=ciFSiuLaunchWME)
       ({ciFSiuLaunchWME.addScore(10);})
    }
    
    // ### Point to held object at group nomination     
    rule pointToHeldObjectAtGroupNomination {

       signalWME=(SocialSignalWME seenByVolition==false closestRecipient::recipient sender::initiator)
       (signalWME.getFirstSocialInterpretation() == socialInterpretationPointAtHeldObject)
      (initiator.equals(playerName))
      
       //grab the player, recipient, and the group that they are both in
       playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName))
       recipientCharacterWME=(CharacterWME) (recipientCharacterWME.getName().equals(recipient)) 
             groupWME=(GroupWME) (groupWME.contains(recipientCharacterWME) && 
                               groupWME.contains(playerCharacterWME))
       ->
       (CiFSiuLaunchWME ruleName=ruleNamePointToHeldObjectAtGroupNomination signalWME=signalWME initiator=initiator recipient=recipient)
       ( { System.out.println("CiF rule: SIU point at held object nominated for: " + initiator + " and " +recipient); } )
    }
    
    // ### point to held object at group volition
    rule pointToHeldObjectAtGroupVolition {
       ciFSiuLaunchWME=(CiFSiuLaunchWME candidate==true) (ruleNamePointToHeldObjectAtGroupNomination.equals(ciFSiuLaunchWME.getRuleName()))
       ->
       (VolitionWME score=10 ciFSiuLaunchWME=ciFSiuLaunchWME)
       ({ciFSiuLaunchWME.addScore(10);})
    }
    
    // ### Point left or right nomination   
    rule pointLeftOrRightNomination {

       signalWME=(SocialSignalWME seenByVolition==false closestRecipient::recipient sender::initiator)
       (signalWME.getFirstSocialInterpretation() == socialInterpretationPointLeft ||
        signalWME.getFirstSocialInterpretation() == socialInterpretationPointRight)

                // NPCs can now generate Point signals, that other NPCs react to 
                //(initiator.equals(playerName))
                
                playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName))
                recipientCharacterWME=(CharacterWME) (recipientCharacterWME.getName().equals(recipient)) 
                      groupWME=(GroupWME) (groupWME.contains(recipientCharacterWME) && 
                                        groupWME.contains(playerCharacterWME))
       ->
       (CiFSiuLaunchWME ruleName=ruleNamePointLeftOrRightNomination signalWME=signalWME initiator=initiator recipient=recipient)
       ( { System.out.println("CiF rule: SIU point left or right nominated for: " + initiator + " and " +recipient); } )
    }
    
    // ### point left or right volition
    rule pointLeftOrRightVolition {
       ciFSiuLaunchWME=(CiFSiuLaunchWME candidate==true) (ruleNamePointLeftOrRightNomination.equals(ciFSiuLaunchWME.getRuleName()))
       ->
       (VolitionWME score=10 ciFSiuLaunchWME=ciFSiuLaunchWME)
       ({ciFSiuLaunchWME.addScore(10);})
    }
    
    
    
    
    
/*    
    //GIVE HELD OBJECT TO SOMEONE REQUESTING IT
    //The execution of this seems to be much more complicated than the previous ones.
    //So maybe the volition rule for this one is going to be different?
    //I'm also not 100 percent sure on what the proper 'name' of this SIU should be for the right hand side of the rule...
    rule offerHeldObjectPre1{
       signalWME=(SocialSignalWME seenByVolition==false closestRecipient::recipient sender::initiator)
       (signalWME.getFirstSocialInterpretation() == socialInterpretationExtendHand)
	   (initiator.equals(playerName))
       playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName))
       (playerCharacterWME.getObjectHeld().equals("") == false)
       siuWME=(SiuWME name==siuNameRequestObject)
       (siuWME.getState() == SiuExecutionState.EXECUTING)
       recipientCharacterWME=(CharacterWME) (recipientCharacterWME.getName().equals(recipient))
       groupWME=(GroupWME) (groupWME.contains(recipientCharacterWME) && groupWME.contains(playerCharacterWME))
       ->(SiuWME name=siuNameGiveObject triggerSignalWME=signalWME initiator=recipientCharacterWME primaryResponder=playerCharacterWME)
    }
    
    //GIVE HELD OBJEJCT TO SOMEONE REQUESTING IT VOLITION
    rule offerHeldObjectVol1{
       siu=(SiuWME candidate==true)(siuNameGiveObject.equals(siu.getName()))
       ->(VolitionWME score=10 siuWME=siu)
       ({siu.addScore(4);})
    }
    
    
    //SHOW HELD OBJECT TO GROUP / siuNameGroupStudyObject
    //Again, I'm unsure as to whether or not I'm using the correct siuName here. There doesn't seem to be an SIU for 'showing' the object.
    //But if it is the player that is showing the object, I guess I'm thinking that the NPC will be studying it.
    rule showHeldObjectPre1{
       signalWME=(SocialSignalWME seenByVolition==false closestRecipient::recipient sender::initiator)
       (signalWME.getFirstSocialInterpretation() == socialInterpretationExtendHand)
	   (initiator.equals(playerName))
       playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName))
       (playerCharacterWME.getObjectHeld().equals("") == false)
       recipientCharacterWME=(CharacterWME) (recipientCharacterWME.getName().equals(recipient))
       groupWME=(GroupWME) (groupWME.contains(recipientCharacterWME) && groupWME.contains(playerCharacterWME))
       ->(SiuWME name=siuNameGroupStudyObject triggerSignalWME=signalWME initiator=playerCharacterWME primaryResponder=recipientCharacterWME)
    }
    
    //SHOW HELD OBJECT TO GROUP
    rule showHeldObjectVol1{
       siu=(SiuWME candidate==true)(siuNameGroupStudyObject.equals(siu.getName()))
       ->(VolitionWME score=10 siuWME=siu)
       ({siu.addScore(10);})
    }

    //REQUEST OBJECT FROM CHARACTER HOLDING IT
    //Again, I'm a little confused -- I guess we are authoring these from the NPC's perspectives?
    //So, the initiator is the 'recipient', and since the player requested the object, we want to make a new 'giveObjectBackToPlayer' SIU, yes? Yes, I think so.
    rule requestObjectBackPre1{
       signalWME=(SocialSignalWME seenByVolition==false closestRecipient::recipient sender::initiator)
       (signalWME.getFirstSocialInterpretation() == socialInterpretationExtendHand)       
	   (initiator.equals(playerName))
		// player is NOT holding an object       
       playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName))
       (playerCharacterWME.getObjectHeld().equals("") == true)              
		// signal needs to be directed at a character holding an object						
		recipientCharacterWME=(CharacterWME) 
		(recipientCharacterWME.getName().equals(signalWME.getPrimaryRecipient()) &&
		 recipientCharacterWME.getObjectHeld().equals("") == false)						 
       groupWME=(GroupWME) (groupWME.contains(recipientCharacterWME) && groupWME.contains(playerCharacterWME))
       ->(SiuWME name=siuNameGiveObjectToPlayer triggerSignalWME=signalWME initiator=playerCharacterWME primaryResponder=recipientCharacterWME)
    }
    
    //REQUEST OBJECT BACK FROM GROUP
    rule requestObjectBackVol1{
       siu=(SiuWME candidate==true)(siuNameGiveObjectToPlayer.equals(siu.getName()))
       ->(VolitionWME score=10 siuWME=siu)
       ({siu.addScore(10);})
    }
    
    //POINT TO HELD OBJECT AT GROUP
    //Based on the testbed behavior that gets called, it seems like "siuNameRequestObject" is the siu that is ultimately being called.
    //There is also some 'group confusion' that happens as well currently in CiF, that isn't being captured now.
    rule pointToHeldObjectAtGroupPre1{
       signalWME=(SocialSignalWME seenByVolition==false closestRecipient::recipient sender::initiator)
       (signalWME.getFirstSocialInterpretation() == socialInterpretationPointAtHeldObject)
	   (initiator.equals(playerName))
       playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName))
       recipientCharacterWME=(CharacterWME) (recipientCharacterWME.getName().equals(recipient))
       groupWME=(GroupWME) (groupWME.contains(recipientCharacterWME) && groupWME.contains(playerCharacterWME))
       ->(SiuWME name=siuNameRequestObject triggerSignalWME=signalWME initiator=recipientCharacterWME primaryResponder=playerCharacterWME)
    }
    
    //POINT TO HELD OBJECT AT GROUP
    rule pointToHeldObjectAtGroupVol1{
       siu=(SiuWME candidate==true)(siuNameRequestObject.equals(siu.getName()))
       ->(VolitionWME score=10 siuWME=siu)
       ({siu.addScore(4);})
    }
    
    //GROUP REACT TO QUESTION 1 (Interpretation = socialInterpretationPointLeft)
    rule groupReactToQuestionPre1{
       signalWME=(SocialSignalWME seenByVolition==false closestRecipient::recipient sender::initiator)
       (signalWME.getFirstSocialInterpretation() == socialInterpretationPointLeft)
	   (initiator.equals(playerName))
       playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName))
       recipientCharacterWME=(CharacterWME) (recipientCharacterWME.getName().equals(recipient))
       groupWME=(GroupWME) (groupWME.contains(recipientCharacterWME) && groupWME.contains(playerCharacterWME))
       ->(SiuWME name=siuNameGroupReactToQuestion triggerSignalWME=signalWME initiator=recipientCharacterWME primaryResponder=playerCharacterWME)
    }
    
    //GROUP REACT TO QUESTION (Interpretation = socialInterpretationPointRight)
    rule groupReactToQuestionPre2{
       signalWME=(SocialSignalWME seenByVolition==false closestRecipient::recipient sender::initiator)
       (signalWME.getFirstSocialInterpretation() == socialInterpretationPointRight)
	   (initiator.equals(playerName))
       playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName))
       recipientCharacterWME=(CharacterWME) (recipientCharacterWME.getName().equals(recipient))
       groupWME=(GroupWME) (groupWME.contains(recipientCharacterWME) && groupWME.contains(playerCharacterWME))
       ->(SiuWME name=siuNameGroupReactToQuestion triggerSignalWME=signalWME initiator=recipientCharacterWME primaryResponder=playerCharacterWME)
    }
    
    //GROUP REACT TO QUESTION
    rule groupReactToQuestionVol1{
       siu=(SiuWME candidate==true)(siuNameGroupReactToQuestion.equals(siu.getName()))
       ->(VolitionWME score=10 siuWME=siu)
       ({siu.addScore(4);})
    }
    
    //BRIEF CHAT
    //This one seems weird...
    //It has no signal (so can't assign anything to the "triggerSignalWME" field in the RHS SiuWME).
    //It also doesn't seem to have the same typical initiator and responder formula.
    //It only has a single character passed in, in the form a string called "myName."
    //**It ALSO does one of those stagingPercentChance things, with a 'chance' value passed in, which I don't quite know how to capture here.**
    rule briefChatPre1{
       //(Staging.percentChance(chance)) -- maybe the way to go would be to use some kind of random number generator here... Is that kosher?
       myCharacterWME=(CharacterWME)
       groupWME=(GroupWME) (groupWME.contains(myCharacterWME))
       ->(SiuWME name=siuNameBriefChat)
    }
    
  //BRIEF CHAT
    rule briefChatVol1{
       siu=(SiuWME candidate==true)(siuNameBriefChat.equals(siu.getName()))
       ->(VolitionWME score=10 siuWME=siu)
       //({siu.addScore(10);})
    }
*/


	// THESE UTILITY RULES NEED TO RUN AFTER THE NOMINATION RULES
	// IDEALLY THEY WOULD NOT HAVE TO BE PLACED AT THE BOTTOM OF THIS FILE TO ENFORCE THAT
    
    /**
     * markSocialSignalsAsSeen
     * we've had our chance to react to the social signal. Time to mark it as being seen.
     */
    rule markSocialSignalsAsSeen {
    	signal=(SocialSignalWME seenByVolition==false)
    	->
    	({signal.setSeenByVolition(true);})
    }

    
    /**
     * promoteCandidates
     * promotes candidates with score about the threshold from CANDIDATE to a REQUESTED_EXECUTION.
     */
    rule promoteCandidates { 
    	ciFSiuLaunchWME=(CiFSiuLaunchWME candidate==true score>=5)
    	(BehavingEntity.truePrintln("promoting to requested execution: " + ciFSiuLaunchWME.getRuleName())) 
    	-> 
    	({ciFSiuLaunchWME.setState(SiuExecutionState.REQUESTED_EXECUTION);})
	}
    
    
    /**
     * removeCandidates
     * remove all candidates that were not promoted.
     */
    rule removeCandidates { 
    	(CiFSiuLaunchWME candidate==true) 
    	-> 
    	!(CiFSiuLaunchWME candidate==true) }
  	
	/**
	 * cif_adhoc_globalReaction() -- None found
	 */	 	
	sequential behavior cif_adhoc_globalReaction(SocialSignalWME signalWME, SocialInterpretation interpretation, String gestureName, String initiator, String recipient) {
		specificity 1;
		mental_act { log.info("##### NO CIF ADHOC GLOBAL REACTION FOUND for " +interpretation+ " gesture " +gestureName+ " from " +initiator+ " to " +recipient); }
	}

	
	/**
	 * cif_siuSetup_approach() -- Approach
	 */	 	
	 
				/* ADHOC RULE COMMENTED OUT, REPLACED BY PROPER CIF RULE
				sequential behavior cif_adhoc_globalReaction(SocialSignalWME signalWME, SocialInterpretation interpretation, String gestureName, String initiator, String recipient) {
					precondition {	(interpretation == socialInterpretationApproach) }
					specificity 3;
					
					mental_act { 
						log.info("##### CIF ADHOC GLOBAL REACTION for " +interpretation+ " (Approach) from " +initiator+ " to " +recipient); 
					}
					
					subgoal cif_siuSetup_approach(signalWME, interpretation, initiator, recipient);
				}
				*/
								
	sequential behavior cif_siuSetup_approach(SocialSignalWME signalWME, SocialInterpretation interpretation, 
													String initiator, String recipient) {
		mental_act { 
			log.info("##### CIF SIU SETUP for " +interpretation+ " from " +initiator+ " to " +recipient); 
		}
			
		// launch the Approach SIU
		spawngoal testbed_LaunchSIU_approachGroup(initiator, recipient);
	}
	

	/**
	 * cif_siuSetup_greet() -- Greet from player to group
	 * higher specificity than mirror
	 */	 
	 
				/* ADHOC RULE COMMENTED OUT, REPLACED BY PROPER CIF RULE
				sequential behavior cif_adhoc_globalReaction(SocialSignalWME signalWME, SocialInterpretation interpretation, String gestureName, String initiator, String recipient) {
					precondition {	(interpretation == socialInterpretationGreetingWaveFriendly ||
										interpretation == socialInterpretationGreetingSpeechFriendly ||
										interpretation == socialInterpretationGreetingSpeechNeutral
										)		
									(initiator.equals(playerName))
			
									//fixme: want to also check timestamp, but how to in a negate test? 
									!(EpisodicMemoryWME characterName==recipient recipientName==initiator episodeName==siuNameGreet)
									
									playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName))
									recipientCharacterWME=(CharacterWME) (recipientCharacterWME.getName().equals(recipient)) 
			                     	groupWME=(GroupWME) (groupWME.contains(recipientCharacterWME) && 
			                     							groupWME.contains(playerCharacterWME))
									}
									
					specificity 3;
									 
					mental_act { 
						log.info("##### CIF ADHOC GLOBAL REACTION for " +interpretation+ " (Greet) from " +initiator+ " to " +recipient); 
					}
					
					subgoal cif_siuSetup_greet(signalWME, interpretation, initiator, recipient, gestureName);
				}
				*/
					
	sequential behavior cif_siuSetup_greet(SocialSignalWME signalWME, SocialInterpretation interpretation, 
													String initiator, String recipient, 
													String gestureName) {
		precondition {	playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName))
						recipientCharacterWME=(CharacterWME) (recipientCharacterWME.getName().equals(recipient)) 
                     	groupWME=(GroupWME) (groupWME.contains(recipientCharacterWME) && 
                     							groupWME.contains(playerCharacterWME))
                     }
					
		mental_act { 
			log.info("##### CIF SIU SETUP for " +interpretation+ " (Greet) from " +initiator+ " to " +recipient); 
		}
		
		// kill off any high priority brief chats occurring in this group
		with (ignore_failure) subgoal siu_requestTerminationOfAllAnSIUInGroup(initiator, siuNameBriefChat);
		
		// launch the Greet SIU
		spawngoal testbed_LaunchSIU_groupGreet(playerName, groupWME, gestureName);

		subgoal testbed_waitForSIUToStart(playerName, siuNameGreet);

		// end the approach SIU!!!
		// fixme: one better way to do this would be, approach should end itself when discourse/engagement has begun 
		subgoal siu_requestTermination(siuNameApproach, playerName);		

		// Add initiator to non-hostile group formation
		// There is already a general CiF rule to do this, but it may not fire in time,
		// because the setNewSpeaker() below may need the initiator in the formation
		// it's harmless for this to happen twice - here and in the CiF rule
		mental_act {		
			if (!recipientCharacterWME.hasAttitude(eAttitudeType_hostile)) {
				groupWME.addFormationCharacter(playerCharacterWME);
			}
		} 
				
		// make player the group's new speaker
		with (ignore_failure) subgoal testbed_groupMaintenance_setNewSpeaker(groupWME, playerName, smallTalk_DiscussClose);
	}
	

	/**
	 * cif_adhoc_globalReaction() -- Group mirrors initiator
	 * lower specificity than greet
	 */
				/* ADHOC RULE COMMENTED OUT, REPLACED BY PROPER CIF RULE
				sequential behavior cif_adhoc_globalReaction(SocialSignalWME signalWME, SocialInterpretation interpretation, String gestureName, String initiator, String recipient) {
					precondition {	(interpretation == socialInterpretationGreetingWaveFriendly
										)		
									(initiator.equals(playerName))
									
									playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName))
									recipientCharacterWME=(CharacterWME) (recipientCharacterWME.getName().equals(recipient)) 
			                     	groupWME=(GroupWME) (groupWME.contains(recipientCharacterWME) && 
			                     							groupWME.contains(playerCharacterWME))
			                     }
					specificity 2;
					mental_act { 
						log.info("##### CIF ADHOC GLOBAL REACTION for " +interpretation+ " (Mirror) from " +initiator+ " to " +recipient); 
					}
					
					subgoal cif_siuSetup_mirror(signalWME, interpretation, initiator, recipient, gestureName);
				}
				*/
								
	sequential behavior cif_siuSetup_mirror(SocialSignalWME signalWME, SocialInterpretation interpretation, 
													String initiator, String recipient, String gestureName) {
		precondition {	playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName))
						recipientCharacterWME=(CharacterWME) (recipientCharacterWME.getName().equals(recipient)) 
                     	groupWME=(GroupWME) (groupWME.contains(recipientCharacterWME) && 
                     							groupWME.contains(playerCharacterWME))
                     }
		mental_act { 
			log.info("##### CIF SIU SETUP for " +interpretation+ " from " +initiator+ " to " +recipient); 
		}
		
		// launch the Mirror SIU
		spawngoal testbed_LaunchSIU_groupMirror(initiator, groupWME, interpretation, gestureName);		
	}
		

	/**
	 * cif_adhoc_globalReaction() -- Personal space violation
	 */	 	
			    /* ADHOC RULE COMMENTED OUT, REPLACED BY PROPER CIF RULE
				sequential behavior cif_adhoc_globalReaction(SocialSignalWME signalWME, SocialInterpretation interpretation, String gestureName, String initiator, String recipient) {
					precondition {	(interpretation == socialInterpretationVeryClose)		
									(initiator.equals(playerName))
									playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName))
									recipientCharacterWME=(CharacterWME) (recipientCharacterWME.getName().equals(recipient)) 
			                     	groupWME=(GroupWME) (groupWME.contains(recipientCharacterWME) && 
			                     							groupWME.contains(playerCharacterWME))
			                     							
									// I am hostile, not leader, not sympathetic
									(recipientCharacterWME.hasAttitude(eAttitudeType_hostile) == true &&
										recipientCharacterWME.hasAttitude(eAttitudeType_leader) == false &&
										recipientCharacterWME.hasAttitude(eAttitudeType_sympathetic) == false)
									
									// haven't done personal space SIU already                     							
									!(EpisodicMemoryWME characterName==recipient recipientName==initiator episodeName==siuNamePersonalSpace)
			                     }
					specificity 2;
					mental_act { 
						log.info("##### CIF ADHOC GLOBAL REACTION for " +interpretation+ " (Personal Space) from " +initiator+ " to " +recipient); 
					}
					
					subgoal cif_siuSetup_personalSpace(signalWME, interpretation, initiator, recipient);
				}
				*/
	
	sequential behavior cif_siuSetup_personalSpace(SocialSignalWME signalWME, SocialInterpretation interpretation, 
													String initiator, String recipient) {
		precondition {	recipientCharacterWME=(CharacterWME) (recipientCharacterWME.getName().equals(recipient)) 
						}
		mental_act { 
			log.info("##### CIF SIU SETUP for " +interpretation+ " (Personal Space) from " +initiator+ " to " +recipient); 
		}
		
		// kill off any high priority brief chats occurring in this group
		with (ignore_failure) subgoal siu_requestTerminationOfAllAnSIUInGroup(initiator, siuNameBriefChat);
		
		// launch the PersonalSpace SIU, only with recipient
		spawngoal testbed_LaunchSIU_personalSpace(initiator, recipientCharacterWME, interpretation);		
	}
	

	/**
	 * cif_adhoc_globalReaction() -- Give held object to someone who is requesting it
	 */	 	
	   /* ADHOC RULE COMMENTED OUT, REPLACED BY PROPER CIF RULE
	sequential behavior cif_adhoc_globalReaction(SocialSignalWME signalWME, SocialInterpretation interpretation, String gestureName, String initiator, String recipient) {
		precondition {	(interpretation == socialInterpretationExtendHand)
						(initiator.equals(playerName))
						
						// player IS holding an object
						playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName))
						(playerCharacterWME.getObjectHeld().equals("") == false)
		
						// interpret extend hand signal as a Give if an NPC is requesting the player's held object
						requestObjectSiuWME=(SiuWME name==siuNameRequestObject)
						(requestObjectSiuWME.getState() == SiuExecutionState.EXECUTING)
                     							
                     	// IS THE PRIMARY RECIPIENT OF THE SIGNAL THE NPC REQUESTING THE OBJECT
                     	(requestObjectSiuWME.getInitiator().getName().equals(signalWME.getPrimaryRecipient()))                     	
								
						recipientCharacterWME=(CharacterWME) (recipientCharacterWME.getName().equals(recipient)) 
                     	groupWME=(GroupWME) (groupWME.contains(recipientCharacterWME) && 
                     							groupWME.contains(playerCharacterWME))
                     }
        
        // THIS NEEDS TO RUN BEFORE THE OFFER RULE (specificity 3) and SHOW RULE (specificity 2)             
		specificity 4;
		String requester;
		
		mental_act { 			
			// the requester isn't necessarily the one the signal went to
			// it's the NPC who is actually currently running the request SIU
			requester = requestObjectSiuWME.getInitiator().getName();
			 
			log.info("##### CIF ADHOC GLOBAL REACTION for " +interpretation+ " (Give Held Object) from " +initiator+ " to " +requester);
		}
		
		subgoal cif_siuSetup_giveHeldObject(signalWME, interpretation, initiator, recipient, requestObjectSiuWME);
	}
   // */					
	sequential behavior cif_siuSetup_giveHeldObject(SocialSignalWME signalWME, SocialInterpretation interpretation, 
													String initiator, String recipient, SiuWME requestObjectSiuWME) {
		String requester;
		
		mental_act { 			
			// the requester isn't necessarily the one the signal went to
			// it's the NPC who is actually currently running the request SIU
			requester = requestObjectSiuWME.getInitiator().getName(); 
			
			log.info("##### CIF SIU SETUP for " +interpretation+ " (Give Held Object) from " +initiator+ " to " +requester);
		}

		// end the requestObject SIU!!!
		subgoal siu_requestTermination(siuNameRequestObject, requester);
		
		// wait for it to stop! seems to be needed....		
		subgoal testbed_waitForSIUToStop(requestObjectSiuWME, true);
		
		spawngoal testbed_LaunchSIU_takeObjectFromPlayer(initiator, requester);
				
		subgoal testbed_waitForSIUToStartAndStop(initiator, siuNameTakeObjectFromPlayer);

		// launch the GroupPassObject SIU for the requester
		spawngoal testbed_LaunchSIU_groupPassObject(requester);
	}
	


	/**
	 * cif_adhoc_globalReaction() -- Offer held object to someone (who is not currently requesting it)
	 */	 
	  /* ADHOC RULE COMMENTED OUT, REPLACED BY PROPER CIF RULE
	sequential behavior cif_adhoc_globalReaction(SocialSignalWME signalWME, SocialInterpretation interpretation, String gestureName, String initiator, String recipient) {
		precondition {	(interpretation == socialInterpretationExtendHand)
						(initiator.equals(playerName))
						
						// player IS holding an object
						playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName))
						(playerCharacterWME.getObjectHeld().equals("") == false) 
								
						recipientCharacterWME=(CharacterWME) (recipientCharacterWME.getName().equals(recipient))						
						// hostile NPC won't take it
						(recipientCharacterWME.hasAttitude(eAttitudeType_hostile) == false)
						 
                     	groupWME=(GroupWME) (groupWME.contains(recipientCharacterWME) && 
                     							groupWME.contains(playerCharacterWME))
                     							
                     	// IS THE PRIMARY RECIPIENT OF THE SIGNAL NON-NULL
                     	(signalWME.getPrimaryRecipient() != null)                     	
                     }
        
        // THIS NEEDS TO RUN AFTER THE GIVE RULE (specificity 4) and BEFORE THE SHOW RULE (specificity 2)             
		specificity 3;
		
		String requester;
		
		mental_act { 			
			requester = signalWME.getPrimaryRecipient();
			log.info("##### CIF ADHOC GLOBAL REACTION for " +interpretation+ " (Offer Held Object) from " +initiator+ " to " +requester);
		}
		
		subgoal cif_siuSetup_offerHeldObject(signalWME, interpretation, initiator, recipient);
	}
   // */
	sequential behavior cif_siuSetup_offerHeldObject(SocialSignalWME signalWME, SocialInterpretation interpretation, 
														String initiator, String recipient) {
		String requester;
		
		mental_act { 			
			requester = signalWME.getPrimaryRecipient();
			log.info("##### CIF SIU SETUP for " +interpretation+ " (Offer Held Object) from " +initiator+ " to " +requester);
		}
		
		subgoal cif_siuSetupMore_requestObject(signalWME, requester, initiator);
	}

   sequential behavior cif_siuSetupMore_requestObject(SocialSignalWME signalWME, String myName/*receiver*/, String requesteeName/*giver*/) {
      precondition { // if the requested requestee very recently just took the object from the character asked to take it back now,
                   	// then suppress this request!! 
                    // Needed to ignore spurious extend_hand signals right after taken the object from an NPC 
					epWME=(EpisodicMemoryWME episodeName==event_tookObject
											characterName==requesteeName recipientName==myName)
					(epWME.isMoreRecentThan(4000))                   
                   }
        specificity 2;
        mental_act { log.info("## " +myName+ " request to " +siuNameRequestObject+ " from " +requesteeName+ " suppressed - it was very recently given by " +myName); }       
   }
		
   sequential behavior cif_siuSetupMore_requestObject(SocialSignalWME signalWME, String myName/*receiver*/, String requesteeName/*giver*/) {
   		specificity 1;
   		
		// end any brief chat the requester is doing
		with (ignore_failure) subgoal siu_requestTermination(siuNameBriefChat, myName);

		spawngoal testbed_LaunchSIU_requestObject(myName, requesteeName);				
	}
				
				

	/**
	 * cif_adhoc_globalReaction() -- Show held object to group
	 */	 	
   /* ADHOC RULE COMMENTED OUT, REPLACED BY PROPER CIF RULE
	sequential behavior cif_adhoc_globalReaction(SocialSignalWME signalWME, SocialInterpretation interpretation, String gestureName, String initiator, String recipient) {
		precondition {	(interpretation == socialInterpretationExtendHand)		
						(initiator.equals(playerName))
						
						// player IS holding an object
						playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName))
						(playerCharacterWME.getObjectHeld().equals("") == false)
							
						recipientCharacterWME=(CharacterWME) (recipientCharacterWME.getName().equals(recipient)) 
                     	groupWME=(GroupWME) (groupWME.contains(recipientCharacterWME) && 
                     							groupWME.contains(playerCharacterWME))
                     }
                     
        // THIS NEEDS TO RUN AFTER THE GIVE RULE (specificity 4) and the OFFER RULE (specificity 3)             
		specificity 2;
		
		mental_act { 
			log.info("##### CIF ADHOC GLOBAL REACTION for " +interpretation+ "  (Show Held Object) from " +initiator+ " to " +recipient); 
		}
		
		subgoal cif_siuSetup_showHeldObject(signalWME, interpretation, initiator, recipient);
	}
	// */			
	sequential behavior cif_siuSetup_showHeldObject(SocialSignalWME signalWME, SocialInterpretation interpretation, 
													String initiator, String recipient) {
		precondition {	playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName))
						recipientCharacterWME=(CharacterWME) (recipientCharacterWME.getName().equals(recipient)) 
                     	groupWME=(GroupWME) (groupWME.contains(recipientCharacterWME) && 
                     							groupWME.contains(playerCharacterWME))
                     }
		mental_act { 
			log.info("##### CIF SIU SETUP for " +interpretation+ "  (Show Held Object) from " +initiator+ " to " +recipient); 
		}
		
		// kill off any high priority brief chats occurring in this group
		with (ignore_failure) subgoal siu_requestTerminationOfAllAnSIUInGroup(initiator, siuNameBriefChat);
		
		// launch the GroupStudyObject SIU
		spawngoal testbed_LaunchSIU_groupStudyObject(initiator, groupWME);		
	}
	
	
		
	/**
	 * cif_adhoc_globalReaction() -- Request object from character holding it
	 */	
	/* ADHOC RULE COMMENTED OUT, REPLACED BY PROPER CIF RULE
	sequential behavior cif_adhoc_globalReaction(SocialSignalWME signalWME, SocialInterpretation interpretation, String gestureName, String initiator, String recipient) {
		precondition {	(interpretation == socialInterpretationExtendHand)		
						(initiator.equals(playerName))
						
						// player is NOT holding an object
						playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName))
						(playerCharacterWME.getObjectHeld().equals("") == true)	

						// recipient IS holding an object
						// signal needs to be directed at a character holding an object						
						recipientCharacterWME=(CharacterWME) 
						(recipientCharacterWME.getName().equals(signalWME.getPrimaryRecipient()) &&
						 recipientCharacterWME.getObjectHeld().equals("") == false)						 

                     	groupWME=(GroupWME) (groupWME.contains(recipientCharacterWME) && 
                     							groupWME.contains(playerCharacterWME))
                     }
                     
		specificity 2;
		String objectHolder;
		
		mental_act { 
			objectHolder = signalWME.getPrimaryRecipient();
			log.info("##### CIF ADHOC GLOBAL REACTION for " +interpretation+ " (Request Object) from " +initiator+ " to " +objectHolder);
		}
		
		subgoal cif_siuSetup_requestObject(signalWME, interpretation, initiator, recipient);
	}
	// */				
	sequential behavior cif_siuSetup_requestObject(SocialSignalWME signalWME, SocialInterpretation interpretation, 
														String initiator, String recipient) {
		String objectHolder;
		
		mental_act { 
			objectHolder = signalWME.getPrimaryRecipient();
			log.info("##### CIF SIU SETUP for " +interpretation+ " (Request Object) from " +initiator+ " to " +objectHolder);
		}

		subgoal cif_siuSetupMore_giveObjectToPlayer(objectHolder, initiator);
	}

   sequential behavior cif_siuSetupMore_giveObjectToPlayer(String objectHolder, String initiator) {
      precondition { // if the initiator very recently just gave the object to the objectHolder,
                    // then suppress this request!! 
                    // Needed to ignore spurious extend_hand signals right after taken the object from an NPC 
					epWME=(EpisodicMemoryWME episodeName==event_gaveObject
											characterName==initiator recipientName==objectHolder)
					(epWME.isMoreRecentThan(4000))                   
                   }
        specificity 2;
        mental_act { log.info("## " +initiator+ " request to " +siuNameGiveObjectToPlayer+ " from " +objectHolder+ " suppressed - it was very recently given by " +initiator); }       
   }
		
   sequential behavior cif_siuSetupMore_giveObjectToPlayer(String objectHolder, String initiator) {
   		specificity 1;
 
		// kill off any high priority brief chats occurring in this group
		with (ignore_failure) subgoal siu_requestTerminationOfAllAnSIUInGroup(initiator, siuNameBriefChat);

		// kill off any SIUs using the object
		with (ignore_failure) subgoal siu_requestTerminationOfAllAnSIUInGroup(initiator, siuNameGroupPassObject);
		with (ignore_failure) subgoal siu_requestTerminationOfAllAnSIUInGroup(initiator, siuNameStudyOwnObject);
		with (ignore_failure) subgoal siu_requestTerminationOfAllAnSIUInGroup(initiator, siuNameGiveObject);
		with (ignore_failure) subgoal siu_requestTerminationOfAllAnSIUInGroup(initiator, siuNameGroupStudyObject);
		
		// launch the GiveObjectToPlayer SIU
		spawngoal testbed_LaunchSIU_giveObjectToPlayer(objectHolder, initiator);		
	}
	

	/**
	 * cif_adhoc_globalReaction() -- Point to held object at group
	 */	 	
   /* ADHOC RULE COMMENTED OUT, REPLACED BY PROPER CIF RULE
	sequential behavior cif_adhoc_globalReaction(SocialSignalWME signalWME, SocialInterpretation interpretation, String gestureName, String initiator, String recipient) {
		precondition {	(interpretation == socialInterpretationPointAtHeldObject)
						(initiator.equals(playerName))
						playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName))
						recipientCharacterWME=(CharacterWME) (recipientCharacterWME.getName().equals(recipient)) 
                     	groupWME=(GroupWME) (groupWME.contains(recipientCharacterWME) && 
                     							groupWME.contains(playerCharacterWME))
                     }
		specificity 2;
		
		mental_act { 
			log.info("##### CIF ADHOC GLOBAL REACTION for " +interpretation+ " from " +initiator+ " to " +recipient); 
		}
		
		subgoal cif_siuSetup_pointAtHeldObject(signalWME, interpretation, initiator, recipient);
	}
   // */
   
	sequential behavior cif_siuSetup_pointAtHeldObject(SocialSignalWME signalWME, SocialInterpretation interpretation, 
													String initiator, String recipient) {
		precondition {	playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName))
						recipientCharacterWME=(CharacterWME) (recipientCharacterWME.getName().equals(recipient)) 
                     	groupWME=(GroupWME) (groupWME.contains(recipientCharacterWME) && 
                     							groupWME.contains(playerCharacterWME))
                     }
		mental_act { 
			log.info("##### CIF SIU SETUP for " +interpretation+ " from " +initiator+ " to " +recipient); 
		}

		// kill off any high priority brief chats occurring in this group
		with (ignore_failure) subgoal siu_requestTerminationOfAllAnSIUInGroup(initiator, siuNameBriefChat);
		
		subgoal cif_siuSetupMore_siuSetup_pointAtHeldObject(initiator, recipient, groupWME);
	}

	// ## Hostile reaction to pointAtHeldObject - just keep studying it
	sequential behavior cif_siuSetupMore_siuSetup_pointAtHeldObject(String initiator, String recipient, GroupWME groupWME) {
		precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(recipient)) 
						(myCharacterWME.hasAttitude(eAttitudeType_hostile) == true)
						}
		specificity 2;
		
		// launch the GroupStudyObject SIU
		spawngoal testbed_LaunchSIU_groupStudyObject(initiator, groupWME);		
	}


	// ## Default reaction to pointAtHeldObject
	sequential behavior cif_siuSetupMore_siuSetup_pointAtHeldObject(String initiator, String recipient, GroupWME groupWME) {
		specificity 1;
		ReturnValueWME retValWME;
		CharactersWME othersInFormationCharactersWME;
		String requester;
		
		// choose the closest NPC in the group to request the object 
		mental_act { 			
         	othersInFormationCharactersWME = GroupUtil.cloneAndRemoveSelf(initiator, groupWME.getFormationCharactersWME());
			retValWME = new ReturnValueWME(); 
		}
		subgoal findClosestCharacterInCharactersWME(othersInFormationCharactersWME, retValWME);
		mental_act {
			requester = retValWME.getString();
		} 
		
		// launch the GroupConfused SIU, without requester
		spawngoal testbed_LaunchSIU_groupConfused(initiator, groupWME, requester);

		subgoal waitForRand(1500, 2000);
								
		spawngoal testbed_LaunchSIU_requestObject(requester, initiator);	// requester, requestee				
	}
	

	/**
	 * cif_adhoc_globalReaction() -- Point left or right
	 */	 	
	/* ADHOC RULE COMMENTED OUT, REPLACED BY PROPER CIF RULE
	sequential behavior cif_adhoc_globalReaction(SocialSignalWME signalWME, SocialInterpretation interpretation, String gestureName, String initiator, String recipient) {
		precondition {	(interpretation == socialInterpretationPointLeft ||
						 interpretation == socialInterpretationPointRight)
						
						// NPCs can now generate Point signals, that other NPCs react to 
						//(initiator.equals(playerName))
						
						playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName))
						recipientCharacterWME=(CharacterWME) (recipientCharacterWME.getName().equals(recipient)) 
                     	groupWME=(GroupWME) (groupWME.contains(recipientCharacterWME) && 
                     							groupWME.contains(playerCharacterWME))
                     }
		specificity 2;
		mental_act {
			log.info("##### CIF ADHOC GLOBAL REACTION for " +interpretation+ " from " +initiator+ " to " +recipient);
		}
		
		subgoal cif_siuSetup_pointLorR(signalWME, interpretation, initiator, recipient, gestureName);
	}
	// */					
	sequential behavior cif_siuSetup_pointLorR(SocialSignalWME signalWME, SocialInterpretation interpretation, 
													String initiator, String recipient, 
													String gestureName) {
		precondition {	playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName))
						recipientCharacterWME=(CharacterWME) (recipientCharacterWME.getName().equals(recipient)) 
                     	groupWME=(GroupWME) (groupWME.contains(recipientCharacterWME) && 
                     							groupWME.contains(playerCharacterWME))
                     }
		String pointTarget;
		mental_act { 
			log.info("##### CIF SIU SETUP for " +interpretation+ " from " +initiator+ " to " +recipient);
			if (initiator.equals(playerName)) pointTarget = "NPC20";	// fixme 
			else pointTarget = signalWME.getParam();
		}

		// kill off any high priority brief chats occurring in this group
		with (ignore_failure) subgoal siu_requestTerminationOfAllAnSIUInGroup(initiator, siuNameBriefChat);
											
		// launch the GroupBriefAttention SIU
		spawngoal testbed_LaunchSIU_groupBriefAttention(initiator, groupWME, eventParam_attention_point, pointTarget);

		subgoal testbed_waitForSIUToStart(initiator, siuNameGroupBriefAttention);

		// possibly do more
		with (ignore_failure) 
			subgoal cif_siuSetup_pointLorR_more(interpretation, gestureName, initiator, recipient, recipientCharacterWME, groupWME);
	}
	
	// React to question from player, if have already studied the object; 
	// otherwise pointing alone has no meaning
	sequential behavior cif_siuSetup_pointLorR_more(SocialInterpretation interpretation, String gestureName, String initiator, String recipient,
											CharacterWME recipientCharacterWME, GroupWME groupWME) {
		precondition {	(initiator.equals(playerName))	// check it's from player, not an NPC
						(EpisodicMemoryWME characterName==recipient recipientName==initiator episodeName==siuNameGroupStudyObject)
						}
											
		// launch the GroupReactToQuestion SIU
		spawngoal testbed_LaunchSIU_groupReactToQuestion(initiator, groupWME);

		// possibly do more
		with (ignore_failure) 
			subgoal cif_siuSetup_pointLorR_more2(interpretation, gestureName, initiator, recipient, recipientCharacterWME, groupWME);
	}
	
	// Non-hostile group, after the reaction to question, one person answers it
	sequential behavior cif_siuSetup_pointLorR_more2(SocialInterpretation interpretation, String gestureName, String initiator, String recipient,
											CharacterWME recipientCharacterWME, GroupWME groupWME) {
		precondition {	(recipientCharacterWME.hasAttitude(eAttitudeType_hostile) == false)
						}		
		int decisionDemonDuration;
		ReturnValueWME retValWME;
		CharactersWME othersInFormationCharactersWME;
		String answerer;
				
		subgoal waitForRand(1000, 2000);
		
		mental_act {
			String potentialAnswerer;
			
			// choose a random answerer, different than player
			answerer = "";
// DEMO HACK			
answerer = "NPC05";			
			while (answerer.equals("")) { 
          		potentialAnswerer = groupWME.getFormationCharactersWME().getRandom().getName();
          		if (potentialAnswerer.equals(playerName) == false) answerer = potentialAnswerer;
          	}
		} 
	
		// launch the GroupAnswerQuestion SIU
		spawngoal testbed_LaunchSIU_groupAnswerQuestion(initiator, answerer, groupWME);		
	}
	
	

	/**
	 * cif_adhoc_globalReaction() -- Emotional Appeal
	 *  first with ReactToAppeal, then AnswerQuestion 
	 */	 	
	 
	// first filter: hostile, and has already gotten past GroupStudyObject
	// Newly added: Emotional appeal must be directed at someone
	sequential behavior cif_adhoc_globalReaction(SocialSignalWME signalWME, SocialInterpretation interpretation, String gestureName, String initiator, String recipient) {
		precondition {	(interpretation == socialInterpretationEmotionalAppeal)
		
						// COMMENTING OUT PRIMARY RECIPIENT REQUIREMENT, until we robustify primary-recipient-ness
						//(signalWME.getPrimaryRecipient() != null)	// <---- directed at someone, not just at group
						//recipientCharacterWME=(CharacterWME) (recipientCharacterWME.getName().equals(signalWME.getPrimaryRecipient()))
						// reverting to group mode
						recipientCharacterWME=(CharacterWME) (recipientCharacterWME.getName().equals(recipient))
						 
						(initiator.equals(playerName))
						playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName))
                     	groupWME=(GroupWME) (groupWME.contains(recipientCharacterWME) && 
                     							groupWME.contains(playerCharacterWME))
						// hostile group                     							
						(recipientCharacterWME.hasAttitude(eAttitudeType_hostile) == true)
						// has previously studied the object 
						(EpisodicMemoryWME characterName==recipient recipientName==initiator episodeName==siuNameGroupStudyObject)
					}
		specificity 2;
		mental_act { 					 
			log.info("##### CIF ADHOC GLOBAL REACTION for " +interpretation+ " from " +initiator+ " to " +recipient);
		}
		
		subgoal cif_siuSetup_emotionalAppeal(signalWME, interpretation, initiator, recipient);
	}
								
	sequential behavior cif_siuSetup_emotionalAppeal(SocialSignalWME signalWME, SocialInterpretation interpretation, 
													String initiator, String recipient) {
		precondition {	recipientCharacterWME=(CharacterWME) (recipientCharacterWME.getName().equals(recipient))
						playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName))
                     	groupWME=(GroupWME) (groupWME.contains(recipientCharacterWME) && 
                     							groupWME.contains(playerCharacterWME))
                     	}
		mental_act { 		
			// COMMENTING OUT PRIMARY RECIPIENT REQUIREMENT, until we robustify primary-recipient-ness
			//recipient = signalWME.getPrimaryRecipient();
			
			log.info("##### CIF SIU SETUP for " +interpretation+ " from " +initiator+ " to " +recipient);
		}
		
		subgoal cif_siuSetupMore_emotionalAppeal(signalWME, initiator, recipient, groupWME);
	}		
		
	
	// if I am leader, and I already did ReactToAppeal, and haven't done AnswerQuestion, do it
	sequential behavior cif_siuSetupMore_emotionalAppeal(SocialSignalWME signalWME, String initiator, String recipient, GroupWME groupWME) {
		precondition {	recipientCharacterWME=(CharacterWME) (recipientCharacterWME.getName().equals(recipient)) 
						(recipientCharacterWME.hasAttitude(eAttitudeType_leader) == true)		
						(EpisodicMemoryWME characterName==recipient recipientName==initiator episodeName==siuNameGroupReactToAppeal)	
						!(EpisodicMemoryWME characterName==recipient recipientName==initiator episodeName==siuNameGroupAnswerQuestion)
						}	
		specificity 2;
		
		// kill off ReactToQuestion and ReactToAppeal, because it's spawning brief chats
		with (ignore_failure) subgoal siu_requestTerminationOfAllAnSIUInGroup(initiator, siuNameGroupReactToQuestion);
		with (ignore_failure) subgoal siu_requestTerminationOfAllAnSIUInGroup(initiator, siuNameGroupReactToAppeal);
		
		// kill off any high priority brief chats occurring in this group
		with (ignore_failure) subgoal siu_requestTerminationOfAllAnSIUInGroup(initiator, siuNameBriefChat);
		
		// launch the GroupAnswerQuestion SIU
		spawngoal testbed_LaunchSIU_groupAnswerQuestion(initiator, recipient, groupWME);		
	}

			
	// else if I am leader or sympathetic, and haven't done ReactToAppeal, do so
	sequential behavior cif_siuSetupMore_emotionalAppeal(SocialSignalWME signalWME, String initiator, String recipient, GroupWME groupWME) {
		precondition {	recipientCharacterWME=(CharacterWME) (recipientCharacterWME.getName().equals(recipient))
		
						// actually for this stage of the response, 
						// let's allow the appeal to be directed at anyone in the group, 
						// and each will respond appropriately within the SIU itself  
						//(recipientCharacterWME.hasAttitude(eAttitudeType_leader) == true ||		
						// recipientCharacterWME.hasAttitude(eAttitudeType_sympathetic) == true)
								
						!(EpisodicMemoryWME characterName==recipient recipientName==initiator episodeName==siuNameGroupReactToAppeal)	
                     }
		specificity 1;
		
		// kill off ReactToQuestion, because it's spawning brief chats
		with (ignore_failure) subgoal siu_requestTerminationOfAllAnSIUInGroup(initiator, siuNameGroupReactToQuestion);
		
		// kill off any high priority brief chats occurring in this group
		with (ignore_failure) subgoal siu_requestTerminationOfAllAnSIUInGroup(initiator, siuNameBriefChat);
		
		// launch the ReactToAppeal SIU
		spawngoal testbed_LaunchSIU_groupReactToAppeal(initiator, recipient, groupWME);
	}
	
	
	/*
	 * testbed_cif_possiblySpawnABriefChat
	 */
	atomic sequential behavior testbed_cif_possiblySpawnABriefChat(String myName, boolean bRemoveSmalltalkSpeaker, int chance, int performancePriority) {
		precondition {	(Staging.percentChance(chance))
						myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
                     	groupWME=(GroupWME) (groupWME.contains(myCharacterWME))
                     }
        CharactersWME othersInFormationCharactersWME;
		CharacterWME chatWith;                                          	
		String chatWithName;
                
		mental_act {
			// get list of fellow groupees, not including me
			othersInFormationCharactersWME = GroupUtil.cloneAndRemoveSelf(myName, groupWME.getFormationCharactersWME());
			
			// be sure the player is not in the list			
			othersInFormationCharactersWME.removeCharacter(playerName);
			
			// remove smalltalk speaker if requested
			if (bRemoveSmalltalkSpeaker && groupWME.getConversationWME() != null) {
				othersInFormationCharactersWME.removeCharacter(groupWME.getConversationWME().getSpeakerName());
			}
			
			// pick a random person in the remaining list
			chatWith = othersInFormationCharactersWME.getRandom();
			if (chatWith == null) chatWithName = "";
			else chatWithName = chatWith.getName();
			
			// don't chat if we're HOSTILE
			if (myCharacterWME.hasAttitude(eAttitudeType_hostile) == true)
				chatWithName = ""; 

			if (chatWithName.equals("") == false) {			
				log.info(myName+ " possibly spawning a brief chat with " +chatWithName);
			} 
		}	

		with (ignore_failure) subgoal testbed_cif_possiblySpawnABriefChat_main(myName, chatWithName, performancePriority);
	}
			
	atomic sequential behavior testbed_cif_possiblySpawnABriefChat_main(String myName, String chatWithName, int performancePriority) {
		precondition { (chatWithName.equals("") == false) }
		spawngoal testbed_LaunchSIU_briefChat(myName, chatWithName, performancePriority);
	}


	
	/**
	 * cif_startCutScene() -- with NPC15 to NPC20
	 */	 	
	sequential behavior cif_startCutScene() {
	   
	   with (ignore_failure) subgoal siu_requestTerminationAllOfSIUsWith("NPC01");
	   with (ignore_failure) subgoal siu_requestTerminationAllOfSIUsWith("NPC02");
	   with (ignore_failure) subgoal siu_requestTerminationAllOfSIUsWith("NPC03");
	   with (ignore_failure) subgoal siu_requestTerminationAllOfSIUsWith("NPC04");
	   with (ignore_failure) subgoal siu_requestTerminationAllOfSIUsWith("NPC05");
	   
		with (ignore_failure) subgoal siu_requestTerminationAllOfSIUsWith("NPC15");
		with (ignore_failure) subgoal siu_requestTerminationAllOfSIUsWith("NPC16");
		with (ignore_failure) subgoal siu_requestTerminationAllOfSIUsWith("NPC17");
		with (ignore_failure) subgoal siu_requestTerminationAllOfSIUsWith("NPC18");
		with (ignore_failure) subgoal siu_requestTerminationAllOfSIUsWith("NPC19");
		with (ignore_failure) subgoal siu_requestTerminationAllOfSIUsWith("NPC20");
		
		//Just to get some NPC's out of the way..
		with (ignore_failure) subgoal siu_requestTerminationAllOfSIUsWith("NPC13");
		with (ignore_failure) subgoal siu_requestTerminationAllOfSIUsWith("NPC14");
				
      	spawngoal testbed_daughterCutScene(nullSiu);		
	}
	

		
	
	// Approach
	sequential behavior cifSiuSetupLauncher(CiFSiuLaunchWME cifSiuLaunchWME) {
		precondition { (ruleNameApproachNomination.equals(cifSiuLaunchWME.getRuleName())) }
		specificity 2;
		
		SocialSignalWME signalWME;
		SocialInterpretation interpretation; 
		String initiator;
		String recipient;
		
		mental_act {						
			signalWME = cifSiuLaunchWME.getSignalWME();
			interpretation = signalWME.getFirstSocialInterpretation(); //cifSiuLaunchWME.getInterpretation(); // fixme: RHS of rule is not able to set the interpretation yet 
			initiator = cifSiuLaunchWME.getInitiator();
			recipient = cifSiuLaunchWME.getRecipient();
						
			__$thisEntity.deleteWME(cifSiuLaunchWME);
		}
		
		subgoal cif_siuSetup_approach(signalWME, interpretation, initiator, recipient);
	}
		
	// Greet
	sequential behavior cifSiuSetupLauncher(CiFSiuLaunchWME cifSiuLaunchWME) {
		precondition { (ruleNameGreetPlayerToGroupNomination.equals(cifSiuLaunchWME.getRuleName())) }
		specificity 2;
		
		SocialSignalWME signalWME;
		SocialInterpretation interpretation; 
		String initiator;
		String recipient;
		 		
		Gesture gesture;
		String gestureName;
		
		mental_act {						
			signalWME = cifSiuLaunchWME.getSignalWME();
			interpretation = signalWME.getFirstSocialInterpretation(); //cifSiuLaunchWME.getInterpretation(); // fixme: RHS of rule is not able to set the interpretation yet 
			initiator = cifSiuLaunchWME.getInitiator();
			recipient = cifSiuLaunchWME.getRecipient();

			// Get name of raw MiBA gesture
			gesture = cifSiuLaunchWME.getSignalWME().getSourceEventGestureType();
			if (gesture == null) gestureName = "";
			else gestureName = gesture.toString();
						
			__$thisEntity.deleteWME(cifSiuLaunchWME);
		}
		
		subgoal cif_siuSetup_greet(signalWME, interpretation, initiator, recipient, gestureName);
	}
		
	// Mirror
	sequential behavior cifSiuSetupLauncher(CiFSiuLaunchWME cifSiuLaunchWME) {
		precondition { (ruleNameMirrorNomination.equals(cifSiuLaunchWME.getRuleName())) }
		specificity 2;
		
		SocialSignalWME signalWME;
		SocialInterpretation interpretation; 
		String initiator;
		String recipient;
		 		
		Gesture gesture;
		String gestureName;
		
		mental_act {						
			signalWME = cifSiuLaunchWME.getSignalWME();
			interpretation = signalWME.getFirstSocialInterpretation(); //cifSiuLaunchWME.getInterpretation(); // fixme: RHS of rule is not able to set the interpretation yet 
			initiator = cifSiuLaunchWME.getInitiator();
			recipient = cifSiuLaunchWME.getRecipient();

			// Get name of raw MiBA gesture
			gesture = cifSiuLaunchWME.getSignalWME().getSourceEventGestureType();
			if (gesture == null) gestureName = "";
			else gestureName = gesture.toString();
						
			__$thisEntity.deleteWME(cifSiuLaunchWME);
		}
		
		subgoal cif_siuSetup_mirror(signalWME, interpretation, initiator, recipient, gestureName);
	}
	
	//Personal Space Violation
   sequential behavior cifSiuSetupLauncher(CiFSiuLaunchWME cifSiuLaunchWME) {
      precondition { (ruleNamePersonalSpaceViolationNomination.equals(cifSiuLaunchWME.getRuleName())) }
      specificity 2;
      
      SocialSignalWME signalWME;
      SocialInterpretation interpretation; 
      String initiator;
      String recipient;
      
      mental_act {                  
         signalWME = cifSiuLaunchWME.getSignalWME();
         interpretation = signalWME.getFirstSocialInterpretation(); //cifSiuLaunchWME.getInterpretation(); // fixme: RHS of rule is not able to set the interpretation yet 
         initiator = cifSiuLaunchWME.getInitiator();
         recipient = cifSiuLaunchWME.getRecipient();
                  
         __$thisEntity.deleteWME(cifSiuLaunchWME);
      }
      
      subgoal cif_siuSetup_personalSpace(signalWME, interpretation, initiator, recipient);
   }
   
   //Give Object to Requester
   sequential behavior cifSiuSetupLauncher(CiFSiuLaunchWME cifSiuLaunchWME) {
      precondition { (ruleNameGiveHeldObjectNomination.equals(cifSiuLaunchWME.getRuleName())) }
      specificity 2;
      
      SocialSignalWME signalWME;
      SocialInterpretation interpretation; 
      String initiator;
      String recipient;
            
      SiuWME requestObjectSiuWME;
      
      mental_act {                  
         signalWME = cifSiuLaunchWME.getSignalWME();
         interpretation = signalWME.getFirstSocialInterpretation(); //cifSiuLaunchWME.getInterpretation(); // fixme: RHS of rule is not able to set the interpretation yet 
         initiator = cifSiuLaunchWME.getInitiator();
         recipient = cifSiuLaunchWME.getRecipient();
         requestObjectSiuWME = cifSiuLaunchWME.getParamSiuWME();
                  
         __$thisEntity.deleteWME(cifSiuLaunchWME);
      }
      
      subgoal cif_siuSetup_giveHeldObject(signalWME, interpretation, initiator, recipient, requestObjectSiuWME);
   }
   
   //Offer Object to A Character not requesting it
   sequential behavior cifSiuSetupLauncher(CiFSiuLaunchWME cifSiuLaunchWME) {
      precondition { (ruleNameOfferHeldObjectNomination.equals(cifSiuLaunchWME.getRuleName())) }
      specificity 2;
      
      SocialSignalWME signalWME;
      SocialInterpretation interpretation; 
      String initiator;
      String recipient;
      
      mental_act {                  
         signalWME = cifSiuLaunchWME.getSignalWME();
         interpretation = signalWME.getFirstSocialInterpretation(); //cifSiuLaunchWME.getInterpretation(); // fixme: RHS of rule is not able to set the interpretation yet 
         initiator = cifSiuLaunchWME.getInitiator();
         recipient = cifSiuLaunchWME.getRecipient();
                  
         __$thisEntity.deleteWME(cifSiuLaunchWME);
      }
      
      subgoal cif_siuSetup_offerHeldObject(signalWME, interpretation, initiator, recipient);
   }
   
   //Show Object
   sequential behavior cifSiuSetupLauncher(CiFSiuLaunchWME cifSiuLaunchWME) {
      precondition { (ruleNameShowHeldObjectNomination.equals(cifSiuLaunchWME.getRuleName())) }
      specificity 2;
      
      SocialSignalWME signalWME;
      SocialInterpretation interpretation; 
      String initiator;
      String recipient;
      
      mental_act {                  
         signalWME = cifSiuLaunchWME.getSignalWME();
         interpretation = signalWME.getFirstSocialInterpretation(); //cifSiuLaunchWME.getInterpretation(); // fixme: RHS of rule is not able to set the interpretation yet 
         initiator = cifSiuLaunchWME.getInitiator();
         recipient = cifSiuLaunchWME.getRecipient();
                  
         __$thisEntity.deleteWME(cifSiuLaunchWME);
      }
      
      subgoal cif_siuSetup_showHeldObject(signalWME, interpretation, initiator, recipient);
   }
   
   //Request Object from someone holding it.
   sequential behavior cifSiuSetupLauncher(CiFSiuLaunchWME cifSiuLaunchWME) {
      precondition { (ruleNameRequestObjectFromCharacterHoldingItNomination.equals(cifSiuLaunchWME.getRuleName())) }
      specificity 2;
      
      SocialSignalWME signalWME;
      SocialInterpretation interpretation; 
      String initiator;
      String recipient;
      
      mental_act {                  
         signalWME = cifSiuLaunchWME.getSignalWME();
         interpretation = signalWME.getFirstSocialInterpretation(); //cifSiuLaunchWME.getInterpretation(); // fixme: RHS of rule is not able to set the interpretation yet 
         initiator = cifSiuLaunchWME.getInitiator();
         recipient = cifSiuLaunchWME.getRecipient();
                  
         __$thisEntity.deleteWME(cifSiuLaunchWME);
      }
      
      subgoal cif_siuSetup_requestObject(signalWME, interpretation, initiator, recipient);
   }
   
   //Point To Held Object
   sequential behavior cifSiuSetupLauncher(CiFSiuLaunchWME cifSiuLaunchWME) {
      precondition { (ruleNamePointToHeldObjectAtGroupNomination.equals(cifSiuLaunchWME.getRuleName())) }
      specificity 2;
      
      SocialSignalWME signalWME;
      SocialInterpretation interpretation; 
      String initiator;
      String recipient;
      
      mental_act {                  
         signalWME = cifSiuLaunchWME.getSignalWME();
         interpretation = signalWME.getFirstSocialInterpretation(); //cifSiuLaunchWME.getInterpretation(); // fixme: RHS of rule is not able to set the interpretation yet 
         initiator = cifSiuLaunchWME.getInitiator();
         recipient = cifSiuLaunchWME.getRecipient();
                  
         __$thisEntity.deleteWME(cifSiuLaunchWME);
      }
      
      subgoal cif_siuSetup_pointAtHeldObject(signalWME, interpretation, initiator, recipient);
   }
   
   //Point Left or Right
   sequential behavior cifSiuSetupLauncher(CiFSiuLaunchWME cifSiuLaunchWME) {
      precondition { (ruleNamePointLeftOrRightNomination.equals(cifSiuLaunchWME.getRuleName())) }
      specificity 2;
      
      SocialSignalWME signalWME;
      SocialInterpretation interpretation; 
      String initiator;
      String recipient;
      
      Gesture gesture;
      String gestureName;
      
      mental_act {                  
         signalWME = cifSiuLaunchWME.getSignalWME();
         interpretation = signalWME.getFirstSocialInterpretation(); //cifSiuLaunchWME.getInterpretation(); // fixme: RHS of rule is not able to set the interpretation yet 
         initiator = cifSiuLaunchWME.getInitiator();
         recipient = cifSiuLaunchWME.getRecipient();
         
         // Get name of raw MiBA gesture
         gesture = cifSiuLaunchWME.getSignalWME().getSourceEventGestureType();
         if (gesture == null) gestureName = "";
         else gestureName = gesture.toString();
                  
         __$thisEntity.deleteWME(cifSiuLaunchWME);
      }
      
      subgoal cif_siuSetup_pointLorR(signalWME, interpretation, initiator, recipient, gestureName);
   }
   
   
   

   
/*
	
	// GroupStudyObject
	sequential behavior cifSiuSetupLauncher(CiFSiuLaunchWME cifSiuLaunchWME) {
		precondition { (siuNameGroupStudyObject.equals(cifSiuLaunchWME.getSiuName()))
			groupWME=(GroupWME)(groupWME.contains(siu.getInitiator())) }
		specificity 2;
		String myName;
		mental_act {
			myName = siu.getInitiator().getName();
			__$thisEntity.deleteWME(cifSiuLaunchWME);
		}
		with (ignore_failure) subgoal testbed_LaunchSIU_groupStudyObject(myName, groupWME);
	}
	
	// GiveObjectToPlayer
	sequential behavior cifSiuSetupLauncher(CiFSiuLaunchWME cifSiuLaunchWME) {
		precondition { (siuNameGiveObjectToPlayer.equals(cifSiuLaunchWME.getSiuName())) }
		specificity 2;
		String initiator;
		String objectHolder;
		mental_act {
			initiator = siu.getInitiator().getName();
			objectHolder = siu.getPrimaryResponder().getName();
			__$thisEntity.deleteWME(cifSiuLaunchWME);
		}
		
		with (ignore_failure) subgoal testbed_LaunchSIU_giveObjectToPlayer(objectHolder, initiator);
	}
*/	

    /**
     * Calls DetermineVolition when either a VolitionEventWME is registered in
     * working memory or when volition has been ran within a timeout (details
     * and timeout are in LastVolitionExecutionWME.java).
     * 
     * This is the interface behavior to the rest of the agent for determining volition. 
     */
    sequential behavior CiFVolitionDaemon() {
    	with(success_test {(LastVolitionExecutionWME readyToRunVolitionRules==true)}) wait;
    	subgoal DetermineVolition();
    }
    
    sequential behavior CiFVolitionDaemonInit() {
    	mental_act {
    		__$thisEntity.addWME(new LastVolitionExecutionWME(System.currentTimeMillis()));
    	}
    }

    /**
     * The main function for determining volition. It runs the ruleset,
     * aggregates the VolitionWMEs into candidate SiuWMEs, flags WMEs with
     * scores above a threshold as REQUESTED_EXECUTION, and cleans up the
     * VoltionEventWMEs and LastVoltionExecutionWME.
     */
    sequential behavior DetermineVolition() {
    	LastVolitionExecutionWME lastExecution;
    	
    	mental_act {    	          	
    		__$thisEntity.runRules(); 
    	}
    	
    	//subgoal AggregateVolitionScores();
    	//subgoal FlagSuccessfulSIUCandidatesForExecution();
    	mental_act {
    		log.info("Clearing VolitionEventWMEs and LastVolitionExecutionWME timer.");
    		__$thisEntity.deleteAllWMEClass("VolitionWME");
    		__$thisEntity.deleteAllWMEClass("VolitionEventWME");
    		__$thisEntity.deleteAllWMEClass("LastVolitionExecutionWME");
    		__$thisEntity.addWME(new LastVolitionExecutionWME(System.currentTimeMillis()));

    		// fixme: After running rules, delete all flag wme's used to support rule specificity
         	__$thisEntity.deleteAllWMEClass("CiFRuleUtilWME");
    	}
    }
    
    /**
     * Takes many VoltionWMEs and sums their scores into SiuWME candidates 
     * when parameters are identical.
     */
    sequential behavior AggregateVolitionScores() {
    	List volWMEs;
    	mental_act {
    		log.info("Aggregating VolitionWMEs");
    		VolitionWME.resetVolitionCandidateMap();
    		
    		//A version with generics.
    		//List<VolitionWME> volWMEs = (List<VolitionWME>)__$thisEntity.lookUpWME("VolitionWME");
    		/*for(VolitionWME vol: volWMEs) {
				vol.addOrUpdateScore();
			}*/

    		volWMEs = __$thisEntity.lookupWME("VolitionWME");
    		for(int i = 0; i < volWMEs.size(); i++) {
    			((VolitionWME) volWMEs.get(i)).addOrUpdateScore();
    		}
    	}
    }
    
    /**
     * Looks at the scores of SiuWME candidates and changes their execution
     * state to REQUESTED_EXECUTION.
     */
    sequential behavior FlagSuccessfulSIUCandidatesForExecution() {
    	mental_act {
    		//FIXME: Git rid fo the magic threshold value.
    		log.info("Flagging SiuWMEs for execution.");
    		VolitionWME.flagCandidatesForExecution(5);
    	}
    }
    
    
    /**
     * Fire an event to start volition determination.
     */
    sequential behavior TriggerVolitionDetermination() {
    	mental_act {         	    		
    		__$thisEntity.addWME(new VolitionEventWME());
    	}
    }
    
  
    
	/**
	 * The external interface for launching pending SIUs.
	 */
	parallel behavior CiFSiuLaunchListenerInit() {
		with (persistent) subgoal CiFListenForRequestedSIULaunches();
		//with (persistent) subgoal SIUSpawnPoint();
	}
	
	sequential behavior CiFListenForRequestedSIULaunches() {
		CiFSiuLaunchWME cifSiuLaunchWME;
		//ParallelBehaviorWME spawnPointBehWME;

		with (success_test {
				cifSiuLaunchWME=(CiFSiuLaunchWME)
				//spawnPointBehWME=(ParallelBehaviorWME signature=="SIUSpawnPoint()")
			} ) wait;
		
		mental_act { log.info("Launching SIU requested from rules: " + cifSiuLaunchWME.getRuleName()); }
		
		with (ignore_failure) spawngoal CiFSpawnSIU(cifSiuLaunchWME);		
		//with (priority 2, effect_only) spawngoal testbed_SIUExpectationWrapper(cifSiuLaunchWME) at spawnPointBehWME;
	}
	
	/*
	parallel behavior SIUSpawnPoint() {
		with (persistent, priority 1) wait;
	}
	*/
	
	
	/**
	 * The wrapper around the launcher that becomes a central point for sending
	 * SIU expectation signals to MIBA.
	 */
	/*
	sequential behavior testbed_SIUExpectationWrapper(SiuWME siu) {	
		with (ignore_failure) subgoal CiFSpawnSIU(siu);		
	}
	*/
	
	
	/**
	 * CiFSpawnSIU()
	 */
	sequential behavior CiFSpawnSIU(CiFSiuLaunchWME cifSiuLaunchWME) {
	
		// fixme
		//subgoal OfferExpectationsForSIU(siu);
		
		with (ignore_failure) subgoal cifSiuSetupLauncher(cifSiuLaunchWME);
		//with (ignore_failure) subgoal testbed_LaunchSIU_byName(siu);
		
		// fixme
		//subgoal ClearExpectationsForSIU(siu);
	}
	
	
    
	/**
	 * testbed_coachManager()
	 */	 	
	parallel behavior coachMgr() {
		with (priority_modifier 1) mental_act { log.info("** coachMgr started"); }
		
		with (ignore_failure) subgoal coach_initialPrompt(); 
		with (ignore_failure) subgoal coach_betweenGroup1And2(); 
		with (ignore_failure) subgoal coach_group2EmotionalAppeal(); 
	}


	// --------------------------------------------
	// --------------------------------------------
	// INITIAL PROMPT 
		
	parallel behavior coach_initialPrompt() {
		number_needed_for_success 1;
		subgoal coach_initialPrompt_speak_test();
		subgoal coach_initialPrompt_cancel_test();
	} 

	sequential behavior coach_initialPrompt_speak_test() {
		subgoal waitFor(15000);
		with (persistent when_fails) subgoal coach_initialPrompt_speak_pollTest();

		// ## SPEAK ##		
		subgoal speakCoachDialogue(oiDialog_mentor1);
	}

	sequential behavior coach_initialPrompt_speak_pollTest() {
		precondition {	playerPhysicalWME=(PhysicalAgentWME)
                     	(playerPhysicalWME.getId().equals(playerName))
						targetPhysicalWME=(PhysicalAgentWME)
                     	(targetPhysicalWME.getId().equals("NPC01"))
                     	(Staging.getXZDistanceBetweenPoints(playerPhysicalWME.getLocation(), 
                     											targetPhysicalWME.getLocation()) 
                     										> cCloseAwarenessDistance)
                     	}
		specificity 2;
		mental_act { log.info("coach_initialPrompt_speak_pollTest succeeded"); }
		succeed_step;
	}
	
	sequential behavior coach_initialPrompt_speak_pollTest() {
		specificity 1;
		subgoal waitFor(1000);
		mental_act { log.info("coach_initialPrompt_speak_pollTest failed"); }
		fail_step;
	}
	
	sequential behavior coach_initialPrompt_cancel_test() {
		with (persistent when_fails) subgoal coach_initialPrompt_cancel_pollTest();
	}
	
	sequential behavior coach_initialPrompt_cancel_pollTest() {
		precondition { (EpisodicMemoryWME episodeName==siuNameApproach) }
		specificity 2;
		mental_act { log.info("coach_initialPrompt_cancel_pollTest succeeded"); }
		succeed_step;
	}
	
	sequential behavior coach_initialPrompt_cancel_pollTest() {
		specificity 1;
		subgoal waitFor(1000);
		mental_act { log.info("coach_initialPrompt_cancel_pollTest failed"); }
		fail_step;
	}
	
	
	// --------------------------------------------
	// --------------------------------------------
	// BETWEEN GROUP 1 AND 2
		
	sequential behavior coach_betweenGroup1And2() {

		with (success_test { (EpisodicMemoryWME episodeName==siuNameGroupMirror) } ) wait;
		with (success_test { (EpisodicMemoryWME episodeName==siuNameGiveObjectToPlayer) } ) wait;
		with (success_test { charWME=(CharacterWME) (charWME.getName().equals(playerName) && 
														charWME.getObjectHeld().equals("") == false) } ) wait;
		subgoal waitFor(6000);

		subgoal coach_betweenGroup1And2_which();
	}	
	
	sequential behavior coach_betweenGroup1And2_which() {
		specificity 2;
		precondition { (EpisodicMemoryWME episodeName==event_coach episodeParam==eventParam_coach_mirroredGreeting) }		
		// ## SPEAK ##		
		subgoal speakCoachDialogue(oiDialog_mentor2a);
	}
	
	sequential behavior coach_betweenGroup1And2_which() {
		specificity 1;
		// ## SPEAK ##		
		subgoal speakCoachDialogue(oiDialog_mentor2b);
	}
	


	// --------------------------------------------
	// --------------------------------------------
	// GROUP 2 EMOTIONAL APPEAL 
		
	sequential behavior coach_group2EmotionalAppeal() {
		with (success_test { (EpisodicMemoryWME characterName=="NPC07" episodeName==siuNameGroupReactToQuestion) } ) wait;
		subgoal coach_group2EmotionalAppeal_par();
	}

	parallel behavior coach_group2EmotionalAppeal_par() {
		number_needed_for_success 1;
		subgoal coach_group2EmotionalAppeal_speak_test();
		subgoal coach_group2EmotionalAppeal_cancel_test();
	}

	sequential behavior coach_group2EmotionalAppeal_speak_test() {
		subgoal waitFor(8000);
		
		// ## SPEAK ##		
		subgoal speakCoachDialogue(oiDialog_mentor3);
	}

	sequential behavior coach_group2EmotionalAppeal_cancel_test() {
		with (success_test { (EpisodicMemoryWME episodeName==siuNameGroupReactToAppeal) } ) wait;
	}

	
    /**
     *  processContext
     */
	
	atomic sequential behavior processContext(SocialSignalWME socialSignalWME) {
		Iterator iterator;
		mental_act { iterator = socialSignalWME.getSignal().iterator(); }
		with (persistent when_succeeds) subgoal processContext_loop(iterator, socialSignalWME);
	}
	
	// loop through all UNCHOSEN (not yet reacted-to) interpretations 
	atomic sequential behavior processContext_loop(Iterator iterator, SocialSignalWME socialSignalWME) {
		precondition { (iterator.hasNext()) }
		SocialInterpretation interpretation;
		mental_act { interpretation = iterator.next(); }
		with (ignore_failure) subgoal processContext_loop_test(interpretation, socialSignalWME);
	}
		
	atomic sequential behavior processContext_loop_test(SocialInterpretation interpretation, SocialSignalWME socialSignalWME) {
		precondition { (interpretation != socialSignalWME.getChosenInterpretation()) }	
		with (ignore_failure) subgoal processContext_test(interpretation, socialSignalWME);			
	}
	
	// individual SIUs can override this with higher specificity variations 
	atomic sequential behavior processContext_test(SocialInterpretation interpretation, SocialSignalWME socialSignalWME) {
		precondition { (interpretation == socialInterpretationDismiss ||
						interpretation == socialUnkindRefusal ||
						interpretation == socialUnkindRefusalHighlyAgitated) }
		specificity 1;
		String character;
		mental_act { 
			character = socialSignalWME.getSender();
			log.info(interpretation+ " terminating active SIUs (if any) for " +character);
		}						
		
		//FIXME
		//subgoal terminateAllSIUsFor(character);						
	}
	
		
	

	/**
	 * testbed_faceManager()
	 * One of these are running per character
	 */	 	
	parallel behavior faceMgr(String myName) {
		with (priority_modifier 1) mental_act { log.info("** " +myName+ " faceMgr started"); }
		with (persistent) subgoal testbed_faceMgr(myName); 
	}
	
	sequential behavior testbed_faceMgr(String myName) {
		precondition { characterWME=(CharacterWME) (characterWME.getName().equals(myName)) }

		//ReturnValueWME retValWME;
		String faceAnim;

		//mental_act { retValWME = new ReturnValueWME(); }			
		//subgoal testbed_getFaceAnim(myName, retValWME);
		//mental_act { faceAnim = retValWME.getString(); }
		
		mental_act {
			boolean bPurposefulExpression;
			boolean bHostile;
			
			faceAnim = "";

			bHostile = characterWME.hasAttitude(eAttitudeType_hostile);

			bPurposefulExpression = (characterWME.getFacialExpression().equals("") == false);
			if (bPurposefulExpression && characterWME.isFacialExpressionExpired()) {
				characterWME.setFacialExpression("", 0);
				bPurposefulExpression = false;
			}
			
			// only change the facial expression if we're not in the middle of a purposeful one
			if (!bPurposefulExpression) {
				faceAnim = characterWME.getFacialExpressionTendency();
				
				//if (Staging.percentChance(10)) faceAnim = animationFaceIdle;
				  
				if (!bHostile && Staging.percentChance(50)) {  
					if (Staging.percentChance(10)) faceAnim = animationFaceUnsure;
					else if (Staging.percentChance(10)) faceAnim = animationFaceAnxious;
					else if (Staging.percentChance(10)) faceAnim = animationFaceAnxious2;
					else if (Staging.percentChance(5)) faceAnim = animationFaceNervous;
					else if (Staging.percentChance(5)) faceAnim = animationFaceNervous2;
					else if (Staging.percentChance(5)) faceAnim = animationFaceNervous3;
					else if (Staging.percentChance(30)) faceAnim = animationFaceBigSmile;  
					else if (Staging.percentChance(10)) faceAnim = animationFaceSmile;  
					else if (Staging.percentChance(10)) faceAnim = animationFaceSmile2;  
					else if (Staging.percentChance(10)) faceAnim = animationFaceVeryAnnoyed;
					else if (Staging.percentChance(10)) faceAnim = animationFaceStony;
				}
			}			
		}
		
		with (ignore_failure) subgoal testbed_performFacialExpression(myName, faceAnim);
		subgoal waitForRand(750, 3000); 
	}


 	/**
	 * testbed_performFacialExpression()
	 */	 	
	sequential behavior testbed_performFacialExpression(String myName, String faceAnim) {
		precondition { (faceAnim.equals("") == false) }
		// fixme -- an 0.2f seems necessary, ideally it would be 0
		subgoal performAnimation_portion(myName, myName, faceAnim, cAnimDefaultStartTime, 0.2f);	
	}


 	/**
	 * testbed_setFacialExpression()
	 */	 	
	sequential behavior testbed_setFacialExpression(String myName, String faceAnim) {
		precondition { characterWME=(CharacterWME) (characterWME.getName().equals(myName)) }
		mental_act { characterWME.setFacialExpression(faceAnim, Staging.randRange(2000, 5000)); }
		with (ignore_failure) subgoal testbed_performFacialExpression(myName, faceAnim);
	}


 	/**
	 * testbed_clearFacialExpression()
	 */	 	
	sequential behavior testbed_clearFacialExpression(String myName) {
		precondition { characterWME=(CharacterWME) (characterWME.getName().equals(myName)) }
		mental_act { characterWME.setFacialExpression("", 0); }
	}

		
	/**
	 * faceMgr_setup()
	 * create faceWMEs per character towards each other character
	 * spawn a faceMgr per character
	 */	 	
	sequential behavior faceMgr_setup() {		
		with (ignore_failure) subgoal faceMgr_setup_main();
	}
	
	sequential behavior faceMgr_setup_main() {
		precondition { charactersWME=(CharactersWME) } 
		Iterator iterator;
		mental_act { iterator = charactersWME.iterator(); }
		with (persistent when_succeeds) subgoal faceMgr_setup_loop(iterator);
	}
			
	sequential behavior faceMgr_setup_loop(Iterator iterator) {
		precondition { (iterator.hasNext()) }						
		CharacterWME characterWME;
		String characterName;
		mental_act { 
			characterWME = iterator.next();
			characterName = characterWME.getName();
		}
		
		with (ignore_failure) subgoal faceMgr_setup_launch(characterName);
	}
	
	sequential behavior faceMgr_setup_launch(String characterName) {
		precondition { (characterName.equals(playerName) == false) }
		//mental_act { log.info("** " +characterName+ " setting up an FaceMgr"); }
		spawngoal faceMgr(characterName);		
	}
	

	/**
	 * addCharacterToFormation()
	 */
	sequential behavior addCharacterToFormation(CharacterWME characterWME, GroupWME groupWME, boolean bAdd) {
		precondition { (bAdd == true) }
		mental_act {
			log.info("## " +characterWME.getName()+ " getting added to group"); 

			// this automatically removes character from approaching list and updates the formation locations
			// based on the number of characters. It will also create the formation if it doesn't exist
			groupWME.addFormationCharacter(characterWME);
		}
		
		with (ignore_failure) subgoal determinePossibleGroupLeader(characterWME, groupWME);
	}		


	/**
	 * getOtherCharactersWME()
	 * returnCharactersWME will get reset and filled in
	 */
	sequential behavior getOtherCharactersWME(String myName, CharactersWME returnCharactersWME) {
		precondition { origCharactersWME=(CharactersWME) }
		subgoal cloneCharactersWMESenseAndRemoveSelf(myName, origCharactersWME, returnCharactersWME);
		
		// also should NOT include player by default
		mental_act { returnCharactersWME.removeCharacter(playerName); }	
	}
	
	/**
	 * getFriendsCharactersWME()
	 * returnCharactersWME will get reset and filled in
	 */
	sequential behavior getFriendsCharactersWME(String myName, CharactersWME returnCharactersWME) {
		precondition { characterWME=(CharacterWME) (characterWME.getName().equals(myName)) }
		CharactersWME friendsCharactersWME;
		
		mental_act { friendsCharactersWME = characterWME.getFriendsCharactersWME(); }		
		subgoal cloneCharactersWMESenseAndRemoveSelf(myName, friendsCharactersWME, returnCharactersWME);
		
		// also should NOT include player by default
		mental_act { returnCharactersWME.removeCharacter(playerName); }	
	}
	
	/**
	 * cloneCharactersWMESenseAndRemoveSelf()
	 * return in a cloned list in returnCharactersWME, 
	 * with self removed, and all character positions sensed
	 
	 * FIXME: because the PhysicalAgentWME sensor actually creates PhysicalAgentWMEs for ALL agents,
	 *  we could just sense any PhysicalAgentWME, and then write a java method to get a list to them all,
	 *  and iterate on that list, instead of via these looping behaviors
	  
	 */
	sequential behavior cloneCharactersWMESenseAndRemoveSelf(String myName,
														CharactersWME origCharactersWME,
														CharactersWME returnCharactersWME) {
		precondition {	myPhysicalWME=(PhysicalAgentWME)
                     	(myPhysicalWME.getId().equals(myName)) 
                     }
                     
		// clear the return value list
		mental_act { returnCharactersWME.clear(); }
		
		// fill in the list 
		with (ignore_failure) subgoal cloneCharactersWMESenseAndRemoveSelf_main(myName, origCharactersWME, returnCharactersWME);
	}
	
	sequential behavior cloneCharactersWMESenseAndRemoveSelf_main(String myName, CharactersWME origCharactersWME, CharactersWME returnCharactersWME) {
		Iterator iterator;
		mental_act { iterator = origCharactersWME.iterator(); }
		with (persistent when_succeeds) subgoal cloneCharactersWMESenseAndRemoveSelf_loop(myName, iterator, returnCharactersWME);
	}
			
	sequential behavior cloneCharactersWMESenseAndRemoveSelf_loop(String myName, Iterator iterator, CharactersWME returnCharactersWME) {
		precondition { (iterator.hasNext()) }						
		CharacterWME origCharacterWME;
		mental_act { origCharacterWME = iterator.next(); }
		with (ignore_failure) subgoal cloneCharactersWMESenseAndRemoveSelf_sense(myName, returnCharactersWME, origCharacterWME);
	}
	
	sequential behavior cloneCharactersWMESenseAndRemoveSelf_sense(String myName, CharactersWME returnCharactersWME, CharacterWME origCharacterWME) {
		precondition { 	(origCharacterWME.getName().equals(myName) == false) 
      					characterPhysicalWME = (PhysicalAgentWME)
                     	(characterPhysicalWME.getId().equals(origCharacterWME.getName()))
						} 
		CharacterWME otherCharacterWME;
		mental_act {
			otherCharacterWME = new CharacterWME(origCharacterWME.getName(), origCharacterWME.getBNpc());
			otherCharacterWME.setTempLocation(characterPhysicalWME.getLocation());
			otherCharacterWME.setTempOrientation(characterPhysicalWME.getOrientation());
			//log.info(myName+ " creating otherCharacterWME for " +origCharacterWME.getName()+ ", " +otherCharacterWME.getTempOrientation()+ " degrees, " +otherCharacterWME.getTempLocation());
						
			// add the character to the list
			returnCharactersWME.addCharacter(otherCharacterWME);
		}
	}
	

	/**
	 * findGroupOthersAreIn
	 */
	sequential behavior findAGroupAnyOthersAreIn(ReturnValueWME retVal, CharactersWME otherCharactersWME) {
		precondition {	groupWME=(GroupWME)
						(groupWME.containsAny(otherCharactersWME))
						}
		specificity 2;
		mental_act { retVal.setGroupWME(groupWME); }
	}
	
	// If I can't find anyone, move on
	sequential behavior findAGroupAnyOthersAreIn(ReturnValueWME retVal, CharactersWME otherCharactersWME) {
		specificity 1;
		succeed_step;
	}

	
	/**
	 * removeFormationCharacter
	 * removes a character from the formation, 
	 * and deletes the groupWME if no one is left in the group
	 */
	sequential behavior removeFormationCharacter(CharacterWME characterWME, GroupWME groupWME) {
		mental_act {
			groupWME.removeFormationCharacter(characterWME);
			
			if (groupWME.isGroupEmpty()) {
				log.info("DELETING now empty groupWME");
				__$thisEntity.deleteWME(groupWME);                               
			}
		}
	}
	
   /**
    * exclusivelyJoinGroup()
    */      
	sequential behavior exclusivelyJoinGroup(CharacterWME characterWME, GroupWME groupWME) {
	
		// first remove self from any existing groups
		with (ignore_failure) subgoal removeFromAnyGroupIn(characterWME);
		
		mental_act {
			groupWME.addApproachingCharacter(characterWME);
		}
	}
        
   /**
    * removeFromAnyGroupIn()
    */      
	sequential behavior removeFromAnyGroupIn(CharacterWME characterWME) {
		precondition { groupWME=(GroupWME) (groupWME.contains(characterWME)) }
		mental_act {
			groupWME.removeCharacter(characterWME);

			if (groupWME.isGroupEmpty()) {
				log.info("DELETING now empty groupWME");
				__$thisEntity.deleteWME(groupWME);                               
			}
		}
		
		// recursively remove from any other group in
		with (ignore_failure) subgoal removeFromAnyGroupIn(characterWME);
	}
    

   /**
    * determinePossibleGroupLeader()
    * Cache the value of the leader of the group in GroupWME
    */      
	sequential behavior determinePossibleGroupLeader(CharacterWME characterWME, GroupWME groupWME) {
		precondition {	leaderCharacterWME=(CharacterWME) 
						(leaderCharacterWME.hasAttitude(eAttitudeType_leader) &&
							groupWME.formationContains(leaderCharacterWME))						
						 }
		mental_act {
			log.info(characterWME.getName()+ " determined group leader to be " +leaderCharacterWME.getName()); 
			groupWME.setLeaderCharacter(leaderCharacterWME); 
		}
	}   
		
// ########## OLD WRAP-ON CODE
/*
	
	// ******************************
	// MAIN ANIMATIONS
	
	//FRUSTRATED  - SIUGiveObject -  Main Animations
	sequential behavior attitudeMain(String performanceEnum, String initiator, String responder){
	   specificity 2;
	   precondition {    attitudeWME=(AttitudeControlWME)
	     (attitudeWME.getName().equals(initiator))
	     (attitudeWME.getType().equals(eAttitudeType_frustration))
	     (performanceEnum.equals(eAttitudePerform_giveObject))
	     }
	
	      subgoal headTrackOff(initiator);
	      subgoal performAnimation(initiator, responder, animationPullOutObject);     // NPC initiator takes out object
	      subgoal headTrack(initiator, responder);
	      subgoal performAnimation(initiator, responder, animationAngryArguingID1);       // NPC initiator proffers object to responder
	
	}
	
	//COMPLIANT  -- SIUGiveObject - Main Animations
	sequential behavior attitudeMain(String performanceEnum, String initiator, String responder){
	   specificity 2;
	   precondition {    attitudeWME=(AttitudeControlWME)
	   (attitudeWME.getName().equals(initiator))
	   (attitudeWME.getType().equals(eAttitudeType_compliance))
	    (performanceEnum.equals(eAttitudePerform_giveObject))
	   } 
	
	      subgoal headTrackOff(initiator);
	      subgoal performAnimation(initiator, responder, animationPullOutObject);     // NPC initiator takes out object
	      subgoal headTrack(initiator, responder);
	      subgoal performAnimation(initiator, responder, animationHandCardTwoHanded);       // NPC initiator proffers object to responder
	}
	
	//NO ATTITUDE -- SIUGiveObject -- Main Animations
	sequential behavior attitudeMain(String performanceEnum, String initiator, String responder){
	   specificity 1;
	   precondition{
	      (performanceEnum.equals(eAttitudePerform_giveObject))
	   }
	   //mental_act { log.info("##PRE " + initiator + " does not have any attitudes, OR the attitude they have has not been authored for the preinsertion step of SIU" + performanceEnum); }
	   subgoal headTrackOff(initiator);
	   subgoal performAnimation(initiator, responder, animationPullOutObject);     // NPC initiator takes out object
	   subgoal headTrack(initiator, responder);
	   subgoal performAnimation(initiator, responder, animationOfferObject);       // NPC initiator proffers object to responder
	
	}
	
	//NO ATTITUDE -- point - Main Animations
	sequential behavior attitudeMain(String performanceEnum, String initiator, String responder){
	   specificity 1;
	   precondition{
	      (performanceEnum.equals(eAttitudePerform_point))
	   }
	   //mental_act { log.info("##PRE " + initiator + " does not have any attitudes, OR the attitude they have has not been authored for the preinsertion step of SIU" + performanceEnum); }
	
	   subgoal performAnimation(initiator, responder, animationPointToLeft);       // NPC will point off to the side.
	
	}
	
	// ------------ GroupMaintenance Main Animations -------------- //
	
	// ~~~ Speaking ~~~
	
	//JOVIAL -- GroupMaintenance -- Speak
	sequential behavior attitudeMain(String performanceEnum, String initiator, String responder){
		specificity 2;
		precondition { 	attitudeWME=(AttitudeControlWME)
						(attitudeWME.getName().equals(initiator))
						(attitudeWME.getType().equals(eAttitudeType_jovial))
						(performanceEnum.equals(eAttitudePerform_speak)) } 
		String anim;
		float animStartTime;
	    float animEndTime;
	    
		mental_act {
			if (Staging.percentChance(50)) anim = animationTalkingNeutral1;
	    	else if (Staging.percentChance(50)) anim = animationTalkingNeutral2;
	    	else anim = animationTalkingNeutral3;
	    	animStartTime = cAnimDefaultStartTime;
	    	animEndTime = cAnimDefaultEndTime;
	    	
	    	//log.info("ATTITUDE: JOVIAL (Speak) " + initiator + ": " + anim);
		}
		
		// SMILE! :D (in the jovial/unjovial list option.)
	   //Should I turn it on here too/instead? Doesn't seem to stick long enough
	   subgoal performAnimation_portion(initiator, initiator, anim,
										animStartTime, animEndTime);
		//subgoal clearFace(initiator);
	}
	
	//SERIOUS -- GroupMaintenance -- Speak
	sequential behavior attitudeMain(String performanceEnum, String initiator, String responder){
		specificity 2;
		precondition { 	attitudeWME=(AttitudeControlWME)
						(attitudeWME.getName().equals(initiator))
						(attitudeWME.getType().equals(eAttitudeType_serious))
						(performanceEnum.equals(eAttitudePerform_speak)) } 
		String anim;
		float animStartTime;
	    float animEndTime;
	    
		mental_act {
			if (Staging.percentChance(50)) anim = animationAngryArguing4;
	    	else if (Staging.percentChance(50)) anim = animationAngryArguing5;
	    	else anim = animationTalkingAnnoyed3;
	    	animStartTime = cAnimDefaultStartTime;
	    	animEndTime = cAnimDefaultEndTime;
	    	
	    	//log.info("ATTITUDE: SERIOUS (Speak) " + initiator + ": " + anim);
		}
		
	   subgoal performAnimation_portion(initiator, initiator, anim,
	   									animStartTime, animEndTime);
	}
	
	//NO ATTITUDE / NEUTRAL -- GroupMaintenance -- Speak
	sequential behavior attitudeMain(String performanceEnum, String initiator, String responder){
	   specificity 1;
	   precondition{
	      (performanceEnum.equals(eAttitudePerform_speak))
	   }
	    String anim;
	    float animStartTime;
	    float animEndTime;
	            
	    mental_act {
	    	if (Staging.percentChance(50)) anim = animationTalkingNeutral1;
	    	else if (Staging.percentChance(50)) anim = animationTalkingNeutral2;
	    	else anim = animationTalkingNeutral3;
	    	animStartTime = cAnimDefaultStartTime;
	    	animEndTime = cAnimDefaultEndTime;
	    	
	    	//log.info("ATTITUDE: NEUTRAL (Speak) " + initiator + ": " + anim);
	   }
	   
	   subgoal performAnimation_portion(initiator, initiator, anim,
										animStartTime, animEndTime);
	
	}
	
	//CURIOUS -- GroupMaintenance -- Speak
	//WARY/NERVOUS -- GroupMaintenance -- Speak
	sequential behavior attitudeMain(String performanceEnum, String initiator, String responder){
		specificity 2;
		precondition { 	attitudeWME=(AttitudeControlWME)
						(attitudeWME.getName().equals(initiator))
						(attitudeWME.getType().equals(eAttitudeType_nervous))
						(performanceEnum.equals(eAttitudePerform_speak)) } 
		String anim;
		float animStartTime;
	    float animEndTime;
	    
		mental_act {
			if (Staging.percentChance(40)) anim = animationTalkingAnnoyed2;
	    	else if (Staging.percentChance(40)) anim = animationTalkingAnnoyed3;
	    	else anim = animationTurnBackRightAndGesture0;
	    	animStartTime = cAnimDefaultStartTime;
	    	animEndTime = cAnimDefaultEndTime;
	    	
	    	//log.info("ATTITUDE: NERVOUS (Speak) " + initiator + ": " + anim);
		}
		
	   subgoal performAnimation_portion(initiator, initiator, anim,
	   									animStartTime, animEndTime);
	}
	
	//FRUSTRATION -- GroupMaintenance -- Speak
	sequential behavior attitudeMain(String performanceEnum, String initiator, String responder){
		specificity 2;
		precondition { 	attitudeWME=(AttitudeControlWME)
						(attitudeWME.getName().equals(initiator))
						(attitudeWME.getType().equals(eAttitudeType_frustration))
						(performanceEnum.equals(eAttitudePerform_speak)) } 
		String anim;
		float animStartTime;
	    float animEndTime;
	    
		mental_act {
			if (Staging.percentChance(35)) anim = animationTalkingFrustrated1;
	    	else if (Staging.percentChance(35)) anim = animationTalkingFrustrated2;
	    	else if (Staging.percentChance(35)) anim = animationFrustratedAngry1;
	    	else anim = animationTalkingFrustrated3;
	    	animStartTime = cAnimDefaultStartTime;
	    	animEndTime = cAnimDefaultEndTime;
	    	
	    	//log.info("ATTITUDE: FRUSTRATION (Speak) " + initiator + ": " + anim);
		}
		
	   subgoal performAnimation_portion(initiator, initiator, anim,
	   									animStartTime, animEndTime);
	}
	
	// ~~~ Speaking Fast ~~~
	
	//NO ATTITUDE / NEUTRAL -- GroupMaintenance -- Speak
	sequential behavior attitudeMain(String performanceEnum, String initiator, String responder){
	   specificity 1;
	   precondition{
	      (performanceEnum.equals(eAttitudePerform_speakFast))
	   }
	    String anim;
	    float animStartTime;
	    float animEndTime;
	            
	    mental_act {
	    	if (Staging.percentChance(20)) anim = animationTalkingGestureEmphatic3;
	    	else if (Staging.percentChance(20)) anim = animationTalkingFrustrated1;
	    	else if (Staging.percentChance(20)) anim = animationTalkingGestureBigAffirmative1;
	    	else if (Staging.percentChance(20)) anim = animationTalkingGestureBigAffirmative2;
	    	else anim = anim = animationTalkingNeutral1;
	    	animStartTime = cAnimDefaultStartTime;
	    	animEndTime = cAnimDefaultEndTime;
	    	
	    	log.info("ATTITUDE: NEUTRAL (SpeakFast) " + initiator + ": " + anim);
	   }
	   
	   subgoal performAnimation_portion(initiator, initiator, anim,
										animStartTime, animEndTime);
	
	}
	
	// ~~~ Listening ~~~
	
	//JOVIAL -- GroupMaintenance -- Listen
	sequential behavior attitudeMain(String performanceEnum, String initiator, String responder){
	   specificity 2;
	   precondition { 	attitudeWME=(AttitudeControlWME)
						(attitudeWME.getName().equals(initiator))
						(attitudeWME.getType().equals(eAttitudeType_jovial))
						(performanceEnum.equals(eAttitudePerform_listen)) }
	    String anim;
	    float animStartTime;
	    float animEndTime;
	            
	    mental_act {
	
	    	animStartTime = cAnimDefaultStartTime;
	    	animEndTime = cAnimDefaultEndTime;
	    	
	    	
	    	if (Staging.percentChance(20)) anim = animationHeadNodSmiling;
	    	else if (Staging.percentChance(5)) anim = animationGestureCough1;
	    	else if (Staging.percentChance(20)) anim = animationHeadNodOpenSmiling;
	    	else if (Staging.percentChance(40)) anim = animationLaugh;
	    	else if (Staging.percentChance(10)) { anim = animationReleaseLaugh; animEndTime = 2.0f; }
	    	else {
	    		anim = animationThumbsUp;
	    		// Thumbs up is very fast, wait a bit longer? Or do I have to put this after it?
	    		animEndTime += .4;
	    	}
	    	
	    
	    	
	    	//log.info("ATTITUDE: JOVIAL (Listen) " + initiator + ": " + anim); 
	   }
	   
	   // SMILE! :D (in the jovial/unjovial list option.)
	   //Should I turn it on here too/instead? Doesn't seem to stick long enough
	   	//subgoal performAnimation(initiator, initiator, animationFaceSmile);
		subgoal performAnimation_portion(initiator, initiator, anim,
										animStartTime, animEndTime);
		//subgoal clearFace(initiator);
	}
	
	//SERIOUS -- GroupMaintenance -- Listen
	sequential behavior attitudeMain(String performanceEnum, String initiator, String responder){
	   specificity 2;
	   precondition { 	attitudeWME=(AttitudeControlWME)
						(attitudeWME.getName().equals(initiator))
						(attitudeWME.getType().equals(eAttitudeType_serious))
						(performanceEnum.equals(eAttitudePerform_listen)) }
	    String anim;
	    float animStartTime;
	    float animEndTime;
	            
	    mental_act {
	
	    	animStartTime = cAnimDefaultStartTime;
	    	animEndTime = cAnimDefaultEndTime;
	    	
	    	if (Staging.percentChance(20)){ anim = animationHeadShake; }
	    	else if (Staging.percentChance(5)){ anim = animationGestureCough1; }
	    	else if (Staging.percentChance(20)){ anim = animationIdle_Agitated2; animEndTime = 1.5f; }
	    	else if (Staging.percentChance(30)){ anim = animationIdle_Restless; animEndTime = 2.0f; }
	    	else if (Staging.percentChance(15)){ anim = animationListeningAngry1; }
	    	else {
	    		anim = animationExasperated3;
	    		animEndTime = 2.0f;
	    	}
	    	
	    	//log.info("ATTITUDE: SERIOUS (Listen) " + initiator + ": " + anim); 
	   }
	
		subgoal performAnimation_portion(initiator, initiator, anim,
										animStartTime, animEndTime);
	}
	
	//NO ATTITUDE / NEUTRAL -- GroupMaintenance -- Listen
	sequential behavior attitudeMain(String performanceEnum, String initiator, String responder){
	   specificity 1;
	   precondition{
	      (performanceEnum.equals(eAttitudePerform_listen))
	   }
	    String anim;
	    float animStartTime;
	    float animEndTime;
	            
	    mental_act {
	
	    	animStartTime = cAnimDefaultStartTime;
	    	
	    	animEndTime = cAnimDefaultEndTime;
	    	
	    	if (Staging.percentChance(20)) anim = animationIdle_Agitated2;
	    	else if (Staging.percentChance(5)) anim = animationGestureCough1;
	    	else if (Staging.percentChance(20)) anim = animationIdle_AngryAkimbo1;
	    	else if (Staging.percentChance(5)) anim = animationLaugh;
	    	else {
	    		anim = animationIdle_Impatient;
	    		animEndTime = 1.0f;
	    	}
	    	
	    	// APRIL (4-9-13) testing new animations
	    	//anim = animationTalkingGestureEmphatic2;
	    	
	    	//log.info("ATTITUDE: NEUTRAL (Listen) " + initiator + ": " + anim); 
	   }
	   
	   subgoal performAnimation_portion(initiator, initiator, anim,
										animStartTime, animEndTime);
	
	}
	
	//CURIOUS -- GroupMaintenance -- Listen
	//WARY/NERVOUS -- GroupMaintenance -- Listen
	sequential behavior attitudeMain(String performanceEnum, String initiator, String responder){
	   specificity 2;
	   precondition { 	attitudeWME=(AttitudeControlWME)
						(attitudeWME.getName().equals(initiator))
						(attitudeWME.getType().equals(eAttitudeType_nervous))
						(performanceEnum.equals(eAttitudePerform_listen)) }
	    String anim;
	    String faceanim;
	    float animStartTime;
	    float animEndTime;
	            
	    mental_act {
	
	    	animStartTime = cAnimDefaultStartTime;
	    	animEndTime = cAnimDefaultEndTime;
	    	
	    	if (Staging.percentChance(10)){ anim = animationGestureCough1; }
	    	else if (Staging.percentChance(30)){ anim = animationIdle_Agitated1; animStartTime = 2.0f; }
	    	else if (Staging.percentChance(30)){ anim = animationIdle_Agitated2; animStartTime = 2.0f; }
	    	else if (Staging.percentChance(20)){ anim = animationConfusedIdle; animEndTime = 1.5f; }
	    	else {
	    		anim = animationHandsHeldStand;
	    		animEndTime = 2.0f;
	    	}
	    	
	    	if (Staging.percentChance(40)) faceanim = animationFaceUnsure;
	    	else faceanim = animationFaceAnxious;
	    	
	    	//log.info("ATTITUDE: NERVOUS (Listen) " + initiator + ": " + anim + " with face " + faceanim); 
	   }
	
		subgoal performAnimation(initiator, initiator, faceanim);
		subgoal performAnimation_portion(initiator, initiator, anim,
										animStartTime, animEndTime);
		subgoal waitFor(500);
		subgoal clearFace(initiator);
	}
	
	//FRUSTRATION -- GroupMaintenance -- Listen
	sequential behavior attitudeMain(String performanceEnum, String initiator, String responder){
	   specificity 2;
	   precondition { 	attitudeWME=(AttitudeControlWME)
						(attitudeWME.getName().equals(initiator))
						(attitudeWME.getType().equals(eAttitudeType_frustration))
						(performanceEnum.equals(eAttitudePerform_listen)) }
	    String anim;
	    float animStartTime;
	    float animEndTime;
	            
	    mental_act {
	
	    	animStartTime = cAnimDefaultStartTime;
	    	animEndTime = cAnimDefaultEndTime;
	    	
	    	if (Staging.percentChance(20)){ anim = animationFrustratedAngry3; }
	    	else if (Staging.percentChance(20)){ anim = animationListeningAngry2;  }
	    	else if (Staging.percentChance(20)){ anim = animationListeningFrustrated1; animEndTime = 2.0f; }
	    	else if (Staging.percentChance(20)){ anim = animationExasperated1; animEndTime = 2.0f; }
	    	else if (Staging.percentChance(20)){ anim = animationExasperated1; animStartTime = 2.5f; animEndTime = 2.0f;  }
	    	else {
	    		anim = animationIdle_Agitated2;
	    		animEndTime = 2.0f;
	    	}
	    	
	    	//log.info("ATTITUDE: FRUSTRATION (Listen) " + initiator + ": " + anim); 
	   }
	
		subgoal performAnimation_portion(initiator, initiator, anim,
										animStartTime, animEndTime);
	}
	
	// ~~~ Listening Fast ~~~
	
	//NO ATTITUDE / NEUTRAL -- GroupMaintenance -- Listen
	sequential behavior attitudeMain(String performanceEnum, String initiator, String responder){
	   specificity 1;
	   precondition{
	      (performanceEnum.equals(eAttitudePerform_listenFast))
	   }
	    String anim;
	    float animStartTime;
	    float animEndTime;
	            
	    mental_act {
	
	    	animStartTime = cAnimDefaultStartTime;
	    	animEndTime = cAnimDefaultEndTime;
	    	
	    	if (Staging.percentChance(10)) anim = animationConfused4;
	    	else if (Staging.percentChance(10)) anim = animationConfused;
	    	else if (Staging.percentChance(10)) anim = animationConfused2;
	    	else if (Staging.percentChance(5)) anim = animationGestureCough1;
	    	else if (Staging.percentChance(20)) anim = animationScratchChin;
	    	else if (Staging.percentChance(10)) anim = animationIdle_AngryAkimbo1;
	    	else if (Staging.percentChance(10)) anim = animationTalkingGestureEmphatic1;
	    	else if (Staging.percentChance(10)) anim = animationTalkingGestureEmphatic2;
	    	else {
	    		anim = animationIdle_Impatient;
	    		animEndTime = 1.0f;
	    	}
	    	if (animEndTime > 1.5f) animEndTime = 1.5f;
	    	
	    	log.info("ATTITUDE: NEUTRAL (ListenFast) " + initiator + ": " + anim); 
	   }
	   
	   subgoal performAnimation_portion(initiator, initiator, anim,
										animStartTime, animEndTime);
	
	}
	
	// ~~~ Glancing ~~~
	
	// JOVIAL -- GroupMaintenance -- Glance
	sequential behavior attitudeMain(String performanceEnum, String initiator, String responder){
		specificity 2;
		precondition {	attitudeWME=(AttitudeControlWME)
						(attitudeWME.getName().equals(initiator))
						(attitudeWME.getType().equals(eAttitudeType_jovial))
						(performanceEnum.equals(eAttitudePerform_glance)) }
		String faceanim;
			
		mental_act {
			faceanim = animationFaceBigSmile;
			//log.info("ATTITUDE: JOVIAL (Glance) " + initiator + " at " + responder);
		}
		
		subgoal headTrack(initiator, responder);
		
		subgoal performAnimation(initiator, initiator, faceanim);
		subgoal waitForRand(1000,2000);
		subgoal clearFace(initiator);
		
	}
	
	// SERIOUS -- GroupMaintenance -- Glance
	sequential behavior attitudeMain(String performanceEnum, String initiator, String responder){
		specificity 2;
		precondition {	attitudeWME=(AttitudeControlWME)
						(attitudeWME.getName().equals(initiator))
						(attitudeWME.getType().equals(eAttitudeType_serious))
						(performanceEnum.equals(eAttitudePerform_glance)) }
		String faceanim;
			
		mental_act {
			faceanim = animationFaceStony;
			//log.info("ATTITUDE: SERIOUS (Glance) " + initiator + " at " + responder);
		}
		
		subgoal headTrack(initiator, responder);
		
		subgoal performAnimation(initiator, initiator, faceanim);
		subgoal waitForRand(1000,2000);
		subgoal clearFace(initiator);
		
	}
	
	// NEUTRAL -- GroupMaintenance -- Glance
	sequential behavior attitudeMain(String performanceEnum, String initiator, String responder){
		specificity 1;
		precondition {	(performanceEnum.equals(eAttitudePerform_glance)) }
			
		//mental_act { log.info("ATTITUDE: NEUTRAL (Glance) " + initiator + " at " + responder); }
		
		subgoal headTrack(initiator, responder);
		
		subgoal waitForRand(1000,2000);
	}
	
	// CURIOUS -- GroupMaintenance -- Glance
	sequential behavior attitudeMain(String performanceEnum, String initiator, String responder){
		specificity 2;
		precondition {	attitudeWME=(AttitudeControlWME)
						(attitudeWME.getName().equals(initiator))
						(attitudeWME.getType().equals(eAttitudeType_curious))
						(performanceEnum.equals(eAttitudePerform_glance)) }
		String faceanim;
			
		mental_act {
			faceanim = animationFaceSmile;
			//log.info("ATTITUDE: CURIOUS (Glance) " + initiator + " at " + responder);
		}
		
		subgoal headTrack(initiator, responder);
		
		subgoal performAnimation(initiator, initiator, faceanim);
		subgoal waitForRand(1000,2000);
		subgoal clearFace(initiator);
		
	}
	
	// NERVOUS -- GroupMaintenance -- Glance
	sequential behavior attitudeMain(String performanceEnum, String initiator, String responder){
		specificity 2;
		precondition {	attitudeWME=(AttitudeControlWME)
						(attitudeWME.getName().equals(initiator))
						(attitudeWME.getType().equals(eAttitudeType_nervous))
						(performanceEnum.equals(eAttitudePerform_glance)) }
		String faceanim;
			
		mental_act {
			faceanim = animationFaceNervous;
			//log.info("ATTITUDE: NERVOUS (Glance) " + initiator + " at " + responder);
		}
		
		subgoal headTrack(initiator, responder);
		
		subgoal performAnimation(initiator, initiator, faceanim);
		subgoal waitForRand(500,1000);
		subgoal clearFace(initiator);
		
	}
	
	// FRUSTRATION -- GroupMaintenance -- Glance
	sequential behavior attitudeMain(String performanceEnum, String initiator, String responder){
		specificity 2;
		precondition {	attitudeWME=(AttitudeControlWME)
						(attitudeWME.getName().equals(initiator))
						(attitudeWME.getType().equals(eAttitudeType_frustration))
						(performanceEnum.equals(eAttitudePerform_glance)) }
		String faceanim;
			
		mental_act {
			faceanim = animationFaceAngry;
			//log.info("ATTITUDE: FRUSTRATION (Glance) " + initiator + " at " + responder);
		}
		
		subgoal headTrack(initiator, responder);
		
		subgoal performAnimation(initiator, initiator, faceanim);
		subgoal waitForRand(1000,2000);
		subgoal clearFace(initiator);
		
	}
	
	// ******************************
	// ATTITUDE INSERTIONS
	
	//EXASPERATED 1 -- PRE OR POST SEQUENTIAL
	sequential behavior attitudeInsert(String performanceEnum, String initiator, String responder, String insertionPoint){
	   specificity 2;
	   precondition{
	            attitudeWME=(AttitudeControlWME)
	            (attitudeWME.getName().equals(initiator))
	            (attitudeWME.getType().equals(eAttitudeType_exasperation))
	   }
	   subgoal performAnimation_portion(initiator, responder, animationExasperated1, 0f, 1.63f); 
	   mental_act{
	      attitudeWME.incrementNumTimesExpressed(animationExasperated1);
	   }
	}
	
	//EXASPERATED 2 -- POST SEQUENTIAL
	sequential behavior attitudeInsert(String performanceEnum, String initiator, String responder, String insertionPoint){
	 specificity 2;
	 precondition {    attitudeWME=(AttitudeControlWME)
	       (attitudeWME.getName().equals(initiator))
	       (attitudeWME.getType().equals(eAttitudeType_exasperation))
	       (insertionPoint.equals("post"))
	 }
	 
	 //mental_act {log.info("##POST Inserting an post-SIU expression of EXASPERATED (parallel) attitude in SIU" + performanceEnum);}
	 
	 //Throw hands in the air.
	 spawngoal performAnimation(initiator, responder, animationFrustrated1);
	 mental_act{
	    attitudeWME.incrementNumTimesExpressed(animationFrustrated1);
	 }
	}
	
	//EXASPERATED -- SIU Give Object -- POST SEQUENTIAL
	sequential behavior attitudeInsert(String performanceEnum, String initiator, String responder, String insertionPoint){
	 specificity 2;
	 precondition {    attitudeWME=(AttitudeControlWME)
	       (attitudeWME.getName().equals(initiator))
	       (insertionPoint.equals("post"))
	       (attitudeWME.getType().equals(eAttitudeType_exasperation))
	       (performanceEnum.equals(eAttitudePerform_giveObject))}
	 //mental_act {log.info("##POST Inserting an post-SIU expression of EXASPERATED (sequential) attitude in SIU" + performanceEnum);}
	 
	 //pull the card away, laugh and then hand it back.
	 //subgoal performAnimation_portion(initiator, responder, animationReachAndTakeObject)
	 subgoal performAnimation_portion(initiator, responder, animationReachAndTakeObject,   1f, 2f);
	 subgoal performAnimation(initiator, responder, animationLaugh);
	 subgoal performAnimation(initiator, responder, animationOfferObject);
	 
	 mental_act{
	    attitudeWME.incrementNumTimesExpressed(animationReachAndTakeObject);
	 }
	}
	
	//FRUSTRATED 1
	sequential behavior attitudeInsert(String performanceEnum, String initiator, String responder, String insertionPoint){
	 specificity 2;
	 precondition{
	          attitudeWME=(AttitudeControlWME)
	          (attitudeWME.getName().equals(initiator))
	          (attitudeWME.getType().equals(eAttitudeType_frustration))
	 }
	 
	 subgoal performAnimation_portion(initiator, responder, animationFrustrated1, 0f, 1.63f); 
	 mental_act{
	    attitudeWME.incrementNumTimesExpressed(animationFrustrated1);
	 }
	}
	
	//FRUSTRATED 2
	parallel behavior attitudeInsert(String performanceEnum, String initiator, String responder, String insertionPoint){
	specificity 2;
	precondition{
	        attitudeWME=(AttitudeControlWME)
	        (attitudeWME.getName().equals(initiator))
	        (attitudeWME.getType().equals(eAttitudeType_frustration))
	}
	
	   subgoal performAnimation(initiator, responder, animationFaceAngry);
	   mental_act{
	     attitudeWME.incrementNumTimesExpressed(animationFaceAngry);
	   }
	}
	
	//FRUSTRATED 3
	sequential behavior attitudeInsert(String performanceEnum, String initiator, String responder, String insertionPoint){
	specificity 2;
	precondition {    attitudeWME=(AttitudeControlWME)
	     (attitudeWME.getName().equals(initiator))
	     (attitudeWME.getType().equals(eAttitudeType_frustration))
	   }
	//mental_act {log.info("##POST Inserting an post-SIU expression of FRUSTRATION (sequential) attitude in SIU" + performanceEnum);}
	
	//Wave arms around angerly.
	subgoal performAnimation_portion(initiator, responder, animationAngryArguing3, 0f, 0.8f);
	
	mental_act{
	   attitudeWME.incrementNumTimesExpressed(animationAngryArguing3);
	 }
	}
	
	
	
	//COMPLIANT 1
	sequential behavior attitudeInsert(String performanceEnum, String initiator, String responder, String insertionPoint){
	   specificity 2;
	   precondition{
	            attitudeWME=(AttitudeControlWME)
	            (attitudeWME.getName().equals(initiator))
	            (attitudeWME.getType().equals(eAttitudeType_compliance))
	   }
	   
	   mental_act{
	      log.info("###### attitudeInsert with compliance maybe...");
	   }
	   
	   subgoal computeAttitudeProbability(attitudeWME, animationGestureCough1);
	   subgoal performAnimation(initiator, responder, animationGestureCough1);
	   
	   //subgoal performAnimation(initiator, responder, animationIdle_AvoidingGazeStart1); 
	   //subgoal performAnimation_portion(initiator, responder, animationIdle_AvoidingGazeLoop1,0f,1f); 
	   //subgoal performAnimation(initiator, responder, animationIdle_AvoidingGazeEnd1); 
	   
	   mental_act{
	      //attitudeWME.incrementNumTimesExpressed(animationIdle_AvoidingGazeLoop1);
	      attitudeWME.incrementNumTimesExpressed(animationGestureCough1);
	      
	   }
	   
	  }
	
	//COMPLIANT 2
	sequential behavior attitudeInsert(String performanceEnum, String initiator, String responder, String insertionPoint){
	 specificity 2;
	 precondition{
	          attitudeWME=(AttitudeControlWME)
	          (attitudeWME.getName().equals(initiator))
	          (attitudeWME.getType().equals(eAttitudeType_compliance))
	 }
	 
	 mental_act{
	    log.info("###### attitudeInsert with compliance maybe...");
	 }
	 
	 subgoal computeAttitudeProbability(attitudeWME, animationListeningHoldChin);
	 subgoal performAnimation(initiator, responder, animationListeningHoldChin);
	 
	 //subgoal performAnimation(initiator, responder, animationIdle_AvoidingGazeStart1); 
	 //subgoal performAnimation_portion(initiator, responder, animationIdle_AvoidingGazeLoop1,0f,1f); 
	 //subgoal performAnimation(initiator, responder, animationIdle_AvoidingGazeEnd1); 
	 
	 mental_act{
	    //attitudeWME.incrementNumTimesExpressed(animationIdle_AvoidingGazeLoop1);
	    attitudeWME.incrementNumTimesExpressed(animationListeningHoldChin);
	    
	 }
	 
	}
	
	//NO ATTITUDE
	sequential behavior attitudeInsert(String performanceEnum, String initiator, String responder, String insertionPoint){
	 mental_act{log.info("##" + insertionPoint + " " + initiator + " does not have any attitudes, OR this attitude case has not been authored for the " + insertionPoint + "-Insertion step of SIU" + performanceEnum);}
	}
	
	////////////////////////////////////////////////
	//Attitude Utility Functions
	////////////////////////////////////////////////
	
	//This behavor looks at how much the passed in attitudeWME has already been expressed
	//and how many times the passed in animation has been expressed as part of this attitudeWME.
	//The more it has been expressed, the lower the value will be that is stored in the returnValueWME, which in turn
	//will decrease the probability that this attitude/animation combination will be expressed in the future.
	sequential behavior computeAttitudeProbability(AttitudeControlWME attitudeWME, String attitudeAnimation){
	   float threshold;
	   float ratio;
	   float sameAttitudePenaltyTotal;
	   float numTimesAttitudeExpressed;
	   ReturnValueWME returnValueWME;
	   
	   mental_act{
	      returnValueWME = new ReturnValueWME();
	      
	      threshold = 100;
	      numTimesAttitudeExpressed = attitudeWME.getNumTimesExpressed();
	      //Only need to bother doing calculations if the attitude has been expressed at least once.
	      if(numTimesAttitudeExpressed > 0){
	         
	         //lower the threshold by:  [(# of times we've seen this attitude) / (# of times this attitude has been expressed)] * sameAnimationPenalty
	         ratio = (float) attitudeWME.getNumTimesAnimationExpressed(attitudeAnimation) / numTimesAttitudeExpressed;
	         threshold -=  ratio * cAttitudeUtility_sameAnimationPenalty;
	         
	         log.info("inside of computeAttitudeProbability! (middle) ratio: " + ratio + " threshold: " + threshold);
	         
	         //lower the threshold by: # of times this attidue has been expressed * sameAttitudePenalty.
	         sameAttitudePenaltyTotal = numTimesAttitudeExpressed * cAttitudeUtility_sameAttitudePenalty;
	         threshold -= sameAttitudePenaltyTotal;
	         
	         log.info("inside of computeAttitudeProbability! (end) penaltyTotal: " + sameAttitudePenaltyTotal + " threshold: " + threshold);
	      }
	      
	      log.info("inside of computeAttitudeProbability! threshold value going into returnValueWME: " + threshold);
	      returnValueWME.setFloat(threshold);
	   }
	   
	   //So, we've computed the probability -- let's make sure that it is unique enough!
	   subgoal verifyProbability(returnValueWME, attitudeWME, attitudeAnimation);
	}
	  
	//verifyProbability -- in which the probability is "not good" (i.e. below the threshold) and so we 'return' with a fail_step
	sequential behavior verifyProbability(ReturnValueWME returnValueWME, AttitudeControlWME attitudeWME, String attitudeAnimation){
	   specificity 10;
	   precondition{
	      (returnValueWME.getFloat() < cAttitudeUtility_uniquenessThreshold)
	   }
	   
	   //Oh oh! This expression of this attitude isn't unique enough! 
	   mental_act{
	      log.info("verifyProbability: return value of " + returnValueWME.getFloat() + " was below the threshold of " + cAttitudeUtility_uniquenessThreshold + " NOT playing " + attitudeAnimation + " in attitude " + attitudeWME.getType());
	   }
	   fail_step;
	}
	
	//verifyProbability -- if we get here, then that means that the above verifyProbability didn't have it's precondition met.
	//Which means we can successfully play the animation without worry!
	sequential behavior verifyProbability(ReturnValueWME returnValueWME, AttitudeControlWME attitudeWME, String attitudeAnimation){
	   specificity 2;
	   precondition{
	      (returnValueWME.getFloat() >= cAttitudeUtility_uniquenessThreshold)
	   }
	   
	   mental_act{
	      log.info("verifyProbability: return value of " + returnValueWME.getFloat() + " was OK! playing " + attitudeAnimation + " in attitude " + attitudeWME.getType());
	   }
	}

*/
// ########## OLD WRAP-ON CODE



// ########## OLD SIGNAL PROCESSING CODE
/*

    /*
     *  initialWaitForSUSocialSignalWMEs
     
	sequential behavior initialWaitForSUSocialSignalWMEs() {
		SocialSignalWME socialSignalWME;
		Iterator iterator;
	
		mental_act { log.info("initialWaitForSUSocialSignalWMEs waiting for new SocialSignalWMEs"); }
			
		// wait for signals not yet initially processed
		with (success_test { socialSignalWME = (SocialSignalWME bInitiallyProcessed == false) } ) wait;

		mental_act {
			socialSignalWME.setBInitiallyProcessed(true);
			log.info("initialWaitForSUSocialSignalWMEs got a signal " +socialSignalWME);
			iterator = socialSignalWME.getSignal().iterator(); 
		}
						
		// process each signal (intepretation) that just came in		
		with (persistent when_succeeds) subgoal initialWaitForSUSocialSignalWMEs_loop(iterator, socialSignalWME);
	}
	
	atomic sequential behavior initialWaitForSUSocialSignalWMEs_loop(Iterator iterator, SocialSignalWME socialSignalWME) {
		precondition { (iterator.hasNext()) }
		SocialInterpretation interpretation;
		boolean bVerbal;
		mental_act { 
			interpretation = iterator.next();
			bVerbal = socialSignalWME.sourceEventIsUtterance(); 
		}
		with (ignore_failure) subgoal managePlayerArmExtendedFlag(interpretation, bVerbal);
	}


    /*
     *  waitForSUSocialSignalWMEs
     
     	
	// if this is a mixin, and is running in parallel to the parent SIU, don't actually wait on the signal;
	// the parent is doing it
	sequential behavior waitForSUSocialSignalWMEs(int myUid) {
		precondition { 	executeSiuWME=(ExecuteSiuWME) (executeSiuWME.uidEquals(myUid))
		 				(executeSiuWME.getBCiFDirected() == false)
		 				(executeSiuWME.getBParallelToParentSIU() == true)
						}
		specificity 2;
		String parentName;
		mental_act { 
			parentName = executeSiuWME.getBehaviorSetName(); 
			log.info("waitForSUSocialSignalWMEs [" +parentName+ "] allowing parent SIU to wait for signals"); 
		}
		wait;
	}
		
	sequential behavior waitForSUSocialSignalWMEs(int myUid) {
		precondition { executeSiuWME=(ExecuteSiuWME) (executeSiuWME.uidEquals(myUid)) }
		specificity 1;
		String parentName;
		mental_act { parentName = executeSiuWME.getBehaviorSetName(); }
		subgoal waitForSUSocialSignalWMEs(parentName);		
	}

	sequential behavior waitForSUSocialSignalWMEs() {
		subgoal waitForSUSocialSignalWMEs("");
	}
	 
	// wait for both new and stale signals here    	     
	parallel behavior waitForSUSocialSignalWMEs(String parentName) {
		subgoal waitForSUSocialSignalWMEs_new(parentName);
		with (effect_only) subgoal waitForSUSocialSignalWMEs_stale(parentName);
	}
	
	sequential behavior waitForSUSocialSignalWMEs_new(String parentName) {
		SocialSignalWME socialSignalWME;
	
		mental_act { log.info("waitForSUSocialSignalWMEs [" +parentName+ "] waiting for new SocialSignalWMEs"); }
			
		// wait for signals not yet set to CiF
		with (success_test { socialSignalWME = (SocialSignalWME 
									bCiFNotified::bCiFNotified
									bRenotifyCiF::bRenotifyCiF)
								(bCiFNotified == false || bRenotifyCiF == true) 
								} ) wait;

		mental_act { log.info("waitForSUSocialSignalWMEs [" +parentName+ "] got a signal " +socialSignalWME); }
								
		// Call with ignore_failure in case some other parallel waitForSUSocialSignalWMEs() has processed this new WME before us
		with (ignore_failure) subgoal processSUSocialSignalWMEs(parentName);
	}

	atomic sequential behavior processSUSocialSignalWMEs(String parentName) {
		specificity 1;
		mental_act { log.info("processSUSocialSignalWMEs [" +parentName+ "] had nothing to do"); }
	}
	
    /*
     *  waitForSUSocialSignalWMEs_stale
     
     	
	sequential behavior waitForSUSocialSignalWMEs_stale(String parentName) {
		SocialSignalWME socialSignalWME;
	
		//mental_act { log.info("waitForSUSocialSignalWMEs [" +parentName+ "] waiting for stale SocialSignalWMEs"); }
			
		// wait for signals not yet set to CiF
		with (success_test { socialSignalWME = (SocialSignalWME 
												bCiFNotified == true
												bRenotifyCiF == false
												bRenotifiedCiF == false)
								(socialSignalWME.isRecentWithinLast(cStaleGestureTimeout) == false)
								} ) wait;

		//mental_act { log.info("waitForSUSocialSignalWMEs [" +parentName+ "] got a stale signal " +socialSignalWME); }
								
		// Call with ignore_failure in case some other parallel waitForSUSocialSignalWMEs_stale() has processed this new WME before us
		with (ignore_failure) subgoal processStaleSocialSignalWMEs(parentName);
	}


	atomic sequential behavior processStaleSocialSignalWMEs(String parentName) {
		specificity 1;
		mental_act { log.info("processStaleSocialSignalWMEs [" +parentName+ "] had nothing to do"); }
	}

    /**
     *  markInterpretationAsChosen
     *  Set flags in a SocialSignalWME to know how to inform CiF about the chosen interpretations (if any)
    
	sequential behavior markInterpretationAsChosen(SocialSignalWME socialSignalWME, SocialInterpretation interpretation) {

		mental_act {
			//log.info("Marking interpretation as chosen");
			
			socialSignalWME.setChosenInterpretation(interpretation);			
			
			// if we need to renotify CiF about the final interpretation
			if (socialSignalWME.getBCiFNotified()) 
				socialSignalWME.setBRenotifyCiF(true);	 
		}
	}


	/**
	 * receiveSignalOrFail - if successfully receive the expected signal
	 
	sequential behavior receiveSignalOrFail(CharactersWME responders, SocialInterpretation interpretationMatch, int waitTime)
	{ 
		specificity 2;
		SocialSignalWME signalWME;
		
		mental_act { log.info("Waiting up to " +(waitTime/1000)+ "s for player to signal " +interpretationMatch); }
				
     	with (success_test {	(SocialSignalWME self::signalWME)
								(signalWME.getChosenInterpretation() == null)
								
								// old
								//(signalWME.getRecipient().equals(recipientName))
								// new
								(responders.containsCharacter(signalWME.getRecipient()))
								
								(signalWME.isRecentWithinLast(cStaleGestureTimeout))
						        (signalWME.contains(interpretationMatch)) 
						        } ) 
         	subgoal waitThenFail(waitTime);

		mental_act { log.info("Player successfully communicated expected signal " +interpretationMatch+ " to " +responders); }
		//mental_act { log.info("Player successfully communicated expected signal " +signalWME.getChosenInterpretation()+ " to " +responders); }
	}
	
	/**
	 * receiveSignalOrFail - if fails
	 
	sequential behavior receiveSignalOrFail(CharactersWME responders, SocialInterpretation interpretationMatch, int waitTime)
	{
		specificity 1;
		mental_act { log.info("Player failed to communicate expected signal " +interpretationMatch+ " to " +responders);}
		fail_step;
	}
	

	// From SocialSignalWME.java
	
   private boolean bInitiallyProcessed;  // whether Abl has done some initial processing on the signal
   private boolean bCiFNotified;  // whether CiF has been initially notified
   private boolean bRenotifyCiF;  // if CiF needs to be renotified about the final interpretation
   private boolean bRenotifiedCiF;  // was CiF renotified

   /*
    * @return bInitiallyProcessed -- whether Abl has initially processed this signal
    
   public boolean getBInitiallyProcessed() {
      return bInitiallyProcessed;
   }

   /*
    * @param bVal - set bInitiallyProcessed
    
   public void setBInitiallyProcessed(boolean bVal) {
      this.bInitiallyProcessed = bVal;
   }

   /*
    * @return bCiFNotified -- whether Abl has initially notified CiF about this signal
    
   public boolean getBCiFNotified() {
      return bCiFNotified;
   }

   /*
    * @param bVal - set bCiFNotified
    
   public void setBCiFNotified(boolean bVal) {
      this.bCiFNotified = bVal;
   }

   /*
    * @return bRenotifyCiF -- if CiF needs to be renotified by Abl about the final interpretation
    
   public boolean getBRenotifyCiF() {
      return bRenotifyCiF;
   }

   /*
    * @param bVal - set bRenotifyCiF
    
   public void setBRenotifyCiF(boolean bVal) {
      this.bRenotifyCiF = bVal;
   }

   /*
    * @return bRenotifiedCiF -- if CiF needs to be renotified by Abl about the final interpretation
    
   public boolean getBRenotifiedCiF() {
      return bRenotifiedCiF;
   }

   /*
    * @param bVal - set bRenotifiedCiF
    
   public void setBRenotifiedCiF(boolean bVal) {
      this.bRenotifiedCiF = bVal;
   }
  	
*/	
// ########## OLD SIGNAL PROCESSING CODE


/* From LaunchSIU.abl

	/**
	 * Lower parameter version.
	 
	atomic sequential behavior testbed_LaunchSIU_groupGreet(SiuWME siuWME) {
		CharacterWME recipient;
		String myName;
		GroupWME groupWME;
		String gestureName;
		SocialInterpretation interpretation;
		Gesture gesture;
		Iterator iterator;
		SocialSignalWME triggerSignalWME;
	
		mental_act {
			myName = siuWME.getInitiator().getName();
			recipient = siuWME.getPrimaryResponder();
			triggerSignalWME = triggerSignalWME;	// APS 5.24.13 -- what is this....???
			
			// fixme: for now, just choose one of the interpretations in the signal
			iterator = triggerSignalWME.getSignal().iterator();
			if (iterator.hasNext()) interpretation = (SocialInterpretation)(iterator.next());
			
			// fixme: for now, just choose one recipient
			recipient = triggerSignalWME.getClosestRecipient(); //getRecipient();

			triggerSignalWME.setChosenInterpretation(interpretation); 
			
			// Get name of raw MiBA gesture
			gesture = triggerSignalWME.getSourceEventGestureType();
			if (gesture == null) gestureName = "";
			else gestureName = gesture.toString();
			log.info("Lower param greet launch gesture " +gestureName);
		}
		subgoal testbed_LaunchSIU_groupGreet(myName, groupWME, gestureName);
	}
*/	

/* Old CiF rules
    
    //terminate approach when greet has happened
	// fixme: one better way to do this would be, approach should end itself when discourse/engagement has begun 
    rule terminateApproachViaGreet {
    	siuGreet=(SiuWME initiator::i executing==true)(siuGreet.getName().equals(siuNameGreet))
    	siuApproach=(SiuWME initiator::iApproach executing==true)
    	(siuApproach.getName().equals(siuNameApproach) && iApproach.getName().equals(i.getName()))		
    	->({siuApproach.setState(SiuExecutionState.REQUESTED_TERMINATION);})
    }
    
    //Make player the group's new speaker when greet happens.
    rule makePlayerGroupSpeakerViaGreet {
    	i=(CharacterWME name::iName)
    	siuGreet=(SiuWME initiator==i executing==true)(siuGreet.getName().equals(siuNameGreet))
    	oldWME=(ConversationWME speakerName::oldSpeakerName )(!oldWME.getSpeakerName().equals(iName)) //the speaker is not the player
    	oldSpeaker=(CharacterWME)(oldSpeaker.getName().equals(oldSpeakerName))
		g=(GroupWME formationCharactersWME::formChars)(g.contains(i) && g.contains(oldSpeaker))
//		(BehavingEntity.truePrintln("antecedent true for makePlayerGroupSpeakerViaGreet: " + iName + " " + oldSpeakerName))
    	->
    	!(ConversationWME speakerName==oldSpeakerName)
    	//({__$thisEntity.deleteWME(oldWME);})
    	({formChars=GroupUtil.cloneAndRemoveSelf(iName, formChars);
    	System.out.println(formChars);
    	__$thisEntity.addWME(new ConversationWME(iName, formChars, g, "smallTalkDiscussClose"));
    	})
    	//the last line is problematic (ConversationWME speakerName=iName groupWME=g currentVariation=smallTalk_DiscussClose)//missing other chars in formation
    	//(ConversationWME currentVariation=smallTalk_DiscussClose listenersCharactersWME=formChars speakerName=iName groupWME=g )
    }
 */
 
	/**
	 * Offering behaviors.
	 * 
	 * 
g.add(MiBA_Gesture.SMALL_WAVE_HOLDING_OBJECT);
g.add(MiBA_Gesture.SHOW_HELD_OBJECT);
g.add(MiBA_Gesture.SHOW_HELD_OBJECT_VARYING_ANGLES);
g.add(MiBA_Gesture.SMALL_BOW_HANDS_TOGETHER);
g.add(MiBA_Gesture.EMOTIONAL_APPEAL);
g.add(MiBA_Gesture.POINTING_LEFT_HAND);
g.add(MiBA_Gesture.POINTING_RIGHT_HAND);
g.add(MiBA_Gesture.FOLD_ARMS);
g.add(MiBA_Gesture.EXTEND_RIGHT_HAND);

	 */
	sequential behavior OfferExpectationsForSIU(SiuWME siu) {
		precondition {(siuNameApproach.equals(siu.getName()))geWME=(GestureExpectationServerWME)}
		specificity 2;
		mental_act {
			List g = new ArrayList();
			g.add(MiBA_Gesture.SMALL_WAVE_HOLDING_OBJECT);
			g.add(MiBA_Gesture.SMALL_BOW_HANDS_TOGETHER);
			geWME.offer(siu, g);
			log.info("Offering expectations for SIU: " + siu.getName());
		}
	}
	
	sequential behavior OfferExpectationsForSIU(SiuWME siu) {
		precondition {(siuNameGreet.equals(siu.getName()))geWME=(GestureExpectationServerWME)}
		specificity 2;
		mental_act {
			List g = new ArrayList();
			g.add(MiBA_Gesture.SHOW_HELD_OBJECT);
			geWME.offer(siu, g);
			log.info("Offering expectations for SIU: " + siu.getName());
		}
	}
	
	//disabled as neither gesture is currently being used
	/*sequential behavior OfferExpectationsForSIU(SiuWME siu) {
		precondition {(siuNameGroupReactToQuestion.equals(siu.getName()))geWME=(GestureExpectationServerWME)}
		specificity 2;
		mental_act {
			List g = new ArrayList();
			g.add(MiBA_Gesture.POINTING_LEFT_HAND);
			g.add(MiBA_Gesture.POINTING_RIGHT_HAND);
			geWME.offer(siu, g);
			log.info("Offering expectations for SIU: " + siu.getName());
		}
	}*/
	
	sequential behavior OfferExpectationsForSIU(SiuWME siu) {
		precondition {(siuNameGroupAnswerQuestion.equals(siu.getName()))geWME=(GestureExpectationServerWME)}
		specificity 2;
		mental_act {
			List g = new ArrayList();
			//g.add(MiBA_Gesture.POINTING_LEFT_HAND);
			//g.add(MiBA_Gesture.POINTING_RIGHT_HAND);
			g.add(MiBA_Gesture.SMALL_BOW_HANDS_TOGETHER);
			geWME.offer(siu, g);
			log.info("Offering expectations for SIU: " + siu.getName());
		}
	}
	
	sequential behavior OfferExpectationsForSIU(SiuWME siu) {
		specificity 1;
		mental_act {
			log.info("No expectations held for SIU " + siu.getName());
		}
	}
	
	sequential behavior ClearExpectationsForSIU(SiuWME siu) {
		precondition {geWME=(GestureExpectationServerWME)}
		mental_act {
			geWME.offer(siu, null);
			log.info("Clearing expectations held for SIU " + siu.getName());
		}
	}

	
	/**
	 * setupPerformanceWME()
	 */	 	
	atomic sequential behavior setupPerformanceWME(PerformanceWME performanceWME, SiuWME siuWME, String myName, int performancePriority, String performanceName) {
		subgoal setupPerformanceWME(performanceWME, siuWME, myName, performancePriority, 
									cPerformanceTypeExpression, performanceName, "");
	}
	
	atomic sequential behavior setupPerformanceWME(PerformanceWME performanceWME, SiuWME siuWME, String myName, 
													int performancePriority, int performanceType,
													String performanceName, String performanceParam) {
		mental_act {
			String siuName; 
							
			PerformanceManager.deleteOldPerformances(myName, performancePriority, performanceType, performanceName);
			
			if (siuWME != null) siuName = siuWME.getName();
			else siuName = "";
			
			performanceWME.init(myName, performancePriority, performanceType, siuName, performanceName, performanceParam);
			BehavingEntity.getBehavingEntity().addWME(performanceWME);
			
			// ## UPDATE PERFORMANCES ##
			// this may suspend the current performance
			PerformanceManager.updatePerformances(myName);
		}
	} 

	
		
	/**
	 * performanceWait()
	 * For a behavior, to wait till permitted to perform
	 */	 	
	sequential behavior performanceWait(PerformanceWME performanceWME) {
		//*/mental_act { log.info(performanceWME.getCharacterName()+ " waiting to start performance of priority-" +performanceWME.getPriority()+ " " +performanceWME.getPerformanceName()); }
		with (success_test { (performanceWME.getPerformanceState() == cPerformanceStatePerforming) } ) wait;
		//*/mental_act { log.info(performanceWME.getCharacterName()+ " starting performance of priority-" +performanceWME.getPriority()+ " " +performanceWME.getPerformanceName()); }
	}

		
	/**
	 * performanceDoneDeleteWME()
	 * For a behavior, when its performance is done, and we should delete its performanceWME
	 */	 	
	sequential behavior performanceDoneDeleteWME(PerformanceWME performanceWME) {
		String myName;
		
		mental_act {
			myName = performanceWME.getCharacterName();
			 
			__$thisEntity.deleteWME(performanceWME);
			//*/log.info(performanceWME.getCharacterName()+ " done with and deleted wme for performance of priority-" +performanceWME.getPriority()+ " " +performanceWME.getPerformanceName());
			
			// ## UPDATE PERFORMANCES ##
			PerformanceManager.updatePerformances(myName);
		} 
	}
	
	
	/**
	 * performanceCleanup()
	 */	 	
	sequential behavior performanceCleanup(String myName, String performanceName) {
		with (ignore_failure) subgoal performanceCleanup_main(myName, performanceName);
	}
	
	sequential behavior performanceCleanup_main(String myName, String perfName) {
		precondition { performanceWME=(PerformanceWME characterName==myName performanceName==perfName) }  
		mental_act {
			__$thisEntity.deleteWME(performanceWME); 
			//*/log.info(performanceWME.getCharacterName()+ " deleted aborted performance for " +performanceWME.getPerformanceName());
			
			// ## UPDATE PERFORMANCES ##
			PerformanceManager.updatePerformances(myName);
		}
	}


	/**
	 * performanceCleanupForSiu()
	 */	 	
	atomic sequential behavior performanceCleanupForSiu(SiuWME siuWME, String myName) {
		//*/mental_act { log.info("performanceCleanupForSiu " +siuWME.getName()+ " for " +myName); }
		
		mental_act {			
			PerformanceManager.cleanupForSIU(myName, siuWME);
		
			// ## UPDATE PERFORMANCES ##
			PerformanceManager.updatePerformances(myName);
		}
	}
	
	
	/**
	 * performanceCleanupForAllInSiu()
	 */	 	
	atomic sequential behavior performanceCleanupForAllInSiu(SiuWME siuWME) {
		String initiatorName;		
		Iterator respondersIterator;
		
		mental_act { 
			//*/log.info("performanceCleanupForAllInSiu " +siuWME.getName());
			initiatorName = siuWME.getInitiator().getName();
			
			respondersIterator = null;
			if (siuWME.getResponders() != null && siuWME.getResponders().getCharacterWMEs() != null) 
				respondersIterator = siuWME.getResponders().getCharacterWMEs().iterator();
		}
		
		// first, cleanup initiator
		subgoal performanceCleanupForSiu(siuWME, initiatorName);
	
		// now loop through responders
		with (ignore_failure) subgoal performanceCleanupForAllInSiu_loop(siuWME, respondersIterator);
	}
	
	atomic sequential behavior performanceCleanupForAllInSiu_loop(SiuWME siuWME, Iterator respondersIterator) {
		precondition { (respondersIterator != null) }
		with (persistent when_succeeds)
			subgoal performanceCleanupForAllInSiu_cleanup(siuWME, respondersIterator);
	}

	atomic sequential behavior performanceCleanupForAllInSiu_cleanup(SiuWME siuWME, Iterator respondersIterator) {
		precondition { (respondersIterator.hasNext()) }
		CharacterWME responderCharacterWME;
		String responderName;
		mental_act { 
			responderCharacterWME = respondersIterator.next();
			responderName = responderCharacterWME.getName();
		}
	
		// cleanup each responder
		subgoal performanceCleanupForSiu(siuWME, responderName);
	}	
	
	
	/**
	 * testbed_LaunchSIU_groupGreet()
	 */	 	
	sequential behavior testbed_LaunchSIU_groupGreet(String myName, GroupWME groupWME, String gestureName) {
		precondition {	siuWME=(SiuWME)
						(siuWME.getName().equals(siuNameGreet) &&
						 siuWME.getState()==SiuExecutionState.EXECUTING &&						 
						 siuWME.containsCharacter(myName)) }
        specificity 2;
        mental_act { log.info("## " +myName+ " waiting for current " +siuNameGreet+ " to be done before starting a new one"); } 		
		with (success_test { (siuWME.getState() != SiuExecutionState.EXECUTING) } ) wait;
        mental_act { log.info("## " +myName+ " done waiting for " +siuNameGreet+ " to be done, starting new one"); }
		subgoal testbed_LaunchSIU_groupGreet_main(myName, groupWME, gestureName);
	}

	sequential behavior testbed_LaunchSIU_groupGreet(String myName, GroupWME groupWME, String gestureName) {
        specificity 1;
		subgoal testbed_LaunchSIU_groupGreet_main(myName, groupWME, gestureName);
	}
	
	
	atomic sequential behavior testbed_LaunchSIU_groupGreet_main(String myName, GroupWME groupWME, String gestureName) {
		precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName))
                     }
        CharactersWME otherCharactersWME;
        SiuWME siuWME;

        mental_act {        
        	otherCharactersWME = GroupUtil.cloneAndRemoveSelf(myName, groupWME.getFormationCharactersWME());
			//log.info(myName+ " about to add SiuWME with " +otherCharactersWME.getSize()+ " responders");
			
			log.info("Greet launch with gesture " +gestureName);
        	
			siuWME = new SiuWME(siuNameGreet, myCharacterWME, otherCharactersWME);
			siuWME.setState(SiuExecutionState.EXECUTING);
			
			// custom state for this SIU
			siuWME.setParamGestureName(gestureName);
			
			BehavingEntity.getBehavingEntity().addWME(siuWME);
			log.info(myName+ " added executing SiuWME for " +siuNameGreet+ " with " +otherCharactersWME.getSize()+ " responders");
		}
		
		spawngoal SIU_greet(siuWME);		
	}

	


	/**
	 * testbed_LaunchSIU_groupFormation()
	 */	 	
	sequential behavior testbed_LaunchSIU_groupFormation(String myName) {
		precondition {	siuWME=(SiuWME)
						(siuWME.getName().equals(siuNameGroupFormation) &&
						 siuWME.getState()==SiuExecutionState.EXECUTING &&						 
						 siuWME.containsCharacter(myName)) }
        specificity 2;
        mental_act { log.info("## " +myName+ " waiting for current " +siuNameGroupFormation+ " to be done before starting a new one"); } 		
		with (success_test { (siuWME.getState() != SiuExecutionState.EXECUTING) } ) wait;
        mental_act { log.info("## " +myName+ " done waiting for current " +siuNameGroupFormation+ " to be done, starting new one"); }		
		subgoal testbed_LaunchSIU_groupFormation_main(myName);
	}
	
	sequential behavior testbed_LaunchSIU_groupFormation(String myName) {
        specificity 1;
		subgoal testbed_LaunchSIU_groupFormation_main(myName);
	}
	
	atomic sequential behavior testbed_LaunchSIU_groupFormation_main(String myName) {
		precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
                     	groupWME=(GroupWME) (groupWME.contains(myCharacterWME))
                     }
        SiuWME siuWME;

        mental_act {        
			siuWME = new SiuWME(siuNameGroupFormation, myCharacterWME);
			siuWME.setState(SiuExecutionState.EXECUTING);
			BehavingEntity.getBehavingEntity().addWME(siuWME);
			log.info(myName+ " added executing SiuWME for " +siuNameGroupFormation);
		}
		
		spawngoal SIU_groupFormation(siuWME);		
	}


	/**
	 * testbed_LaunchSIU_groupSmalltalk()
	 */	 	
	sequential behavior testbed_LaunchSIU_groupSmalltalk(String myName) {
		precondition {	siuWME=(SiuWME)
						(siuWME.getName().equals(siuNameGroupSmalltalk) &&
						 siuWME.getState()==SiuExecutionState.EXECUTING &&						 
						 siuWME.containsCharacter(myName)) }
        specificity 2;
        mental_act { log.info("## " +myName+ " waiting for current " +siuNameGroupSmalltalk+ " to be done before starting a new one"); } 		
		with (success_test { (siuWME.getState() != SiuExecutionState.EXECUTING) } ) wait;
        mental_act { log.info("## " +myName+ " done waiting for current " +siuNameGroupSmalltalk+ " to be done, starting new one"); }		
		subgoal testbed_LaunchSIU_groupSmalltalk_main(myName);
	}

	sequential behavior testbed_LaunchSIU_groupSmalltalk(String myName) {
        specificity 1;
		subgoal testbed_LaunchSIU_groupSmalltalk_main(myName);
	}
		
	atomic sequential behavior testbed_LaunchSIU_groupSmalltalk_main(String myName) {
		precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
                     	groupWME=(GroupWME) (groupWME.contains(myCharacterWME))
                     }
        SiuWME siuWME;

        mental_act {        
			siuWME = new SiuWME(siuNameGroupSmalltalk, myCharacterWME);
			siuWME.setState(SiuExecutionState.EXECUTING);
			BehavingEntity.getBehavingEntity().addWME(siuWME);
			log.info(myName+ " added executing SiuWME for " +siuNameGroupSmalltalk);
		}
		
		spawngoal SIU_groupSmalltalk(siuWME);		
	}
	
	
   /**
    * testbed_LaunchSIU_briefChat()
    */      
   atomic sequential behavior testbed_LaunchSIU_briefChat(String initiator, String responder, int performancePriority) {
      precondition { siuWME=(SiuWME)
	                  (siuWME.getName().equals(siuNameBriefChat) &&
	                   siuWME.getState()==SiuExecutionState.EXECUTING &&                 
	                   (siuWME.containsCharacter(initiator) || siuWME.containsCharacter(responder))
	                   ) }
        specificity 2;
        mental_act { log.info("## additional request to launch " +siuNameBriefChat+ " for " +initiator+ " and " +responder+ " ignored - one or both already participating in it"); }       
   }

   atomic sequential behavior testbed_LaunchSIU_briefChat(String initiator, String responder, int performancePriority) {
      specificity 1;
      precondition { initiatorCharacterWME=(CharacterWME) (initiatorCharacterWME.getName().equals(initiator)) 
                  responderCharacterWME=(CharacterWME) (responderCharacterWME.getName().equals(responder)) 
                   }
        CharactersWME otherCharactersWME;
        SiuWME siuWME;

        mental_act {                 
         otherCharactersWME = new CharactersWME();
         otherCharactersWME.addCharacter(responderCharacterWME);
         siuWME = new SiuWME(siuNameBriefChat, initiatorCharacterWME, otherCharactersWME);
         siuWME.setState(SiuExecutionState.EXECUTING);
         siuWME.setPerformancePriority(performancePriority);
         BehavingEntity.getBehavingEntity().addWME(siuWME);       
         log.info(initiator+ " added executing SiuWME for " +siuNameBriefChat+ " with " +otherCharactersWME.getSize()+ " responders");
      }
      
      spawngoal SIU_briefChat(siuWME);     
   }


	
	/**
	 * testbed_LaunchSIU_approachGroup()
	 */	 	
	 
	// ignore this request if approacher and approachee are in the same group
	// note this same check occurs in awareness manager, so this code shouldn't actually ever get called
	atomic sequential behavior testbed_LaunchSIU_approachGroup(String approacherName, String approacheeName) {
		precondition {	approacherCharacterWME=(CharacterWME) (approacherCharacterWME.getName().equals(approacherName)) 
						approacheeCharacterWME=(CharacterWME) (approacheeCharacterWME.getName().equals(approacheeName)) 
                     	groupWME=(GroupWME) 
                     	(groupWME.contains(approacherCharacterWME) &&
                     	groupWME.contains(approacheeCharacterWME))
                     }
        specificity 2;
        mental_act { log.info("## " +approacheeName+ " additional request to launch " +siuNameApproach+ 
        						" for " +approacherName+ " ignored - already both in same group"); } 		
	}

	atomic sequential behavior testbed_LaunchSIU_approachGroup(String approacherName, String approacheeName) {
		precondition {	approacherCharacterWME=(CharacterWME) (approacherCharacterWME.getName().equals(approacherName)) 
						approacheeCharacterWME=(CharacterWME) (approacheeCharacterWME.getName().equals(approacheeName)) 
                     	groupWME=(GroupWME) (groupWME.contains(approacheeCharacterWME))
                     }
        specificity 1;
        CharactersWME otherCharactersWME;
        SiuWME siuWME;

		// if approacher is approaching a new group, end all SIUs with any previous group
		// needed to avoid having to write context conditions on all SIUs to fail when approacher leaves any previous group, in a moment
		with (ignore_failure) subgoal siu_requestTerminationAllOfSIUsWith(approacherName);

        // JOIN THE GROUP as an approaching character!
		subgoal exclusivelyJoinGroup(approacherCharacterWME, groupWME);

        mental_act {        
        	groupWME.addApproachingCharacter(approacherCharacterWME);
        
        	otherCharactersWME = GroupUtil.cloneAndRemoveSelf(approacherName, groupWME.getFormationCharactersWME());
        	
			siuWME = new SiuWME(siuNameApproach, approacherCharacterWME, otherCharactersWME);
			siuWME.setState(SiuExecutionState.EXECUTING);
			BehavingEntity.getBehavingEntity().addWME(siuWME);			
			log.info(approacherName+ " added executing SiuWME for " +siuNameApproach+ " with " +otherCharactersWME.getSize()+ " responders");
		}
		
		spawngoal SIU_approach(siuWME);		
	}
	

	
   /**
    * testbed_LaunchSIU_giveObject()
    */      
   atomic sequential behavior testbed_LaunchSIU_giveObject(String giverName, String receiverName) {
      precondition { siuWME=(SiuWME)
                  (siuWME.getName().equals(siuNameGiveObject) &&
                   siuWME.getState()==SiuExecutionState.EXECUTING &&                 
                   siuWME.containsCharacter(receiverName)) }
        specificity 2;
        mental_act { log.info("## " +giverName+ " additional request to launch " +siuNameGiveObject+ " for " +receiverName+ " ignored - already participating in it"); }       
   }

   atomic sequential behavior testbed_LaunchSIU_giveObject(String giverName, String receiverName) {
      precondition { giverCharacterWME=(CharacterWME) (giverCharacterWME.getName().equals(giverName)) 
                  receiverCharacterWME=(CharacterWME) (receiverCharacterWME.getName().equals(receiverName)) 
                   }
        specificity 1;
        CharactersWME otherCharactersWME;
        SiuWME siuWME;

        mental_act {        
         
         otherCharactersWME = new CharactersWME();//GroupUtil.cloneAndRemoveSelf(giverName, groupWME.getFormationCharactersWME());
         otherCharactersWME.addCharacter(receiverCharacterWME);
         siuWME = new SiuWME(siuNameGiveObject, giverCharacterWME, otherCharactersWME);
         siuWME.setState(SiuExecutionState.EXECUTING);
         BehavingEntity.getBehavingEntity().addWME(siuWME);       
         log.info(giverName+ " added executing SiuWME for " +siuNameGiveObject+ " with " +otherCharactersWME.getSize()+ " responders");
      }
      
      spawngoal SIU_giveObject(siuWME);     
   }
	
	
   /**
    * testbed_LaunchSIU_takeObjectFromPlayer()
    */      
   atomic sequential behavior testbed_LaunchSIU_takeObjectFromPlayer(String giverName, String receiverName) {
      precondition { siuWME=(SiuWME)
                  (siuWME.getName().equals(siuNameTakeObjectFromPlayer) &&
                   siuWME.getState()==SiuExecutionState.EXECUTING &&                 
                   siuWME.containsCharacter(receiverName)) }
        specificity 2;
        mental_act { log.info("## " +giverName+ " additional request to launch " +siuNameTakeObjectFromPlayer+ " for " +receiverName+ " ignored - already participating in it"); }       
   }

   atomic sequential behavior testbed_LaunchSIU_takeObjectFromPlayer(String giverName, String receiverName) {
      precondition { giverCharacterWME=(CharacterWME) (giverCharacterWME.getName().equals(giverName)) 
                  receiverCharacterWME=(CharacterWME) (receiverCharacterWME.getName().equals(receiverName)) 
                   }
        specificity 1;
        CharactersWME otherCharactersWME;
        SiuWME siuWME;

        mental_act {        
         
         otherCharactersWME = new CharactersWME();//GroupUtil.cloneAndRemoveSelf(giverName, groupWME.getFormationCharactersWME());
         otherCharactersWME.addCharacter(receiverCharacterWME);
         siuWME = new SiuWME(siuNameTakeObjectFromPlayer, giverCharacterWME, otherCharactersWME);
         siuWME.setState(SiuExecutionState.EXECUTING);
         BehavingEntity.getBehavingEntity().addWME(siuWME);       
         log.info(giverName+ " added executing SiuWME for " +siuNameTakeObjectFromPlayer+ " with " +otherCharactersWME.getSize()+ " responders");
      }
      
      spawngoal SIU_takeObjectFromPlayer(siuWME);
   }
   
	/**
     * testbed_LaunchSIU_giveObjectToPlayer()
     */      
	atomic sequential behavior testbed_LaunchSIU_giveObjectToPlayer(String giverName, String receiverName) {
      precondition { siuWME=(SiuWME)
                  (siuWME.getName().equals(siuNameGiveObjectToPlayer) &&
                   siuWME.getState()==SiuExecutionState.EXECUTING &&                 
                   siuWME.containsCharacter(receiverName)) }
        specificity 2;
        mental_act { log.info("## " +giverName+ " additional request to launch " +siuNameGiveObjectToPlayer+ " for " +receiverName+ " ignored - already participating in it"); }       
	}

	atomic sequential behavior testbed_LaunchSIU_giveObjectToPlayer(String giverName, String receiverName) {
      precondition { giverCharacterWME=(CharacterWME) (giverCharacterWME.getName().equals(giverName)) 
                  receiverCharacterWME=(CharacterWME) (receiverCharacterWME.getName().equals(receiverName)) 
                   }
        specificity 1;
        CharactersWME otherCharactersWME;
        SiuWME siuWME;

        mental_act {        
         
         otherCharactersWME = new CharactersWME();
         otherCharactersWME.addCharacter(receiverCharacterWME);
         siuWME = new SiuWME(siuNameGiveObjectToPlayer, giverCharacterWME, otherCharactersWME);
         siuWME.setState(SiuExecutionState.EXECUTING);
         BehavingEntity.getBehavingEntity().addWME(siuWME);       
         log.info(giverName+ " added executing SiuWME for " +siuNameGiveObjectToPlayer+ " with " +otherCharactersWME.getSize()+ " responders");
      }
      
      spawngoal SIU_giveObjectToPlayer(siuWME);
   }

	
   /**
    * testbed_LaunchSIU_studyOwnObject()
    */      
   atomic sequential behavior testbed_LaunchSIU_studyOwnObject(String myName, String giverName) {
      precondition { siuWME=(SiuWME)
                  (siuWME.getName().equals(siuNameStudyOwnObject) &&
                   siuWME.getState()==SiuExecutionState.EXECUTING &&                 
                   siuWME.containsCharacter(myName)) }
        specificity 2;
        mental_act { log.info("## " +myName+ " additional request to launch " +siuNameStudyOwnObject+ " ignored - already participating in it"); }       
   }

   atomic sequential behavior testbed_LaunchSIU_studyOwnObject(String myName, String giverName) {
      precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName))
      					giverCharacterWME=(CharacterWME) (giverCharacterWME.getName().equals(giverName)) 
                   }
        specificity 1;
        CharactersWME otherCharactersWME;
        SiuWME siuWME;

        mental_act {        
         otherCharactersWME = new CharactersWME();
         otherCharactersWME.addCharacter(giverCharacterWME);
         siuWME = new SiuWME(siuNameStudyOwnObject, myCharacterWME, otherCharactersWME);
         siuWME.setState(SiuExecutionState.EXECUTING);
         BehavingEntity.getBehavingEntity().addWME(siuWME);       
         log.info(myName+ " added executing SiuWME for " +siuNameStudyOwnObject+ " with " +otherCharactersWME.getSize()+ " responders");
      }
      
      spawngoal SIU_studyOwnObject(siuWME);
   }

	
   /**
    * testbed_LaunchSIU_requestObject()
    */      
   atomic sequential behavior testbed_LaunchSIU_requestObject(String myName, String requesteeName) {
      precondition { siuWME=(SiuWME)
                  (siuWME.getName().equals(siuNameRequestObject) &&
                   siuWME.getState()==SiuExecutionState.EXECUTING &&                 
                   siuWME.containsCharacter(myName)) }
        specificity 2;
        mental_act { log.info("## " +myName+ " additional request to launch " +siuNameRequestObject+ " ignored - already participating in it"); }       
   }

   atomic sequential behavior testbed_LaunchSIU_requestObject(String myName, String requesteeName) {
      precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName))
      					requesteeCharacterWME=(CharacterWME) (requesteeCharacterWME.getName().equals(requesteeName)) 
                   }
        specificity 1;
        CharactersWME otherCharactersWME;
        SiuWME siuWME;

        mental_act {        
         otherCharactersWME = new CharactersWME();
         otherCharactersWME.addCharacter(requesteeCharacterWME);
         siuWME = new SiuWME(siuNameRequestObject, myCharacterWME, otherCharactersWME);
         siuWME.setState(SiuExecutionState.EXECUTING);
         BehavingEntity.getBehavingEntity().addWME(siuWME);       
         log.info(myName+ " added executing SiuWME for " +siuNameRequestObject+ " with " +otherCharactersWME.getSize()+ " responders");
      }
      
      spawngoal SIU_requestObject(siuWME);
   }


	/**
	 * testbed_LaunchSIU_groupMirror()
	 */	 	
	atomic sequential behavior testbed_LaunchSIU_groupMirror(String myName, GroupWME groupWME, SocialInterpretation interpretation, String gestureName) {
		precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName))
                     }
        CharactersWME otherCharactersWME;
        SiuWME siuWME;

        mental_act {        
        	otherCharactersWME = GroupUtil.cloneAndRemoveSelf(myName, groupWME.getFormationCharactersWME());
			//log.info(myName+ " about to add SiuWME with " +otherCharactersWME.getSize()+ " responders");
        	
			siuWME = new SiuWME(siuNameGroupMirror, myCharacterWME, otherCharactersWME);
			siuWME.setState(SiuExecutionState.EXECUTING);
			
			// custom state for this SIU
			siuWME.setParamInterpretation(interpretation);
			siuWME.setParamGestureName(gestureName);
			
			BehavingEntity.getBehavingEntity().addWME(siuWME);
			log.info(myName+ " added executing SiuWME for " +siuNameGroupMirror+ " with " +otherCharactersWME.getSize()+ " responders");
		}
		
		spawngoal SIU_groupMirror(siuWME);		
	}


	/**
	 * testbed_LaunchSIU_groupBriefAttention()
	 */	 	
	atomic sequential behavior testbed_LaunchSIU_groupBriefAttention(String myName, GroupWME groupWME, String eventType, String pointTarget) {
		precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName))
                     }
        CharactersWME otherCharactersWME;
        SiuWME siuWME;

        mental_act {        
        	otherCharactersWME = GroupUtil.cloneAndRemoveSelf(myName, groupWME.getFormationCharactersWME());
			//log.info(myName+ " about to add SiuWME with " +otherCharactersWME.getSize()+ " responders");
        	
			siuWME = new SiuWME(siuNameGroupBriefAttention, myCharacterWME, otherCharactersWME);
			siuWME.setState(SiuExecutionState.EXECUTING);
			
			// custom state for this SIU
			siuWME.setParamType(eventType);
			if (eventType.equals(eventParam_attention_point)) {
				siuWME.setParamString(pointTarget);
			}
			
			BehavingEntity.getBehavingEntity().addWME(siuWME);
			log.info(myName+ " added executing SiuWME for " +siuNameGroupBriefAttention+ " with " +otherCharactersWME.getSize()+ " responders");
		}
		
		spawngoal SIU_groupBriefAttention(siuWME);		
	}


	/**
	 * testbed_LaunchSIU_personalSpace()
	 */	 	
	atomic sequential behavior testbed_LaunchSIU_personalSpace(String myName, CharacterWME recipientCharacterWME/*GroupWME groupWME*/, SocialInterpretation interpretation) {
		precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName))
                     }
        CharactersWME otherCharactersWME;
        SiuWME siuWME;

        mental_act {        
        	//otherCharactersWME = GroupUtil.cloneAndRemoveSelf(myName, groupWME.getFormationCharactersWME());
        	otherCharactersWME = new CharactersWME();
        	otherCharactersWME.addCharacter(recipientCharacterWME);
			//log.info(myName+ " about to add SiuWME with " +otherCharactersWME.getSize()+ " responders");
        	
			siuWME = new SiuWME(siuNamePersonalSpace, myCharacterWME, otherCharactersWME);
			siuWME.setState(SiuExecutionState.EXECUTING);
			
			BehavingEntity.getBehavingEntity().addWME(siuWME);
			log.info(myName+ " added executing SiuWME for " +siuNamePersonalSpace+ " with " +otherCharactersWME.getSize()+ " responders");
		}
		
		spawngoal SIU_personalSpace(siuWME);		
	}


	/**
	 * testbed_LaunchSIU_groupStudyObject()
	 */	 	
	atomic sequential behavior testbed_LaunchSIU_groupStudyObject(String myName, GroupWME groupWME) {
		precondition {	siuWME=(SiuWME)
						(siuWME.getName().equals(siuNameGroupStudyObject) &&
						 siuWME.getState()==SiuExecutionState.EXECUTING &&						 
						 siuWME.containsCharacter(myName)) }
        specificity 2;
        mental_act { log.info("## " +myName+ " additional request to launch " +siuNameGroupStudyObject+ " ignored - already participating in it"); }       
	}

	atomic sequential behavior testbed_LaunchSIU_groupStudyObject(String myName, GroupWME groupWME) {
		precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName))
                     }
        CharactersWME otherCharactersWME;
        SiuWME siuWME;

        mental_act {        
        	otherCharactersWME = GroupUtil.cloneAndRemoveSelf(myName, groupWME.getFormationCharactersWME());
			//log.info(myName+ " about to add SiuWME with " +otherCharactersWME.getSize()+ " responders");
        	
			siuWME = new SiuWME(siuNameGroupStudyObject, myCharacterWME, otherCharactersWME);
			siuWME.setState(SiuExecutionState.EXECUTING);
			BehavingEntity.getBehavingEntity().addWME(siuWME);
			log.info(myName+ " added executing SiuWME for " +siuNameGroupStudyObject+ " with " +otherCharactersWME.getSize()+ " responders");
		}
		
		spawngoal SIU_groupStudyObject(siuWME);		
	}




	/**
	 * testbed_LaunchSIU_groupPassObject()
	 */	 	
	atomic sequential behavior testbed_LaunchSIU_groupPassObject(String myName) {
		precondition {	siuWME=(SiuWME)
						(siuWME.getName().equals(siuNameGroupPassObject) &&
						 siuWME.getState()==SiuExecutionState.EXECUTING &&						 
						 siuWME.containsCharacter(myName)) }
        specificity 2;
        mental_act { log.info("## " +myName+ " additional request to launch " +siuNameGroupPassObject+ " ignored - already participating in it"); }       
	}
	
	sequential behavior testbed_LaunchSIU_groupPassObject(String myName) {
		precondition { myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) }
        specificity 1;
        SiuWME siuWME;

        mental_act {        
			siuWME = new SiuWME(siuNameGroupPassObject, myCharacterWME);
			siuWME.setState(SiuExecutionState.EXECUTING);
			BehavingEntity.getBehavingEntity().addWME(siuWME);
			log.info(myName+ " added executing SiuWME for " +siuNameGroupPassObject+ " with " +myName);
		}
		
		spawngoal SIU_groupPassObject(siuWME, myName);		
	}	
	


	/**
	 * testbed_LaunchSIU_groupConfused()
	 */	 	
	atomic sequential behavior testbed_LaunchSIU_groupConfused(String myName, GroupWME groupWME, String excludeFixme) {
		precondition {	siuWME=(SiuWME)
						(siuWME.getName().equals(siuNameGroupConfused) &&
						 siuWME.getState()==SiuExecutionState.EXECUTING &&						 
						 siuWME.containsCharacter(myName)) }
        specificity 2;
        mental_act { log.info("## " +myName+ " additional request to launch " +siuNameGroupConfused+ " ignored - already participating in it"); }       
	}

	atomic sequential behavior testbed_LaunchSIU_groupConfused(String myName, GroupWME groupWME, String excludeFixme) {
		precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName))
                     }
        specificity 1;
        CharactersWME otherCharactersWME;
        SiuWME siuWME;

        mental_act {        
        	otherCharactersWME = GroupUtil.cloneAndRemoveSelf(myName, groupWME.getFormationCharactersWME());
        	
        	//fixme - exclude this character
        	// better solution is a way to remove a single NPC from an SIU in realtime
        	otherCharactersWME.removeCharacter(excludeFixme);
        	
			//log.info(myName+ " about to add SiuWME with " +otherCharactersWME.getSize()+ " responders");
        	
			siuWME = new SiuWME(siuNameGroupConfused, myCharacterWME, otherCharactersWME);
			siuWME.setState(SiuExecutionState.EXECUTING);
			BehavingEntity.getBehavingEntity().addWME(siuWME);
			log.info(myName+ " added executing SiuWME for " +siuNameGroupConfused+ " with " +otherCharactersWME.getSize()+ " responders");
		}
		
		spawngoal SIU_groupConfused(siuWME);		
	}



	/**
	 * testbed_LaunchSIU_groupReactToQuestion()
	 */	 	
	atomic sequential behavior testbed_LaunchSIU_groupReactToQuestion(String myName, GroupWME groupWME) {
		precondition {	siuWME=(SiuWME)
						(siuWME.getName().equals(siuNameGroupReactToQuestion) &&
						 siuWME.getState()==SiuExecutionState.EXECUTING &&						 
						 siuWME.containsCharacter(myName)) }
        specificity 2;
        mental_act { log.info("## " +myName+ " additional request to launch " +siuNameGroupReactToQuestion+ " ignored - already participating in it"); }       
	}

	atomic sequential behavior testbed_LaunchSIU_groupReactToQuestion(String myName, GroupWME groupWME) {
		precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName))
                     }
        specificity 1;
        CharactersWME otherCharactersWME;
        SiuWME siuWME;

        mental_act {        
        	otherCharactersWME = GroupUtil.cloneAndRemoveSelf(myName, groupWME.getFormationCharactersWME());
			//log.info(myName+ " about to add SiuWME with " +otherCharactersWME.getSize()+ " responders");
        	
			siuWME = new SiuWME(siuNameGroupReactToQuestion, myCharacterWME, otherCharactersWME);
			siuWME.setState(SiuExecutionState.EXECUTING);
			BehavingEntity.getBehavingEntity().addWME(siuWME);
			log.info(myName+ " added executing SiuWME for " +siuNameGroupReactToQuestion+ " with " +otherCharactersWME.getSize()+ " responders");
		}
		
		spawngoal SIU_groupReactToQuestion(siuWME);		
	}


	/**
	 * testbed_LaunchSIU_groupReactToAppeal()
	 */	 	
	atomic sequential behavior testbed_LaunchSIU_groupReactToAppeal(String myName, String responder, GroupWME groupWME) {
		precondition {	siuWME=(SiuWME)
						(siuWME.getName().equals(siuNameGroupReactToAppeal) &&
						 siuWME.getState()==SiuExecutionState.EXECUTING &&						 
						 siuWME.containsCharacter(myName)) }
        specificity 2;
        mental_act { log.info("## " +myName+ " additional request to launch " +siuNameGroupReactToAppeal+ " ignored - already participating in it"); }       
	}

	atomic sequential behavior testbed_LaunchSIU_groupReactToAppeal(String myName, String responder, GroupWME groupWME) {
		precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName))
	                  	responderCharacterWME=(CharacterWME) (responderCharacterWME.getName().equals(responder)) 
                     }
        specificity 1;
        CharactersWME otherCharactersWME;
        SiuWME siuWME;

        mental_act {        
        	otherCharactersWME = GroupUtil.cloneAndRemoveSelf(myName, groupWME.getFormationCharactersWME());
			//log.info(myName+ " about to add SiuWME with " +otherCharactersWME.getSize()+ " responders");
        	
			siuWME = new SiuWME(siuNameGroupReactToAppeal, myCharacterWME, otherCharactersWME);
			
			// Set responder
        	siuWME.setPrimaryResponder(responderCharacterWME);
        	
			siuWME.setState(SiuExecutionState.EXECUTING);
			BehavingEntity.getBehavingEntity().addWME(siuWME);
			log.info(myName+ " added executing SiuWME for " +siuNameGroupReactToAppeal+ " with " +otherCharactersWME.getSize()+ " responders");
		}
		
		spawngoal SIU_groupReactToAppeal(siuWME);		
	}


	/**
	 * testbed_LaunchSIU_groupAnswerQuestion()
	 */	 	
	atomic sequential behavior testbed_LaunchSIU_groupAnswerQuestion(String questionerName, String answererName, GroupWME groupWME) {
		precondition {	siuWME=(SiuWME)
						(siuWME.getName().equals(siuNameGroupAnswerQuestion) &&
						 siuWME.getState()==SiuExecutionState.EXECUTING &&						 
						 siuWME.containsCharacter(questionerName)) }
        specificity 2;
        mental_act { log.info("## " +questionerName+ " additional request to launch " +siuNameGroupAnswerQuestion+ " ignored - already participating in it"); }       
	}

	atomic sequential behavior testbed_LaunchSIU_groupAnswerQuestion(String questionerName, String answererName, GroupWME groupWME) {
		precondition {	questionerCharacterWME=(CharacterWME) (questionerCharacterWME.getName().equals(questionerName))
						answererCharacterWME=(CharacterWME) (answererCharacterWME.getName().equals(answererName))
                     }
        specificity 1;
        CharactersWME otherCharactersWME;
        SiuWME siuWME;

        mental_act {        
        	otherCharactersWME = GroupUtil.cloneAndRemoveSelf(questionerName, groupWME.getFormationCharactersWME());
			//log.info(questionerName+ " about to add SiuWME with " +otherCharactersWME.getSize()+ " responders");
        	
			siuWME = new SiuWME(siuNameGroupAnswerQuestion, questionerCharacterWME, otherCharactersWME);
			
			// Set answerer
        	siuWME.setPrimaryResponder(answererCharacterWME);
        	
			siuWME.setState(SiuExecutionState.EXECUTING);
			BehavingEntity.getBehavingEntity().addWME(siuWME);
			log.info(questionerName+ " added executing SiuWME for " +siuNameGroupAnswerQuestion+ " with " +otherCharactersWME.getSize()+ " responders");
		}
		
		spawngoal SIU_groupAnswerQuestion(siuWME);		
	}

	
	
	/**
	 * SIU_approach()
	 */	 	
	sequential behavior SIU_approach(SiuWME siuWME) {
		CharacterWME initiator;
		CharactersWME responders;
		String initiatorName;
		
		mental_act {
			log.info("### " +siuWME.getInitiator().getName()+ " starting " +siuNameApproach+ " with " +siuWME.getResponders().getCharacterWMEs().size()+ " responders");
			
			initiator = siuWME.getInitiator();
			initiatorName = initiator.getName(); 
			responders = siuWME.getResponders(); 
		}
		
		subgoal OfferExpectationsForSIU(siuWME);
		
		with (ignore_failure)
			subgoal SIU_approach_root(siuWME, initiatorName, responders);
			
		subgoal ClearExpectationsForSIU(siuWME);		
		subgoal testbed_endSIU(siuWME);
	}
	
	// short circuit if there are no responders	
	parallel behavior SIU_approach_root(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		precondition { (responders.getSize() == 0) }
		specificity 3;
		mental_act {
			log.info(initiatorName+ " will skip " +siuNameApproach+ ", no one in group to approach");
		}
	}
	

	parallel behavior SIU_approach_root(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		context_condition { (siuWME.getState()==SiuExecutionState.EXECUTING) } 			
		specificity 1;
		Collection responderCharacters;
		Iterator respondersIterator;
		
		with (priority_modifier 1) mental_act {
			responderCharacters = responders.getCharacterWMEs();
			respondersIterator = responderCharacters.iterator();
		}
	
		// ## INITIATOR
		subgoal SIU_approach_initiator(siuWME, initiatorName, responders);
		
		// ## LAUNCH ALL RESPONDERS				
		with (ignore_failure) 
			subgoal SIU_approach_root_responders_launch(siuWME, initiatorName, respondersIterator);
				
		// ## MONITOR END CONDITIONS
		subgoal SIU_approach_monitorEndConditions(siuWME, initiatorName, responders);			
	}

	
	sequential behavior SIU_approach_root_responders_launch(SiuWME siuWME, String initiatorName, Iterator respondersIterator) {
		with (persistent when_succeeds)
			subgoal SIU_approach_root_responders_launchLoop(siuWME, initiatorName, respondersIterator);
	}

	sequential behavior SIU_approach_root_responders_launchLoop(SiuWME siuWME, String initiatorName, Iterator respondersIterator) {
		precondition {	(respondersIterator.hasNext()) 
						parentBehavior = (ParallelBehaviorWME signature == "SIU_approach_root(SiuWME, String, CharactersWME)") }
		CharacterWME responderCharacterWME;
		String responderName;
		mental_act { 
			responderCharacterWME = respondersIterator.next();
			responderName = responderCharacterWME.getName();
			log.info("### " +responderCharacterWME.getName()+ " participating in " +siuNameApproach+ " started by " +initiatorName);
		}
		
		with (effect_only) 
			spawngoal SIU_approach_responder(siuWME, initiatorName, responderName) at parentBehavior;
	}


	/**
	 * ## INITIATOR ##
	 */	 	

	sequential behavior SIU_approach_initiator(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		subgoal createEpisodicMemoryWME(initiatorName, siuNameApproach);
		
		subgoal waitFor(500);	// fixme: needed to give time for responder behaviors to take root in root parallel behavior, otherwise the SIU will complete prematurely!
				
        subgoal performanceCleanupForSiu(siuWME, initiatorName);
	}
	
	
	/**
	 * ## RESPONDER ##
	 */	 	
		
	sequential behavior SIU_approach_responder(SiuWME siuWME, String initiatorName, String responderName) {
		precondition {	initiatorCharacterWME=(CharacterWME) (initiatorCharacterWME.getName().equals(initiatorName)) 
						responderCharacterWME=(CharacterWME) (responderCharacterWME.getName().equals(responderName)) 
						groupWME=(GroupWME) (groupWME.contains(responderCharacterWME))
						} 
		PerformanceWME performanceWME;
		String performanceName;
		boolean bAddedInitiatorToGroup;
		
		// ## MedHigh: Acknowledge approacher
		mental_act {
			performanceWME = new PerformanceWME(siuWME);
			performanceName = siuNameApproach + "_acknowledge";
		}
		subgoal setupPerformanceWME(performanceWME, siuWME, responderName, cPerformancePriorityMedHigh, performanceName);
		with (persistent when_fails) subgoal SIU_approach_responder_acknowledge(initiatorName, responderName, performanceWME);
		subgoal performanceDoneDeleteWME(performanceWME);


		// ## MedHigh: Possibly add approacher to group
		// ## hostile group wants to quickly get into a formation to best deal with approacher 
		mental_act {		
			bAddedInitiatorToGroup = false;
			if (responderCharacterWME.hasAttitude(eAttitudeType_hostile)) {
				bAddedInitiatorToGroup = true;
			}
		} 
		with (ignore_failure) subgoal addCharacterToFormation(initiatorCharacterWME, groupWME, bAddedInitiatorToGroup);
		// not needed anymore, now that formation is higher priority 
		//with (ignore_failure) subgoal SIU_approach_responder_updateFormation(siuWME, responderCharacterWME, groupWME, bAddedInitiatorToGroup);

						
		// ## MedMedLow: Idle and wait for signal from approacher
		mental_act {
			performanceWME = new PerformanceWME(siuWME);
			performanceName = siuNameApproach + "_idleWait";
		}
		subgoal setupPerformanceWME(performanceWME, siuWME, responderName, cPerformancePriorityMedMedLow, performanceName);
		with (persistent /*when_fails*/) subgoal SIU_approach_responder_idleWait(initiatorName, responderName, performanceWME);
		subgoal performanceDoneDeleteWME(performanceWME);
			
		// ## Done
        subgoal performanceCleanupForSiu(siuWME, responderName);
	}
	
	
	/**
	 * Responder: acknowledge
	 */	 		
	sequential behavior SIU_approach_responder_acknowledge(String initiatorName, String responderName, PerformanceWME performanceWME) {
		subgoal performanceWait(performanceWME);
		subgoal SIU_approach_responder_acknowledge_perform(initiatorName, responderName, performanceWME);
	}

	sequential behavior SIU_approach_responder_acknowledge_perform(String initiatorName, String responderName, PerformanceWME performanceWME) {
		context_condition {	(performanceWME.getPerformanceState() == cPerformanceStatePerforming) }
		precondition {	initiatorPhysicalWME = (PhysicalAgentWME)
                     	(initiatorPhysicalWME.getId().equals(initiatorName))
						}
		float durationIdleAnimPre1;
		
		subgoal createEpisodicMemoryWME(responderName, initiatorName, siuNameApproach);

		mental_act { 
			durationIdleAnimPre1 = (float)Staging.randRange(0.5, 1.5); // (float)Staging.randRange(1.5, 3.0); //retValWME.getFloat(); 
		}
				
		// fixme: need to stop audio!
		
		// look at initiator and idle for a moment
		subgoal headTrack(responderName, initiatorName);
		subgoal performWithAttitude(responderName, eAttitudePerform_listen, durationIdleAnimPre1);
				
		// headNod layering doesn't work well
		//subgoal headNod(headNodAnim, responderName, initiatorName, idleAnim, cAnimDefaultStartTime, durationIdleAnim);
		// instead play the headNod directly
		//subgoal headTrack(responderName, initiatorName);
		//subgoal performAnimation_portion(responderName, responderName, headNodAnim, cAnimDefaultStartTime, durationHeadNodAnim);
	}
	
	
	/**
	 * Responder: updateFormation
	 */	 		
	sequential behavior SIU_approach_responder_updateFormation(SiuWME siuWME, CharacterWME responderCharacterWME, GroupWME groupWME, boolean bAddedInitiatorToGroup) {
		precondition { (bAddedInitiatorToGroup == true) }
		subgoal testbed_joinAndMaintainFormation_moveToFormationPoint(siuWME, responderCharacterWME, groupWME, cPerformancePriorityMedHigh);
	}		

		
	/**
	 * Responder: idleWait
	 */	 		
	sequential behavior SIU_approach_responder_idleWait(String initiatorName, String responderName, PerformanceWME performanceWME) {
		subgoal performanceWait(performanceWME);
		subgoal SIU_approach_responder_idleWait_perform(initiatorName, responderName, performanceWME);		
	}

	sequential behavior SIU_approach_responder_idleWait_perform(String initiatorName, String responderName, PerformanceWME performanceWME) {
		precondition { myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(responderName)) } 
		context_condition {	(performanceWME.getPerformanceState() == cPerformanceStatePerforming) }
		specificity 2;				
		boolean bHostile;
		
		mental_act { 
			bHostile = myCharacterWME.hasAttitude(eAttitudeType_hostile);
		}
		
		subgoal headTrack(responderName, initiatorName);
		
		with (ignore_failure)
			subgoal SIU_approach_responder_idleWait_perform_facing(initiatorName, responderName, bHostile); 
				
		subgoal SIU_approach_responder_idleWait_perform_par(initiatorName, responderName); 
	}

	sequential behavior SIU_approach_responder_idleWait_perform_facing(String initiatorName, String responderName, boolean bHostile) {
		precondition { 	initiatorPhysicalWME=(PhysicalAgentWME) (initiatorPhysicalWME.getId().equals(initiatorName))
						responderPhysicalWME=(PhysicalAgentWME) (responderPhysicalWME.getId().equals(responderName))
						(bHostile == true
						
							// if facing away from player too much, turn to face player
							// || (Math.abs(Staging.getDiffBetweenAngleAndOrientation(responderName,
							//													initiatorPhysicalWME.getLocation(), responderPhysicalWME.getLocation(),
							//													responderPhysicalWME.getOrientation())) < 30)
							)
                     	}
                     	
		Location initiatorPt;
		mental_act { initiatorPt = initiatorPhysicalWME.getLocation(); } 			
		subgoal turnToFacingPoint(responderName, initiatorPt);
	}

	parallel behavior SIU_approach_responder_idleWait_perform_par(String initiatorName, String responderName) {
		subgoal performWithAttitude(responderName, eAttitudePerform_listen, cAttitudeDefaultDuration);
		with (persistent, effect_only) subgoal SIU_approach_responder_idleWait_glances(initiatorName, responderName);
		with (persistent) subgoal SIU_approach_responder_possiblySpawnABriefChat(responderName);
	}	
	
	sequential behavior SIU_approach_responder_idleWait_perform(String initiatorName, String responderName, PerformanceWME performanceWME) {
		specificity 1;
		fail_step;
	}	
	
	sequential behavior SIU_approach_responder_idleWait_glances(String initiatorName, String responderName) {
		with (ignore_failure) subgoal SIU_approach_responder_idleWait_glanceAtGroup(responderName);
		mental_act { log.info(responderName+ " SIU_approach_responder_idleWait_glances " +initiatorName); }
		subgoal headTrack(responderName, initiatorName);
		subgoal waitForRand(1500, 4000); 
	}

	sequential behavior SIU_approach_responder_idleWait_glanceAtGroup(String responderName) {
		precondition {	(Staging.percentChance(15))
						responderCharacterWME=(CharacterWME) (responderCharacterWME.getName().equals(responderName)) 
						groupWME=(GroupWME) (groupWME.contains(responderCharacterWME))
						}		
		String targetName;
		mental_act { 
			CharacterWME characterWME;
			characterWME = groupWME.getRandomFormationCharacterWME();
			targetName = characterWME.getName();
			log.info(responderName+ " SIU_approach_responder_idleWait_glanceAtGroup " +targetName);
		}
		subgoal headTrack(responderName, targetName);
		
		subgoal waitForRand(600, 1500); 
	}
	
	
	/*
	 * SIU_approach_responder_possiblySpawnABriefChat
	 */
	 
	sequential behavior SIU_approach_responder_possiblySpawnABriefChat(String myName) {
		subgoal waitForRand(2000, 4000);
		with (ignore_failure) 
			subgoal testbed_cif_possiblySpawnABriefChat(myName, false, 7, cPerformancePriorityMedMedHigh); // so can override approach 	
	}
	
	
	/**
	 * SIU_approach_monitorEndConditions()
	 */	 	
	sequential behavior SIU_approach_monitorEndConditions(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		subgoal SIU_approach_monitorEndConditions_main(initiatorName, responders);
		subgoal siu_requestTermination(siuWME);
	}
	
	parallel behavior SIU_approach_monitorEndConditions_main(String initiatorName, CharactersWME responders) {
		number_needed_for_success 1;
		
		subgoal SIU_approach_monitor_initiatorDistance(initiatorName, responders);
	}
	
	sequential behavior SIU_approach_monitor_initiatorDistance(String initiatorName, CharactersWME responders) {
		precondition {	groupWME=(GroupWME) 
						(groupWME.containsAny(responders))
						}
						
		PhysicalAgentWME initiatorPhysicalWME;
		with (success_test {
						initiatorPhysicalWME=(PhysicalAgentWME)
                     	(initiatorPhysicalWME.getId().equals(initiatorName))
                     	(Staging.getXZDistanceBetweenPoints(initiatorPhysicalWME.getLocation(), 
                     											groupWME.getOrigin()) 
                     										> cFarAwarenessDistance)
			} ) wait;
			
		mental_act { 
			log.info("## " +initiatorName+ " has moved too far from group during " +siuNameApproach); 
			log.info("initiator location " +initiatorPhysicalWME.getLocation()); 
			log.info("group location " +groupWME.getOrigin()); 
		} 
	}
	
	
	
	
	/**
	 * SIU_briefChat()
	 */	 	
	sequential behavior SIU_briefChat(SiuWME siuWME) {
		CharacterWME initiator;
		CharactersWME responders;
		String initiatorName;
		
		mental_act {
			log.info("### " +siuWME.getInitiator().getName()+ " starting " +siuNameBriefChat+ " with " +siuWME.getResponders().getCharacterWMEs().size()+ " responders");
			initiator = siuWME.getInitiator();
			initiatorName = initiator.getName(); 
			responders = siuWME.getResponders(); 
			
			// should we do a longer chat
			siuWME.setParamBoolean(Staging.percentChance(70));
		}
		
		with (ignore_failure)
			subgoal SIU_briefChat_root(siuWME, initiatorName, responders);
		
		subgoal testbed_endSIU(siuWME);
	}
	
	parallel behavior SIU_briefChat_root(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		context_condition { (siuWME.getState()==SiuExecutionState.EXECUTING) } 			
		specificity 1;
		Collection responderCharacters;
		Iterator respondersIterator;
		
		with (priority_modifier 1) mental_act {
			responderCharacters = responders.getCharacterWMEs();
			respondersIterator = responderCharacters.iterator();
		}
	
		// ## INITIATOR
		subgoal SIU_briefChat_root_initiator(siuWME, initiatorName, responders);
		
		// ## RESPONDERS				
		with (ignore_failure) 
			subgoal SIU_briefChat_root_responders_launch(siuWME, initiatorName, respondersIterator);
	}

	
	sequential behavior SIU_briefChat_root_responders_launch(SiuWME siuWME, String initiatorName, Iterator respondersIterator) {
		with (persistent when_succeeds)
			subgoal SIU_briefChat_root_responders_launchLoop(siuWME, initiatorName, respondersIterator);
	}

	// spawn into this SIU's root parallel behavior 
	sequential behavior SIU_briefChat_root_responders_launchLoop(SiuWME siuWME, String initiatorName, Iterator respondersIterator) {
		precondition { (respondersIterator.hasNext()) 					
						parentBehavior = (ParallelBehaviorWME signature == "SIU_briefChat_root(SiuWME, String, CharactersWME)") }
		CharacterWME responderCharacterWME;
		mental_act { 
			responderCharacterWME = respondersIterator.next();
			log.info(responderCharacterWME.getName()+ " participating in " +siuNameBriefChat+ " started by " +initiatorName);
		}
		
		spawngoal SIU_briefChat_root_responder(siuWME, initiatorName, responderCharacterWME) at parentBehavior;
	}


	// ---------------------------------------
	// ---------------------------------------

	// ## INITIATOR ##
	
	sequential behavior SIU_briefChat_root_initiator(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		String responderName;
		int performancePriority;
		boolean bLongerChat;		
		mental_act { 
			responderName = responders.get(0).getName();
			performancePriority = siuWME.getPerformancePriority();
			bLongerChat = siuWME.getParamBoolean();
		}
		subgoal createEpisodicMemoryWME(initiatorName, responderName, siuNameBriefChat);
		
		subgoal testbed_briefChat(siuWME, initiatorName, initiatorName, responderName, bLongerChat, performancePriority);
														
		subgoal performanceCleanupForSiu(siuWME, initiatorName);
	}
	
	
	// ## RESPONDER ##

	sequential behavior SIU_briefChat_root_responder(SiuWME siuWME, String initiatorName, CharacterWME responder) {
		String responderName;
		int performancePriority;		
		boolean bLongerChat;		
		mental_act { 
			responderName = responder.getName(); 
			performancePriority = siuWME.getPerformancePriority();
			bLongerChat = siuWME.getParamBoolean();
		} 
		subgoal createEpisodicMemoryWME(responderName, initiatorName, siuNameBriefChat);
		
		subgoal testbed_briefChat(siuWME, responderName, initiatorName, responderName, bLongerChat, performancePriority);
														
		subgoal performanceCleanupForSiu(siuWME, responderName);
	}


	
	/**
	 * SIU_giveObject()
	 */	 	
	sequential behavior SIU_giveObject(SiuWME siuWME) {
		CharacterWME initiator;
		CharactersWME responders;
		String initiatorName;
		
		mental_act {
			log.info("### " +siuWME.getInitiator().getName()+ " starting " +siuNameGiveObject+ " with " +siuWME.getResponders().getCharacterWMEs().size()+ " responders");
			initiator = siuWME.getInitiator();
			initiatorName = initiator.getName(); 
			responders = siuWME.getResponders(); 
		}
		
		with (ignore_failure)
			subgoal SIU_giveObject_root(siuWME, initiatorName, responders);
		
		subgoal testbed_endSIU(siuWME);
	}
	
	parallel behavior SIU_giveObject_root(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		context_condition { (siuWME.getState()==SiuExecutionState.EXECUTING) } 			
		specificity 1;
		Collection responderCharacters;
		Iterator respondersIterator;
		
		with (priority_modifier 1) mental_act {
			responderCharacters = responders.getCharacterWMEs();
			respondersIterator = responderCharacters.iterator();
		}
	
		// ## INITIATOR
		subgoal SIU_giveObject_root_initiator(siuWME, initiatorName, responders);
		
		// ## RESPONDERS				
		with (ignore_failure) 
			subgoal SIU_giveObject_root_responders_launch(siuWME, initiatorName, respondersIterator);
	}

	
	sequential behavior SIU_giveObject_root_responders_launch(SiuWME siuWME, String initiatorName, Iterator respondersIterator) {
		with (persistent when_succeeds)
			subgoal SIU_giveObject_root_responders_launchLoop(siuWME, initiatorName, respondersIterator);
	}

	// spawn into this SIU's root parallel behavior 
	sequential behavior SIU_giveObject_root_responders_launchLoop(SiuWME siuWME, String initiatorName, Iterator respondersIterator) {
		precondition { (respondersIterator.hasNext()) 					
						parentBehavior = (ParallelBehaviorWME signature == "SIU_giveObject_root(SiuWME, String, CharactersWME)") }
		CharacterWME responderCharacterWME;
		mental_act { 
			responderCharacterWME = respondersIterator.next();
			log.info(responderCharacterWME.getName()+ " participating in " +siuNameGiveObject+ " started by " +initiatorName);
		}
		
		spawngoal SIU_giveObject_root_responder(siuWME, initiatorName, responderCharacterWME) at parentBehavior;
	}


	// ---------------------------------------
	// ---------------------------------------

	// ## INITIATOR ##
	
	sequential behavior SIU_giveObject_root_initiator(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		subgoal createEpisodicMemoryWME(initiatorName, siuNameGiveObject);
		subgoal SIU_giveObject_root_initiator_perform(siuWME, initiatorName, responders);
      subgoal performanceCleanupForSiu(siuWME, initiatorName);
	}
	
	// PLAYER INITIATOR
	sequential behavior SIU_giveObject_root_initiator_perform(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		precondition { (initiatorName.equals(playerName) == true) }
		mental_act { log.info(initiatorName+ " performing offering object in SIU_giveObject"); }		
		
		subgoal waitFor(500);	// fixme: needed to give time for responder behaviors to take root in root parallel behavior, otherwise the SIU will complete prematurely!		
	}
	
	// NPC INITIATOR
	sequential behavior SIU_giveObject_root_initiator_perform(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		precondition { (initiatorName.equals(playerName) == false) }
		
		String responderName;
		
		mental_act { 
		   log.info(initiatorName+ " performing offering object in SIU_giveObject");
		   responderName = responders.get(0).getName();
		}
		subgoal testbed_offerObjectToCharacter(siuWME, initiatorName, responderName, cPerformancePriorityHigh);	// high, to override StudyOthersObject		
	}
	
	
	// ## RESPONDER ##

	
	sequential behavior SIU_giveObject_root_responder(SiuWME siuWME, String initiatorName, CharacterWME responder) {
		specificity 1;
		String responderName;
		mental_act { 
			log.info(responder.getName()+ " starting to respond to giveObject from " +initiatorName + " (about to call testbed takeObject)"); 
			responderName = responder.getName(); 
		}

		subgoal createEpisodicMemoryWME(responderName, initiatorName, siuNameGiveObject);
		subgoal testbed_takeObjectFromCharacter(siuWME, responderName, initiatorName, cPerformancePriorityHigh);	// high, to override StudyOthersObject
		
      subgoal performanceCleanupForSiu(siuWME, responderName);
	}


	
	/** (April 4-24-13)
	 * SIU_giveObjectToPlayer()
	 */	 	
	sequential behavior SIU_giveObjectToPlayer(SiuWME siuWME) {
		CharacterWME giver;
		String giverName;
		CharacterWME receiver;
		CharactersWME receivers;
		String receiverName;
		
		mental_act {
			log.info("### " +siuWME.getInitiator().getName()+ " starting " +siuNameGiveObjectToPlayer+ " with " +siuWME.getResponders().getCharacterWMEs().size()+ " givers");

			giver = siuWME.getInitiator();
			giverName = giver.getName();
			receivers = siuWME.getResponders(); 
			receiver = receivers.get(0); // I believe there should only ever be a single receiver here.
			receiverName = receiver.getName(); 
		}
		
		with (ignore_failure)
			subgoal SIU_giveObjectToPlayer_root(siuWME, giverName, receiverName);
		
		subgoal testbed_endSIU(siuWME);
	}

	// The initiator is the NPC that is giving the object to the player.
	// The responder is intended to be the player, the receiver.
	
	// Find the NPC that has the item and make them do the SIU
	sequential behavior SIU_giveObjectToPlayer_specialEntry(SiuWME siuWME) {
		precondition { charWME = (CharacterWME) (charWME.getObjectHeld().equals("") == false)
						(charWME.getName().equals(playerName) == false)}
		specificity 2;
		String giverName;
		mental_act { 
			log.info("Special Entry SIU_giveObjectToplayer");
			giverName = charWME.getName();
		}
		with (ignore_failure) subgoal SIU_giveObjectToPlayer_root(siuWME, giverName, playerName);
	}
	
	sequential behavior SIU_giveObjectToPlayer_specialEntry(SiuWME siuWME) {
		specificity 1;
		mental_act { log.info("ERROR: Don't try to make the player get the object when they already have it!"); }
	}
	
	
	// If an NPC doesn't have an object to give, they can't give it
	parallel behavior SIU_giveObjectToPlayer_root(SiuWME siuWME, String giverName, String receiverName) {
		precondition {  giver=(CharacterWME) (giver.getName().equals(giverName) == true) 	
						(giver.getObjectHeld().equals("") == true) }
		specificity 2;
		mental_act {
			log.info(giverName+ " will skip the " +siuNameGiveObjectToPlayer+ ", does not have an item to give");
		}
	}
	
	parallel behavior SIU_giveObjectToPlayer_root(SiuWME siuWME, String giverName, String receiverName) {
		context_condition { (siuWME.getState()==SiuExecutionState.EXECUTING) } 			
		specificity 1;
	
		mental_act { log.info("SIU_giveObjectToPlayer_root"); }
		
		// ## INITIATOR (giver)
		subgoal SIU_giveObjectToPlayer_root_giver(siuWME, giverName, receiverName);
		
		// ## RESPONDER (receiver)	
		subgoal SIU_giveObjectToPlayer_root_receiver(siuWME, giverName, receiverName);
	}


	// ---------------------------------------
	// ---------------------------------------

	// ## INITIATOR (giver) ##

	sequential behavior SIU_giveObjectToPlayer_root_giver(SiuWME siuWME, String giverName, String receiverName) {
	   precondition { targetPhysicalWME = (PhysicalAgentWME)
	                        (targetPhysicalWME.getId().equals(receiverName))
	      					} 
		Location targetPt;

		mental_act { 
			log.info(giverName+ " participating in giving object to player as giver to " +receiverName); 
			targetPt = targetPhysicalWME.getLocation();
		}
		
		subgoal createEpisodicMemoryWME(giverName, receiverName, siuNameGiveObjectToPlayer);
		
		//fixme: wrap in performanceWME
		subgoal headTrack(giverName, receiverName);		
		subgoal turnToFacingPoint(giverName, targetPt);
		
		subgoal testbed_offerObjectToCharacter(siuWME, giverName, receiverName, cPerformancePriorityHigh);
		
      	subgoal performanceCleanupForSiu(siuWME, giverName);
	}


	// ## RESPONDER (receiver) ##
	
	sequential behavior SIU_giveObjectToPlayer_root_receiver(SiuWME siuWME, String giverName, String receiverName) {
		mental_act { log.info("SIU_giveObjectToPlayer_root_receiver"); }
		subgoal createEpisodicMemoryWME(receiverName, siuNameGiveObjectToPlayer);
		subgoal SIU_giveObjectToPlayer_root_receiver_perform(giverName, receiverName);
        subgoal performanceCleanupForSiu(siuWME, receiverName);
	}
	
	// PLAYER INITIATOR
	sequential behavior SIU_giveObjectToPlayer_root_receiver_perform(String giverName, String receiverName) {
		precondition { (receiverName.equals(playerName) == true) }
		mental_act { log.info(receiverName+ " participating in giveObjectToPlayer as receiver"); }		
		subgoal waitFor(500);	// fixme: needed to give time for giver behaviors to take root in root parallel behavior, otherwise the SIU will complete prematurely!		
	}
	
	// NPC INITIATOR
	//ERROR -- I do not believe we should hit this case -- the player is the receiver here.
	sequential behavior SIU_giveObjectToPlayer_root_receiver_perform(String giverName, String receiverName) {
		precondition { (receiverName.equals(playerName) == false) }		
		mental_act { log.info(receiverName+ " ERROR -- only player should be receiver for giveObjectToPlayer"); }	
		subgoal waitFor(500);	// fixme: needed to give time for giver behaviors to take root in root parallel behavior, otherwise the SIU will complete prematurely!		
	}
	
	
	
	/**
	 * SIU_greet()
	 */	 	
	sequential behavior SIU_greet(SiuWME siuWME) {
		CharacterWME initiator;
		CharactersWME responders;
		String initiatorName;
		
		mental_act {
			log.info("### " +siuWME.getInitiator().getName()+ " starting " +siuNameGreet+ " with " +siuWME.getResponders().getCharacterWMEs().size()+ " responders");
			initiator = siuWME.getInitiator();
			initiatorName = initiator.getName(); 
			responders = siuWME.getResponders(); 
		}
		
		subgoal OfferExpectationsForSIU(siuWME);
		
		with (ignore_failure)
			subgoal SIU_greet_root(siuWME, initiatorName, responders);
			
		subgoal ClearExpectationsForSIU(siuWME);		
		subgoal testbed_endSIU(siuWME);
	}

	// For the player initiating greeting, short circuit this SIU if the initiator recently greeted this group	
	// For NPCs initiating greeting, let's not suppress this, and always do the greeting; 
	//   though the others may not return the greeting if they've greeted recently
	parallel behavior SIU_greet_root(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		precondition { 	epMemWME=(EpisodicMemoryWME)
						(epMemWME.getCharacterName().equals(initiatorName) &&
						 epMemWME.getEpisodeName().equals(siuNameGreet) &&
						 epMemWME.isMoreRecentThan(cRepetitiveGestureTimeout))
						(initiatorName.equals(playerName))						 
						}
		specificity 2;
		mental_act {
			log.info(initiatorName+ " will skip the " +siuNameGreet+ ", already greeted this group recently");
		}
	}
	
	// short circuit if there are no responders	
	parallel behavior SIU_greet_root(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		precondition { (responders.getSize() == 0) }
		specificity 2;
		mental_act {
			log.info(initiatorName+ " will skip the " +siuNameGreet+ ", no one in group to greet");
		}
	}
	
	parallel behavior SIU_greet_root(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		context_condition { (siuWME.getState()==SiuExecutionState.EXECUTING) } 			
		specificity 1;
		Collection responderCharacters;
		Iterator respondersIterator;
		
		with (priority_modifier 1) mental_act {
			responderCharacters = responders.getCharacterWMEs();
			respondersIterator = responderCharacters.iterator();
		}
	
		// ## INITIATOR
		subgoal SIU_greet_root_initiator(siuWME, initiatorName, responders);
		
		// ## RESPONDERS				
		with (ignore_failure) 
			subgoal SIU_greet_root_responders_launch(siuWME, initiatorName, respondersIterator);
	}

	
	sequential behavior SIU_greet_root_responders_launch(SiuWME siuWME, String initiatorName, Iterator respondersIterator) {
		with (persistent when_succeeds)
			subgoal SIU_greet_root_responders_launchLoop(siuWME, initiatorName, respondersIterator);
	}

	// spawn into this SIU's root parallel behavior 
	sequential behavior SIU_greet_root_responders_launchLoop(SiuWME siuWME, String initiatorName, Iterator respondersIterator) {
		precondition { (respondersIterator.hasNext()) 					
						parentBehavior = (ParallelBehaviorWME signature == "SIU_greet_root(SiuWME, String, CharactersWME)") }
		CharacterWME responderCharacterWME;
		mental_act { 
			responderCharacterWME = respondersIterator.next();
			log.info(responderCharacterWME.getName()+ " participating in " +siuNameGreet+ " started by " +initiatorName);
		}
		
		spawngoal SIU_greet_root_responder(siuWME, initiatorName, responderCharacterWME) at parentBehavior;
	}


	// ---------------------------------------
	// ---------------------------------------

	// ## INITIATOR ##
	
	sequential behavior SIU_greet_root_initiator(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		subgoal createEpisodicMemoryWME(initiatorName, siuNameGreet);
		subgoal SIU_greet_root_initiator_perform(siuWME, initiatorName, responders);
        subgoal performanceCleanupForSiu(siuWME, initiatorName);
	}
	
	// PLAYER INITIATOR
	sequential behavior SIU_greet_root_initiator_perform(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		precondition { (initiatorName.equals(playerName) == true) }
		mental_act { log.info(initiatorName+ " participating in greeting as initiator"); }		
		
		subgoal waitFor(500);	// fixme: needed to give time for responder behaviors to take root in root parallel behavior, otherwise the SIU will complete prematurely!		
	}
	
	// NPC INITIATOR
	sequential behavior SIU_greet_root_initiator_perform(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		precondition { (initiatorName.equals(playerName) == false) }
		mental_act { log.info(initiatorName+ " participating in greeting as initiator"); }
		subgoal testbed_greetCharacters(siuWME, initiatorName, responders, cPerformancePriorityMedHigh);		
	}
	
	
	// ## RESPONDER ##

	// don't perform in this SIU if we recently greeted 	
	sequential behavior SIU_greet_root_responder(SiuWME siuWME, String initiatorName, CharacterWME responder) {
		precondition { 	epMemWME=(EpisodicMemoryWME)
						(responder!=null && epMemWME.getCharacterName().equals(responder.getName()) &&
						 epMemWME.getEpisodeName().equals(siuNameGreet) &&
						 epMemWME.isMoreRecentThan(cRepetitiveGestureTimeout)) }
		specificity 2;
		mental_act {
			log.info(responder.getName()+ " not returning the greeting, already greeted this group recently");
		}
	}
	
	sequential behavior SIU_greet_root_responder(SiuWME siuWME, String initiatorName, CharacterWME responder) {
		specificity 1;
		String responderName;
		float duration;
		String greetAnim;
		boolean bHostile;
		boolean bSpeak;
		String headTrackTarget;
		
		mental_act { 			
			log.info(responder.getName()+ " participating in greeting as responder to " +initiatorName); 
			responderName = responder.getName(); 
			
			greetAnim = animationBowSmallGreet;
			duration = (float)Staging.randRange(2.5, 3.5);
			
			// possibly mirror a non-native greeting
			if (Staging.percentChance(65)) {
				if (siuWME.getParamGestureName().equals(gestureNameSmallWave)) {
					greetAnim = animationSmallWaveLeftArm1;
					if (Staging.percentChance(25)) greetAnim = animationSmallWaveLeftArm2;
					else if (Staging.percentChance(25)) greetAnim = animationSmallWaveRightArm1;
					else if (Staging.percentChance(25)) greetAnim = animationSmallWaveRightArm2;
				}
			} 
			
			bSpeak = Staging.percentChance(30);
			headTrackTarget = initiatorName;
			
			bHostile = responder.hasAttitude(eAttitudeType_hostile);
			if (bHostile) {
				bSpeak = false;
				greetAnim = animationInterrupted1;
				if (Staging.percentChance(30)) greetAnim = animationInterrupted1;
				else if (Staging.percentChance(30)) greetAnim = animationInterrupted2;
				else if (Staging.percentChance(20)) greetAnim = animationListeningAngry1;
				else if (Staging.percentChance(20)) greetAnim = animationIdle_Agitated2;
				else if (Staging.percentChance(20)) { greetAnim = animationReleaseLaugh; duration = 2.0f; }
				else if (Staging.percentChance(20)) greetAnim = animationAkimboBothArms;

				// HEAD NODDING STILL DOESNT WORK				
				//greetAnim = animationHeadNodBig;
				//headTrackTarget = responderName;	// turn off head tracking so head nod will work				
			}
			
		}
		
		subgoal testbed_headTrack(siuWME, responderName, initiatorName, 0, 700, cPerformancePriorityMedHigh);
	
		subgoal createEpisodicMemoryWME(responderName, initiatorName, siuNameGreet);
		
		// maybe speak something short
		spawngoal SIU_greet_root_responder_speak(responderName, bSpeak);
		 
		subgoal testbed_gestureToCharacter(siuWME, responderName, headTrackTarget, greetAnim, true, 
											duration, true, true, cPerformancePriorityMedHigh);
		
        subgoal performanceCleanupForSiu(siuWME, responderName);
	}


	sequential behavior SIU_greet_root_responder_speak(String myName, boolean bSpeak) {
		precondition { (bSpeak == true) }
		
        ReturnValueWME retValWME;
        String audio;
        String tone;
                
		mental_act { retValWME = new ReturnValueWME(); }
        subgoal testbed_getRandomDialog(retValWME, true);
        mental_act {
        	audio = retValWME.getString();
        	tone = retValWME.getString2();
        }
        
		subgoal speakDialogue(myName, audio, true, dialogue_gender_male, tone);
	}

	
	/**
	 * SIU_groupAnswerQuestion()
	 */	 	
	sequential behavior SIU_groupAnswerQuestion(SiuWME siuWME) {
		CharacterWME initiator;
		CharactersWME responders;
		String initiatorName;
		
		mental_act {
			log.info("### " +siuWME.getInitiator().getName()+ " starting " +siuNameGroupAnswerQuestion+ " with " +siuWME.getResponders().getCharacterWMEs().size()+ " responders");
			initiator = siuWME.getInitiator();
			initiatorName = initiator.getName(); 
			responders = siuWME.getResponders(); 
		}
		
		subgoal OfferExpectationsForSIU(siuWME);
		
		with (ignore_failure)
			subgoal SIU_groupAnswerQuestion_root(siuWME, initiatorName, responders);
			
		subgoal ClearExpectationsForSIU(siuWME);		
		subgoal testbed_endSIU(siuWME);
	}


	// short circuit if there are no responders	
	parallel behavior SIU_groupAnswerQuestion_root(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		precondition { (responders.getSize() == 0) }
		specificity 2;
		mental_act {
			log.info(initiatorName+ " will skip the " +siuNameGroupAnswerQuestion+ ", no one in group to study object");
		}
	}
	
	parallel behavior SIU_groupAnswerQuestion_root(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		context_condition { (siuWME.getState()==SiuExecutionState.EXECUTING) } 			
		specificity 1;
		Collection responderCharacters;
		Iterator respondersIterator;
		
		with (priority_modifier 1) mental_act {
			responderCharacters = responders.getCharacterWMEs();
			respondersIterator = responderCharacters.iterator();
		}
	
		// ## INITIATOR
		subgoal SIU_groupAnswerQuestion_root_initiator(siuWME, initiatorName, responders);
		
		// ## RESPONDERS				
		with (ignore_failure) 
			subgoal SIU_groupAnswerQuestion_root_responders_launch(siuWME, initiatorName, respondersIterator);
	}

	
	sequential behavior SIU_groupAnswerQuestion_root_responders_launch(SiuWME siuWME, String initiatorName, Iterator respondersIterator) {
		with (persistent when_succeeds)
			subgoal SIU_groupAnswerQuestion_root_responders_launchLoop(siuWME, initiatorName, respondersIterator);
	}

	// spawn into this SIU's root parallel behavior 
	sequential behavior SIU_groupAnswerQuestion_root_responders_launchLoop(SiuWME siuWME, String initiatorName, Iterator respondersIterator) {
		precondition { (respondersIterator.hasNext()) 					
						parentBehavior = (ParallelBehaviorWME signature == "SIU_groupAnswerQuestion_root(SiuWME, String, CharactersWME)") }
		CharacterWME responderCharacterWME;
		mental_act { 
			responderCharacterWME = respondersIterator.next();
			log.info(responderCharacterWME.getName()+ " participating in " +siuNameGroupAnswerQuestion+ " started by " +initiatorName);
		}
		
		spawngoal SIU_groupAnswerQuestion_root_responder(siuWME, initiatorName, responderCharacterWME) at parentBehavior;
	}


	// ---------------------------------------
	// ---------------------------------------

	// ## INITIATOR ##
	
	sequential behavior SIU_groupAnswerQuestion_root_initiator(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		subgoal createEpisodicMemoryWME(initiatorName, siuNameGroupAnswerQuestion);
		subgoal SIU_groupAnswerQuestion_root_initiator_perform(initiatorName, responders);
        subgoal performanceCleanupForSiu(siuWME, initiatorName);
	}
	
	// PLAYER INITIATOR
	sequential behavior SIU_groupAnswerQuestion_root_initiator_perform(String initiatorName, CharactersWME responders) {
		precondition { (initiatorName.equals(playerName) == true) }
		mental_act { log.info(initiatorName+ " initiating groupAnswerQuestion."); }		
		
		subgoal waitFor(500);	// fixme: needed to give time for responder behaviors to take root in root parallel behavior, otherwise the SIU will complete prematurely!		
	}
	
	// NPC INITIATOR
	sequential behavior SIU_groupAnswerQuestion_root_initiator_perform(String initiatorName, CharactersWME responders) {
		precondition { (initiatorName.equals(playerName) == false) }
		mental_act { log.info(initiatorName+ " ERROR: NPC responding to question is not currently supported"); }
	}
	
	
	// ## RESPONDER ##

	// ANSWERER - if we are primary responder
	sequential behavior SIU_groupAnswerQuestion_root_responder(SiuWME siuWME, String initiatorName, CharacterWME responder) {
		precondition { (siuWME.getPrimaryResponder().getName().equals(responder.getName())) }
		specificity 2;
		String responderName;
		mental_act { 
			log.info(responder.getName()+ " answering question from " +initiatorName); 
			responderName = responder.getName(); 
		}

		subgoal createEpisodicMemoryWME(responderName, initiatorName, siuNameGroupAnswerQuestion);
		subgoal testbed_answerQuestion(siuWME, responderName, initiatorName, cPerformancePriorityHigher);
		
        subgoal performanceCleanupForSiu(siuWME, responderName);
	}

	// LISTENER
	sequential behavior SIU_groupAnswerQuestion_root_responder(SiuWME siuWME, String initiatorName, CharacterWME responder) {
		specificity 1;
		String responderName;
		String primaryAnswerer;
		
		mental_act { 
			log.info(responder.getName()+ " listening to answer question from " +initiatorName); 
			responderName = responder.getName();
			
			primaryAnswerer = siuWME.getPrimaryResponder().getName(); 
		}

		subgoal createEpisodicMemoryWME(responderName, initiatorName, siuNameGroupAnswerQuestion);
		
		subgoal testbed_reactToQuestion(siuWME, responderName, primaryAnswerer, cPerformancePriorityHigh);
		
        subgoal performanceCleanupForSiu(siuWME, responderName);
	}


	
	/**
	 * SIU_groupBriefAttention()
	 */	 	
	sequential behavior SIU_groupBriefAttention(SiuWME siuWME) {
		CharacterWME initiator;
		CharactersWME responders;
		String initiatorName;
		
		mental_act {
			log.info("### " +siuWME.getInitiator().getName()+ " starting " +siuNameGroupBriefAttention+ " with " +siuWME.getResponders().getCharacterWMEs().size()+ " responders");
			initiator = siuWME.getInitiator();
			initiatorName = initiator.getName(); 
			responders = siuWME.getResponders(); 
		}
		
		with (ignore_failure)
			subgoal SIU_groupBriefAttention_root(siuWME, initiatorName, responders);
		
		subgoal testbed_endSIU(siuWME);
	}

	// short circuit if there are no responders	
	parallel behavior SIU_groupBriefAttention_root(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		precondition { (responders.getSize() == 0) }
		specificity 2;
		mental_act {
			log.info(initiatorName+ " will skip the " +siuNameGroupBriefAttention+ ", no one in group to groupBriefAttention");
		}
	}
	
	parallel behavior SIU_groupBriefAttention_root(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		context_condition { (siuWME.getState()==SiuExecutionState.EXECUTING) } 			
		specificity 1;
		Collection responderCharacters;
		Iterator respondersIterator;
		
		with (priority_modifier 1) mental_act {
			responderCharacters = responders.getCharacterWMEs();
			respondersIterator = responderCharacters.iterator();
		}
	
		// ## INITIATOR
		subgoal SIU_groupBriefAttention_root_initiator(siuWME, initiatorName, responders);
		
		// ## RESPONDERS				
		with (ignore_failure) 
			subgoal SIU_groupBriefAttention_root_responders_launch(siuWME, initiatorName, respondersIterator);
	}

	
	sequential behavior SIU_groupBriefAttention_root_responders_launch(SiuWME siuWME, String initiatorName, Iterator respondersIterator) {
		with (persistent when_succeeds)
			subgoal SIU_groupBriefAttention_root_responders_launchLoop(siuWME, initiatorName, respondersIterator);
	}

	// spawn into this SIU's root parallel behavior 
	sequential behavior SIU_groupBriefAttention_root_responders_launchLoop(SiuWME siuWME, String initiatorName, Iterator respondersIterator) {
		precondition { (respondersIterator.hasNext()) 					
						parentBehavior = (ParallelBehaviorWME signature == "SIU_groupBriefAttention_root(SiuWME, String, CharactersWME)") }
		CharacterWME responderCharacterWME;
		mental_act { 
			responderCharacterWME = respondersIterator.next();
			log.info(responderCharacterWME.getName()+ " participating in " +siuNameGroupBriefAttention+ " started by " +initiatorName);
		}
		
		spawngoal SIU_groupBriefAttention_root_responder(siuWME, initiatorName, responderCharacterWME) at parentBehavior;
	}


	// ---------------------------------------
	// ---------------------------------------

	// ## INITIATOR ##
	
	sequential behavior SIU_groupBriefAttention_root_initiator(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		subgoal createEpisodicMemoryWME(initiatorName, siuNameGroupBriefAttention);
		subgoal SIU_groupBriefAttention_root_initiator_perform(initiatorName, responders);
        subgoal performanceCleanupForSiu(siuWME, initiatorName);
	}

	// PLAYER INITIATOR	
	sequential behavior SIU_groupBriefAttention_root_initiator_perform(String initiatorName, CharactersWME responders) {
		precondition { (initiatorName.equals(playerName) == true) }
		mental_act { log.info(initiatorName+ " participating in groupBriefAttention as initiator"); }				
		subgoal waitFor(500);	// fixme: needed to give time for responder behaviors to take root in root parallel behavior, otherwise the SIU will complete prematurely!		
	}
	
	// NPC INITIATOR -- don't do anything, we're the one pointing
	sequential behavior SIU_groupBriefAttention_root_initiator_perform(String initiatorName, CharactersWME responders) {
		precondition { (initiatorName.equals(playerName) == false) }
		mental_act { log.info(initiatorName+ " participating in groupBriefAttention as initiator"); }
		subgoal waitFor(500);	// fixme: needed to give time for responder behaviors to take root in root parallel behavior, otherwise the SIU will complete prematurely!		
	}
	
	
	// ## RESPONDER ##
/*
	// ## Suppress participation if recently gave attention for this same reason	
	sequential behavior SIU_groupBriefAttention_root_responder(SiuWME siuWME, String initiatorName, CharacterWME responder) {
		precondition {	epWME=(EpisodicMemoryWME episodeName==event_attention characterName==initiatorName)
						(epWME.getRecipientName().equals(responder.getName()) && epWME.getEpisodeParam() != null)
												
						// ## attention to pointing within last 6 seconds 
						(siuWME.getParamType().equals(eventParam_attention_point) &&
							epWME.getEpisodeParam().equals(eventParam_attention_point) &&
							epWME.isMoreRecentThan(6000))                   
						}
		specificity 2;
		String responderName;
		
		mental_act { 
			log.info(responder.getName()+ " ignoring groupBriefAttention, because did " +epWME.getEpisodeParam()+ " recently"); 
			responderName = responder.getName();
		}
		subgoal performanceCleanupForSiu(siuWME, responderName);
	}
	*/
	
	sequential behavior SIU_groupBriefAttention_root_responder(SiuWME siuWME, String initiatorName, CharacterWME responder) {
		specificity 1;

		String responderName;		
		mental_act { 
			log.info(responder.getName()+ " participating in groupBriefAttention as responder to " +initiatorName); 
			responderName = responder.getName();
		}
		
		subgoal SIU_groupBriefAttention_root_responder_perform(siuWME, initiatorName, responderName);
	}
			
					
	// ## Attention to Location 
	sequential behavior SIU_groupBriefAttention_root_responder_perform(SiuWME siuWME, String initiatorName, String responderName) {
		precondition { 	(siuWME.getParamType().equals(eventParam_attention_point)) 
						targetPhysicalWME=(PhysicalAgentWME) (targetPhysicalWME.getId().equals(initiatorName))
						}
		specificity 2;
		Location targetLocation;
		String targetName;
		float duration;
		
		// if we're not already looking at the pointing initiator, do so  
		//with (ignore_failure) subgoal SIU_groupBriefAttention_root_responder_possiblyHeadtrackInitiator(responderName, initiatorName);		
		subgoal testbed_headTrack(siuWME, responderName, initiatorName, 600, 1000, cPerformancePriorityHighest);

		subgoal createEpisodicMemoryWME(responderName, initiatorName, siuNameGroupBriefAttention, eventParam_attention_point);
		
		mental_act { 
			double dist;
			double angle;
			dist = 20.0;
			angle = targetPhysicalWME.getOrientation() + 45.0;

			//targetLocation = siuWME.getParamLocation();
			//targetLocation = Staging.pointAtAngleAndDist(dist, angle, targetPhysicalWME.getLocation());
			//log.info(responderName+ " brief attention headtracking " +targetLocation+ " from " +targetPhysicalWME.getLocation());
			targetName = siuWME.getParamString(); 
			log.info(responderName+ " brief attention headtracking " +targetName);
			
			duration = (float)Staging.randRange(1.5, 2.5);
		}
								
		subgoal testbed_gestureToCharacter(siuWME, responderName, targetName, eAttitudePerform_notice, false, 
											duration, true, false, cPerformancePriorityHighest);
		
		subgoal testbed_headTrack(siuWME, responderName, initiatorName, 600, 1000, cPerformancePriorityHighest);
		
        subgoal performanceCleanupForSiu(siuWME, responderName);
	}

	/*
	sequential behavior SIU_groupBriefAttention_root_responder_possiblyHeadtrackInitiator(String myName, String initiatorName) {
		precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName))
						(myCharacterWME.getHeadtrackTarget().equals(initiatorName) == false) 
						}
		subgoal headTrack(myName, initiatorName);
		subgoal waitForRand(600, 800);
	}
	*/

	sequential behavior SIU_groupBriefAttention_root_responder_perform(SiuWME siuWME, String initiatorName, String responderName) {
		specificity 1;
		mental_act { 
			log.info("ERROR: " +responderName+ " couldn't find attention perform behavior"); 
		}
	}

	
	/**
	 * SIU_groupConfused()
	 */	 	
	sequential behavior SIU_groupConfused(SiuWME siuWME) {
		CharacterWME initiator;
		CharactersWME responders;
		String initiatorName;
		
		mental_act {
			log.info("### " +siuWME.getInitiator().getName()+ " starting " +siuNameGroupConfused+ " with " +siuWME.getResponders().getCharacterWMEs().size()+ " responders");
			initiator = siuWME.getInitiator();
			initiatorName = initiator.getName(); 
			responders = siuWME.getResponders(); 
		}
		
		with (ignore_failure)
			subgoal SIU_groupConfused_root(siuWME, initiatorName, responders);
		
		subgoal testbed_endSIU(siuWME);
	}


	// short circuit if there are no responders	
	parallel behavior SIU_groupConfused_root(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		precondition { (responders.getSize() == 0) }
		specificity 2;
		mental_act {
			log.info(initiatorName+ " will skip the " +siuNameGroupConfused+ ", no one in group to respond");
		}
	}
	
	parallel behavior SIU_groupConfused_root(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		context_condition { (siuWME.getState()==SiuExecutionState.EXECUTING) } 			
		specificity 1;
		Collection responderCharacters;
		Iterator respondersIterator;
		
		with (priority_modifier 1) mental_act {
			responderCharacters = responders.getCharacterWMEs();
			respondersIterator = responderCharacters.iterator();
		}
	
		// ## INITIATOR
		subgoal SIU_groupConfused_root_initiator(siuWME, initiatorName, responders);
		
		// ## RESPONDERS				
		with (ignore_failure) 
			subgoal SIU_groupConfused_root_responders_launch(siuWME, initiatorName, respondersIterator);
	}

	
	sequential behavior SIU_groupConfused_root_responders_launch(SiuWME siuWME, String initiatorName, Iterator respondersIterator) {
		with (persistent when_succeeds)
			subgoal SIU_groupConfused_root_responders_launchLoop(siuWME, initiatorName, respondersIterator);
	}

	// spawn into this SIU's root parallel behavior 
	sequential behavior SIU_groupConfused_root_responders_launchLoop(SiuWME siuWME, String initiatorName, Iterator respondersIterator) {
		precondition { (respondersIterator.hasNext()) 					
						parentBehavior = (ParallelBehaviorWME signature == "SIU_groupConfused_root(SiuWME, String, CharactersWME)") }
		CharacterWME responderCharacterWME;
		mental_act { 
			responderCharacterWME = respondersIterator.next();
			log.info(responderCharacterWME.getName()+ " participating in " +siuNameGroupConfused+ " started by " +initiatorName);
		}
		
		spawngoal SIU_groupConfused_root_responder(siuWME, initiatorName, responderCharacterWME) at parentBehavior;
	}


	// ---------------------------------------
	// ---------------------------------------

	// ## INITIATOR ##
	
	sequential behavior SIU_groupConfused_root_initiator(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		subgoal createEpisodicMemoryWME(initiatorName, siuNameGroupConfused);
		subgoal SIU_groupConfused_root_initiator_perform(initiatorName, responders);
        subgoal performanceCleanupForSiu(siuWME, initiatorName);
	}
	
	// PLAYER INITIATOR
	sequential behavior SIU_groupConfused_root_initiator_perform(String initiatorName, CharactersWME responders) {
		precondition { (initiatorName.equals(playerName) == true) }
		mental_act { log.info(initiatorName+ " initiating groupConfused."); }		
		
		subgoal waitFor(500);	// fixme: needed to give time for responder behaviors to take root in root parallel behavior, otherwise the SIU will complete prematurely!		
	}
	
	// NPC INITIATOR
	sequential behavior SIU_groupConfused_root_initiator_perform(String initiatorName, CharactersWME responders) {
		precondition { (initiatorName.equals(playerName) == false) }
		mental_act { log.info(initiatorName+ " ERROR: NPC initiator confused is not currently supported"); }
	}
	
	
	// ## RESPONDER ##

	sequential behavior SIU_groupConfused_root_responder(SiuWME siuWME, String initiatorName, CharacterWME responder) {
		String responderName;
		mental_act { 
			log.info(responder.getName()+ " reacting to question from " +initiatorName); 
			responderName = responder.getName(); 
		}

		subgoal createEpisodicMemoryWME(responderName, initiatorName, siuNameGroupConfused);
		
		// possibly spawn a brief chat with a fellow responder soon!
		spawngoal SIU_groupConfused_responder_possiblySpawnABriefChat(responderName);
		
		subgoal testbed_confused(siuWME, responderName, initiatorName, cPerformancePriorityHigh);
		
        subgoal performanceCleanupForSiu(siuWME, responderName);
	}


	// ----------------------------------------------------------

	/*
	 * SIU_groupConfused_responder_possiblySpawnABriefChat
	 */
	sequential behavior SIU_groupConfused_responder_possiblySpawnABriefChat(String myName) {
		subgoal waitForRand(3000, 4000);
		with (ignore_failure) 
			subgoal testbed_cif_possiblySpawnABriefChat(myName, false, 10, cPerformancePriorityHigher);	// above testbed_reactToQuestion
	}
	
		
	/**
	 * SIU_groupFormation()
	 */	 	
	sequential behavior SIU_groupFormation(SiuWME siuWME) {
		CharacterWME initiator;
		CharactersWME responders;
		String initiatorName;
		
		mental_act {
			log.info("### " +siuWME.getInitiator().getName()+ " starting " +siuNameGroupFormation);
			initiator = siuWME.getInitiator();
			initiatorName = initiator.getName(); 
			responders = siuWME.getResponders(); 
		}
		
		with (ignore_failure)
			subgoal SIU_groupFormation_root(siuWME, initiatorName, responders);
		
		subgoal testbed_endSIU(siuWME);
	}

	parallel behavior SIU_groupFormation_root(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		context_condition { (siuWME.getState()==SiuExecutionState.EXECUTING) } 			
		specificity 1;
		Collection responderCharacters;
		Iterator respondersIterator;
		
		with (priority_modifier 1) mental_act {
			responderCharacters = responders.getCharacterWMEs();
			respondersIterator = responderCharacters.iterator();
		}
	
		// ## INITIATOR
		subgoal SIU_groupFormation_root_initiator(siuWME, initiatorName, responders);
		
		// ## RESPONDERS
		//fixme				
		//with (ignore_failure) 
		//	subgoal SIU_groupFormation_root_responders_launch(siuWME, initiatorName, respondersIterator);
	}

	
	// ---------------------------------------
	// ---------------------------------------

	// ## INITIATOR ##
	
	sequential behavior SIU_groupFormation_root_initiator(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		subgoal createEpisodicMemoryWME(initiatorName, siuNameGroupFormation);
		subgoal SIU_groupFormation_root_initiator_perform(siuWME, initiatorName, responders);
        subgoal performanceCleanupForSiu(siuWME, initiatorName);
	}
	
	sequential behavior SIU_groupFormation_root_initiator_perform(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		mental_act { log.info(initiatorName+ " performing groupFormation"); }
		
		// above groupMaintenance and briefExchange
		subgoal testbed_joinAndMaintainFormation(siuWME, initiatorName, cPerformancePriorityMedMedHigh); //, cPerformancePriorityMedMedLow);			
	}
	
	

	
	/**
	 * SIU_groupMirror()
	 */	 	
	sequential behavior SIU_groupMirror(SiuWME siuWME) {
		CharacterWME initiator;
		CharactersWME responders;
		String initiatorName;
		
		mental_act {
			log.info("### " +siuWME.getInitiator().getName()+ " starting " +siuNameGroupMirror+ " with " +siuWME.getResponders().getCharacterWMEs().size()+ " responders");
			initiator = siuWME.getInitiator();
			initiatorName = initiator.getName(); 
			responders = siuWME.getResponders(); 
		}
		
		with (ignore_failure)
			subgoal SIU_groupMirror_root(siuWME, initiatorName, responders);
		
		subgoal testbed_endSIU(siuWME);
	}

	// short circuit if there are no responders	
	parallel behavior SIU_groupMirror_root(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		precondition { (responders.getSize() == 0) }
		specificity 2;
		mental_act {
			log.info(initiatorName+ " will skip the " +siuNameGroupMirror+ ", no one in group to groupMirror");
		}
	}
	
	parallel behavior SIU_groupMirror_root(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		context_condition { (siuWME.getState()==SiuExecutionState.EXECUTING) } 			
		specificity 1;
		Collection responderCharacters;
		Iterator respondersIterator;
		
		with (priority_modifier 1) mental_act {
			responderCharacters = responders.getCharacterWMEs();
			respondersIterator = responderCharacters.iterator();
		}
	
		// ## INITIATOR
		subgoal SIU_groupMirror_root_initiator(siuWME, initiatorName, responders);
		
		// ## RESPONDERS				
		with (ignore_failure) 
			subgoal SIU_groupMirror_root_responders_launch(siuWME, initiatorName, respondersIterator);
	}

	
	sequential behavior SIU_groupMirror_root_responders_launch(SiuWME siuWME, String initiatorName, Iterator respondersIterator) {
		with (persistent when_succeeds)
			subgoal SIU_groupMirror_root_responders_launchLoop(siuWME, initiatorName, respondersIterator);
	}

	// spawn into this SIU's root parallel behavior 
	sequential behavior SIU_groupMirror_root_responders_launchLoop(SiuWME siuWME, String initiatorName, Iterator respondersIterator) {
		precondition { (respondersIterator.hasNext()) 					
						parentBehavior = (ParallelBehaviorWME signature == "SIU_groupMirror_root(SiuWME, String, CharactersWME)") }
		CharacterWME responderCharacterWME;
		mental_act { 
			responderCharacterWME = respondersIterator.next();
			log.info(responderCharacterWME.getName()+ " participating in " +siuNameGroupMirror+ " started by " +initiatorName);
		}
		
		spawngoal SIU_groupMirror_root_responder(siuWME, initiatorName, responderCharacterWME) at parentBehavior;
	}


	// ---------------------------------------
	// ---------------------------------------

	// ## INITIATOR ##
	
	sequential behavior SIU_groupMirror_root_initiator(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		subgoal createEpisodicMemoryWME(initiatorName, siuNameGroupMirror);
		subgoal SIU_groupMirror_root_initiator_perform(initiatorName, responders);
        subgoal performanceCleanupForSiu(siuWME, initiatorName);
	}

	// PLAYER INITIATOR	
	sequential behavior SIU_groupMirror_root_initiator_perform(String initiatorName, CharactersWME responders) {
		precondition { (initiatorName.equals(playerName) == true) }
		mental_act { log.info(initiatorName+ " participating in groupMirror as initiator"); }				
		subgoal waitFor(500);	// fixme: needed to give time for responder behaviors to take root in root parallel behavior, otherwise the SIU will complete prematurely!		
	}
	
	// NPC INITIATOR
	sequential behavior SIU_groupMirror_root_initiator_perform(String initiatorName, CharactersWME responders) {
		precondition { (initiatorName.equals(playerName) == false) }
		mental_act { log.info(initiatorName+ " participating in groupMirror as initiator"); }
		subgoal waitFor(500);	// fixme: needed to give time for responder behaviors to take root in root parallel behavior, otherwise the SIU will complete prematurely!		
	}
	
	
	// ## RESPONDER ##

	sequential behavior SIU_groupMirror_root_responder(SiuWME siuWME, String initiatorName, CharacterWME responder) {
		precondition {	(responder.getObjectHeld().equals("") == false)
						}
		specificity 2;
		String responderName;
		
		mental_act { 
			log.info(responder.getName()+ " ignoring groupMirror, because holding an object"); 
			responderName = responder.getName();
		}
		subgoal performanceCleanupForSiu(siuWME, responderName);
	}
	
	
	sequential behavior SIU_groupMirror_root_responder(SiuWME siuWME, String initiatorName, CharacterWME responder) {
		specificity 1;

		String responderName;
		SocialInterpretation interpretation;
		String anim;
		boolean bHostile;
		float duration;
		boolean bMirroredBow;
        ReturnValueWME retValWME;
        boolean bAlreadyAnsweredQuestion;
		
		mental_act { 
			log.info(responder.getName()+ " participating in groupMirror as responder to " +initiatorName); 
			responderName = responder.getName();
			bMirroredBow = false;
			retValWME = new ReturnValueWME(); 
		}
		
		// check if we've answered a question, and are therefore less hostile
		// fixme: better to change our actual attitude value
        subgoal SIU_groupMirror_checkIfAlreadyAnsweredQuestion(responderName, retValWME);
        
        mental_act {
        	bAlreadyAnsweredQuestion = retValWME.getB();
					 
			interpretation = siuWME.getParamInterpretation();
			duration = cAnimDefaultEndTime;
			
			if (interpretation == socialInterpretationGreetingWaveFriendly) {
				anim = animationBowSmallGreet;
				
				// Coach cares if player mirrored a bow greeting 
				if (siuWME.getParamGestureName().equals(gestureNameSmallBowHandsTogether)) {
					bMirroredBow = true;
				}
				
				if (siuWME.getParamGestureName().equals(gestureNameSmallWave) &&
						(Staging.percentChance(80) 
// demo hack to ensure at least 2 bows - remove					 
&& responderName.equals("NPC04")==false && responderName.equals("NPC02")==false
						)) {
					anim = animationSmallWaveLeftArm1;
					if (Staging.percentChance(25)) anim = animationSmallWaveLeftArm2;
					else if (Staging.percentChance(25)) anim = animationSmallWaveRightArm1;
					else if (Staging.percentChance(25)) anim = animationSmallWaveRightArm2;
				}
			}

			
			bHostile = (responder.hasAttitude(eAttitudeType_hostile) &&
							// check if we've answered a question, and are therefore less hostile 
							!bAlreadyAnsweredQuestion);
			if (bHostile) {
				anim = animationListeningAngry1;
				if (Staging.percentChance(20)) anim = animationListeningAngry1;
				else if (Staging.percentChance(20)) anim = animationIdle_Agitated2;				
				else if (Staging.percentChance(20)) { anim = animationReleaseLaugh; duration = 2.0f; }
				else if (Staging.percentChance(20)) anim = animationAkimboBothArms;
			}
		}
	
		with (ignore_failure) subgoal SIU_groupMirror_mirroredBowCheck(initiatorName, responderName, bMirroredBow);
			
		// look at initiator and idle for a moment
		subgoal testbed_headTrack(siuWME, responderName, initiatorName, 0, 800, cPerformancePriorityMedHigh);
									
		subgoal createEpisodicMemoryWME(responderName, initiatorName, siuNameGroupMirror);
		
		subgoal headTrack(responderName, initiatorName);		
		subgoal testbed_gestureToCharacter(siuWME, responderName, initiatorName, anim, true, duration, true, false, cPerformancePriorityMedHigh);
			
        subgoal performanceCleanupForSiu(siuWME, responderName);
	}


	sequential behavior SIU_groupMirror_mirroredBowCheck(String initiatorName, String responderName, boolean bMirroredBow) {
		precondition { (bMirroredBow == true) }
		subgoal createEpisodicMemoryWME(responderName, initiatorName, event_coach, eventParam_coach_mirroredGreeting);
	}				
	
	
	sequential behavior SIU_groupMirror_checkIfAlreadyAnsweredQuestion(String myName, ReturnValueWME retValWME) {
		precondition { (EpisodicMemoryWME characterName==myName episodeName==siuNameGroupAnswerQuestion) }
		specificity 2;
		mental_act { retValWME.setB(true); }
	}
	sequential behavior SIU_groupMirror_checkIfAlreadyAnsweredQuestion(String myName, ReturnValueWME retValWME) {
		specificity 1;
		mental_act { retValWME.setB(false); }
	}
	
	
	/**
	 * SIU_groupPassObject()
	 */	 	
	sequential behavior SIU_groupPassObject(SiuWME siuWME, String myName) {
	   precondition {
	      groupWME=(GroupWME)
	      charWME=(CharacterWME)
	      (charWME.getName().equals(myName))
	      (groupWME.formationContains(charWME))
	   }
	   
	   Iterator giverIterator;
	   Iterator takerIterator;
		mental_act {
			log.info("### starting HIERARCHICAL SIU " +siuNameGroupPassObject);
	      groupWME.orderFormationAroundCharacter(myName);
	      if (groupWME.getOrderedFormationCharacters().get(1).getName().equals(playerName)) {
	         groupWME.reverseFormationOrder();  
	      }
	      
	      giverIterator = groupWME.getOrderedFormationCharacters().iterator();
	      takerIterator = groupWME.getOrderedFormationCharacters().listIterator(1);
	   }

	   with (ignore_failure)  
         subgoal SIU_groupPassObject_main(siuWME, groupWME, giverIterator, takerIterator);

      mental_act {
			log.info("### finishing HIERARCHICAL SIU " +siuNameGroupPassObject);
      }
         
		subgoal testbed_endSIU(siuWME);
   }
	
	sequential behavior SIU_groupPassObject_main(SiuWME siuWME, GroupWME groupWME, Iterator giverIterator, Iterator takerIterator) {
		context_condition { (siuWME.getState()==SiuExecutionState.EXECUTING) } 			
	   with (persistent when_succeeds)  
         subgoal SIU_groupPassObject_launchLoop(groupWME, giverIterator, takerIterator);
    }
	
	
	// this will reset the taker iterator back to index zero of the ordered formation character
	// in other words, the last person in the ordered list is giving to the 0th person.
   sequential behavior SIU_groupPassObject_launchLoop(GroupWME groupWME, Iterator giverIterator, Iterator takerIterator) {
      precondition {	(giverIterator.hasNext() == true)
         				(takerIterator.hasNext() == false)
						
						// player can not have gotten the photo back yet, which can occur in this SIU
      					playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName)) 
						(playerCharacterWME.getObjectHeld().equals("") == true)
				      }
      specificity 3;
      mental_act {
         //giverIterator = groupWME.getOrderedFormationCharacters().iterator();
         takerIterator = groupWME.getOrderedFormationCharacters().listIterator(0);
      }
      
      // don't recurse -- allow the persistent to do the work
      //subgoal SIU_groupPassObject_launchLoop(groupWME, giverIterator, takerIterator);
   }
   
   // this will reset the giver iterator back to index zero of the ordered formation character   
   sequential behavior SIU_groupPassObject_launchLoop(GroupWME groupWME, Iterator giverIterator, Iterator takerIterator) {
      precondition {	(giverIterator.hasNext() == false)
						(takerIterator.hasNext() == true)
						
						// player can not have gotten the photo back yet, which can occur in this SIU
      					playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName)) 
						(playerCharacterWME.getObjectHeld().equals("") == true)
      				}
      specificity 2;
      mental_act {
         giverIterator = groupWME.getOrderedFormationCharacters().listIterator(0);
         //takerIterator = groupWME.getOrderedFormationCharacters().listIterator(0);
      }
      
      // don't recurse -- allow the persistent to do the work
      //subgoal SIU_groupPassObject_launchLoop(groupWME, giverIterator, takerIterator);
   }
  	
	sequential behavior SIU_groupPassObject_launchLoop(GroupWME groupWME, Iterator giverIterator, Iterator takerIterator) {
      precondition {	(giverIterator.hasNext() == true)
         				(takerIterator.hasNext() == true)
						
						// player can not have gotten the photo back yet, which can occur in this SIU
      					playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName)) 
						(playerCharacterWME.getObjectHeld().equals("") == true)
      				}
      specificity 1;
      
      CharacterWME giverWME;
      CharacterWME takerWME;
      String giver;
      String taker;
      mental_act {
         giverWME = giverIterator.next();
         giver = giverWME.getName();
         takerWME = takerIterator.next();
         taker = takerWME.getName();
      }
    
      subgoal SIU_groupPassObject_perform(giver, taker);
    }


	// NPC TO NPC
	sequential behavior SIU_groupPassObject_perform(String giver, String taker) {
		precondition { (taker.equals(playerName) == false) }
		specificity 2;
		      
	      subgoal testbed_LaunchSIU_studyOwnObject(giver, taker);
	      subgoal testbed_waitForSIUToStartAndStop(giver, siuNameStudyOwnObject);
	      mental_act {
	         log.info(giver + " finished studying object");
	      }
	      
	      mental_act {
	         log.info(giver + " starting giving an object to " + taker);
	      }
	      subgoal testbed_LaunchSIU_giveObject(giver, taker);
	      subgoal testbed_waitForSIUToStartAndStop(giver, siuNameGiveObject);
	      mental_act {
	         log.info(giver + " finished giving an object to " + taker);
	      }
      
	}
	

	// NPC TO PLAYER - FAIL AT THE END, TO TERMINATE THIS SIU
	sequential behavior SIU_groupPassObject_perform(String giver, String taker) {
      	precondition {	giverCharacterWME=(CharacterWME) (giverCharacterWME.getName().equals(giver)) 
						(giverCharacterWME.getObjectHeld().equals("") == false)
						(taker.equals(playerName) == true) 
						}

	      subgoal testbed_LaunchSIU_studyOwnObject(giver, taker);
	      subgoal testbed_waitForSIUToStartAndStop(giver, siuNameStudyOwnObject);
	      mental_act {
	         log.info(giver + " finished studying object");
	      }
			      
	      mental_act {
	         log.info(giver + " starting giving an object to " + taker);
	      }
	      subgoal testbed_LaunchSIU_giveObjectToPlayer(giver, taker);
	      subgoal testbed_waitForSIUToStartAndStop(giver, siuNameGiveObjectToPlayer);
	      mental_act {
	         log.info(giver + " finished giving an object to " + taker);
	      }
	      
	      fail_step;      
	}
 
   	
	/**
	 * SIU_groupReactToAppeal()
	 */	 	
	sequential behavior SIU_groupReactToAppeal(SiuWME siuWME) {
		CharacterWME initiator;
		CharactersWME responders;
		String initiatorName;
		
		mental_act {
			log.info("### " +siuWME.getInitiator().getName()+ " starting " +siuNameGroupReactToAppeal+ " with " +siuWME.getResponders().getCharacterWMEs().size()+ " responders");
			initiator = siuWME.getInitiator();
			initiatorName = initiator.getName(); 
			responders = siuWME.getResponders(); 
		}

		subgoal OfferExpectationsForSIU(siuWME);
		
		with (ignore_failure)
			subgoal SIU_groupReactToAppeal_root(siuWME, initiatorName, responders);
			
		subgoal ClearExpectationsForSIU(siuWME);		
		subgoal testbed_endSIU(siuWME);
	}


	// short circuit if there are no responders	
	parallel behavior SIU_groupReactToAppeal_root(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		precondition { (responders.getSize() == 0) }
		specificity 2;
		mental_act {
			log.info(initiatorName+ " will skip the " +siuNameGroupReactToAppeal+ ", no one in group to respond");
		}
	}
	
	parallel behavior SIU_groupReactToAppeal_root(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		context_condition { (siuWME.getState()==SiuExecutionState.EXECUTING) } 			
		specificity 1;
		Collection responderCharacters;
		Iterator respondersIterator;
		
		with (priority_modifier 1) mental_act {
			responderCharacters = responders.getCharacterWMEs();
			respondersIterator = responderCharacters.iterator();
		}
	
		// ## INITIATOR
		subgoal SIU_groupReactToAppeal_root_initiator(siuWME, initiatorName, responders);
		
		// ## RESPONDERS				
		with (ignore_failure) 
			subgoal SIU_groupReactToAppeal_root_responders_launch(siuWME, initiatorName, respondersIterator);
	}

	
	sequential behavior SIU_groupReactToAppeal_root_responders_launch(SiuWME siuWME, String initiatorName, Iterator respondersIterator) {
		with (persistent when_succeeds)
			subgoal SIU_groupReactToAppeal_root_responders_launchLoop(siuWME, initiatorName, respondersIterator);
	}

	// spawn into this SIU's root parallel behavior 
	sequential behavior SIU_groupReactToAppeal_root_responders_launchLoop(SiuWME siuWME, String initiatorName, Iterator respondersIterator) {
		precondition { (respondersIterator.hasNext()) 					
						parentBehavior = (ParallelBehaviorWME signature == "SIU_groupReactToAppeal_root(SiuWME, String, CharactersWME)") }
		CharacterWME responderCharacterWME;
		mental_act { 
			responderCharacterWME = respondersIterator.next();
			log.info(responderCharacterWME.getName()+ " participating in " +siuNameGroupReactToAppeal+ " started by " +initiatorName);
		}
		
		spawngoal SIU_groupReactToAppeal_root_responder(siuWME, initiatorName, responderCharacterWME) at parentBehavior;
	}


	// ---------------------------------------
	// ---------------------------------------

	// ## INITIATOR ##
	
	sequential behavior SIU_groupReactToAppeal_root_initiator(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		subgoal createEpisodicMemoryWME(initiatorName, siuNameGroupReactToAppeal);
		subgoal SIU_groupReactToAppeal_root_initiator_perform(initiatorName, responders);
        subgoal performanceCleanupForSiu(siuWME, initiatorName);
	}
	
	// PLAYER INITIATOR
	sequential behavior SIU_groupReactToAppeal_root_initiator_perform(String initiatorName, CharactersWME responders) {
		precondition { (initiatorName.equals(playerName) == true) }
		mental_act { log.info(initiatorName+ " initiating groupReactToAppeal."); }		
		
		subgoal waitFor(500);	// fixme: needed to give time for responder behaviors to take root in root parallel behavior, otherwise the SIU will complete prematurely!		
	}
	
	// NPC INITIATOR
	sequential behavior SIU_groupReactToAppeal_root_initiator_perform(String initiatorName, CharactersWME responders) {
		precondition { (initiatorName.equals(playerName) == false) }
		mental_act { log.info(initiatorName+ " ERROR: NPC initiator in responding to question is not currently supported"); }
	}
	
	
	// ## PRIMARY RESPONDER ##

	sequential behavior SIU_groupReactToAppeal_root_responder(SiuWME siuWME, String initiatorName, CharacterWME responder) {
		precondition {	(responder.getName().equals(siuWME.getPrimaryResponder().getName()) == true
		
// LEADER ALSO RESPONDS, EVEN IF NOT PRIMARY
|| responder.hasAttitude(eAttitudeType_leader) == true
						)
						
						groupWME=(GroupWME) (groupWME.contains(responder)) 
						}
		specificity 2;
		String responderName;
		mental_act { 
			log.info(responder.getName()+ " reacting to appeal from " +initiatorName); 
			responderName = responder.getName(); 
		}

		subgoal createEpisodicMemoryWME(responderName, initiatorName, siuNameGroupReactToAppeal);
		with (ignore_failure) subgoal testbed_reactToAppeal(siuWME, responderName, initiatorName, cPerformancePriorityHigh);
        subgoal performanceCleanupForSiu(siuWME, responderName);
	}


	// ## RESPONDER DEFAULT ##

	sequential behavior SIU_groupReactToAppeal_root_responder(SiuWME siuWME, String initiatorName, CharacterWME responder) {
		specificity 1;
		String responderName;
		mental_act { 
			log.info(responder.getName()+ " reacting to question from " +initiatorName); 
			responderName = responder.getName(); 
		}

		subgoal createEpisodicMemoryWME(responderName, initiatorName, siuNameGroupReactToQuestion);
		subgoal testbed_reactToQuestion(siuWME, responderName, initiatorName, cPerformancePriorityHigh);
        subgoal performanceCleanupForSiu(siuWME, responderName);
	}

	
	/**
	 * SIU_groupReactToQuestion()
	 */	 	
	sequential behavior SIU_groupReactToQuestion(SiuWME siuWME) {
		CharacterWME initiator;
		CharactersWME responders;
		String initiatorName;
		
		mental_act {
			log.info("### " +siuWME.getInitiator().getName()+ " starting " +siuNameGroupReactToQuestion+ " with " +siuWME.getResponders().getCharacterWMEs().size()+ " responders");
			initiator = siuWME.getInitiator();
			initiatorName = initiator.getName(); 
			responders = siuWME.getResponders(); 
		}

		subgoal OfferExpectationsForSIU(siuWME);
		
		with (ignore_failure)
			subgoal SIU_groupReactToQuestion_root(siuWME, initiatorName, responders);
			
		subgoal ClearExpectationsForSIU(siuWME);		
		subgoal testbed_endSIU(siuWME);
	}


	// short circuit if there are no responders	
	parallel behavior SIU_groupReactToQuestion_root(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		precondition { (responders.getSize() == 0) }
		specificity 2;
		mental_act {
			log.info(initiatorName+ " will skip the " +siuNameGroupReactToQuestion+ ", no one in group to respond");
		}
	}
	
	parallel behavior SIU_groupReactToQuestion_root(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		context_condition { (siuWME.getState()==SiuExecutionState.EXECUTING) } 			
		specificity 1;
		Collection responderCharacters;
		Iterator respondersIterator;
		
		with (priority_modifier 1) mental_act {
			responderCharacters = responders.getCharacterWMEs();
			respondersIterator = responderCharacters.iterator();
		}
	
		// ## INITIATOR
		subgoal SIU_groupReactToQuestion_root_initiator(siuWME, initiatorName, responders);
		
		// ## RESPONDERS				
		with (ignore_failure) 
			subgoal SIU_groupReactToQuestion_root_responders_launch(siuWME, initiatorName, respondersIterator);
	}

	
	sequential behavior SIU_groupReactToQuestion_root_responders_launch(SiuWME siuWME, String initiatorName, Iterator respondersIterator) {
		with (persistent when_succeeds)
			subgoal SIU_groupReactToQuestion_root_responders_launchLoop(siuWME, initiatorName, respondersIterator);
	}

	// spawn into this SIU's root parallel behavior 
	sequential behavior SIU_groupReactToQuestion_root_responders_launchLoop(SiuWME siuWME, String initiatorName, Iterator respondersIterator) {
		precondition { (respondersIterator.hasNext()) 					
						parentBehavior = (ParallelBehaviorWME signature == "SIU_groupReactToQuestion_root(SiuWME, String, CharactersWME)") }
		CharacterWME responderCharacterWME;
		mental_act { 
			responderCharacterWME = respondersIterator.next();
			log.info(responderCharacterWME.getName()+ " participating in " +siuNameGroupReactToQuestion+ " started by " +initiatorName);
		}
		
		spawngoal SIU_groupReactToQuestion_root_responder(siuWME, initiatorName, responderCharacterWME) at parentBehavior;
	}


	// ---------------------------------------
	// ---------------------------------------

	// ## INITIATOR ##
	
	sequential behavior SIU_groupReactToQuestion_root_initiator(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		subgoal createEpisodicMemoryWME(initiatorName, siuNameGroupReactToQuestion);
		subgoal SIU_groupReactToQuestion_root_initiator_perform(initiatorName, responders);
        subgoal performanceCleanupForSiu(siuWME, initiatorName);
	}
	
	// PLAYER INITIATOR
	sequential behavior SIU_groupReactToQuestion_root_initiator_perform(String initiatorName, CharactersWME responders) {
		precondition { (initiatorName.equals(playerName) == true) }
		mental_act { log.info(initiatorName+ " initiating groupReactToQuestion."); }		
		
		subgoal waitFor(500);	// fixme: needed to give time for responder behaviors to take root in root parallel behavior, otherwise the SIU will complete prematurely!		
	}
	
	// NPC INITIATOR
	sequential behavior SIU_groupReactToQuestion_root_initiator_perform(String initiatorName, CharactersWME responders) {
		precondition { (initiatorName.equals(playerName) == false) }
		mental_act { log.info(initiatorName+ " ERROR: NPC initiator in responding to question is not currently supported"); }
	}
	
	
	// ## RESPONDER NON-LEADER ##

	sequential behavior SIU_groupReactToQuestion_root_responder(SiuWME siuWME, String initiatorName, CharacterWME responder) {
		precondition {	(responder.hasAttitude(eAttitudeType_leader) == false)
						groupWME=(GroupWME) (groupWME.contains(responder)) 
						}
		specificity 2;
		String responderName;
		mental_act { 
			log.info(responder.getName()+ " reacting to question from " +initiatorName); 
			responderName = responder.getName(); 
		}

		subgoal createEpisodicMemoryWME(responderName, initiatorName, siuNameGroupReactToQuestion);
		subgoal SIU_groupReactToQuestion_root_responder_par(siuWME, initiatorName, responderName, responder, groupWME);
        subgoal performanceCleanupForSiu(siuWME, responderName);
	}

	parallel behavior SIU_groupReactToQuestion_root_responder_par(SiuWME siuWME, String initiatorName, String responderName, CharacterWME myCharacterWME, GroupWME groupWME) {		
		with (ignore_failure) subgoal testbed_reactToQuestion(siuWME, responderName, initiatorName, cPerformancePriorityHigh);
		with (persistent) subgoal SIU_groupReactToQuestion_responder_briefChatsWithLeader(responderName, myCharacterWME, groupWME);
	}
		
	sequential behavior SIU_groupReactToQuestion_responder_briefChatsWithLeader(String myName, CharacterWME myCharacterWME, GroupWME groupWME) {
		String leaderName;
		subgoal waitForRand(2000, 3000);
		mental_act {
      		leaderName = "";
      		if (groupWME.getLeaderCharacter() != null) { 
      			leaderName = groupWME.getLeaderCharacter().getName();
				log.info(myName+ " spawning brief chat with leader " +leaderName+ " in ReactToQuestion");
      		}			
		}

		spawngoal testbed_LaunchSIU_briefChat(myName, leaderName, cPerformancePriorityHigher);	// above testbed_reactToQuestion
	}

	// ## RESPONDER DEFAULT ##

	sequential behavior SIU_groupReactToQuestion_root_responder(SiuWME siuWME, String initiatorName, CharacterWME responder) {
		specificity 1;
		String responderName;
		mental_act { 
			log.info(responder.getName()+ " reacting to question from " +initiatorName); 
			responderName = responder.getName(); 
		}

		subgoal createEpisodicMemoryWME(responderName, initiatorName, siuNameGroupReactToQuestion);
		
		// possibly spawn a brief chat with a fellow responder soon!
		spawngoal SIU_groupReactToQuestion_responder_possiblySpawnABriefChat(responderName, responder);
		
		subgoal testbed_reactToQuestion(siuWME, responderName, initiatorName, cPerformancePriorityHigh);
		
        subgoal performanceCleanupForSiu(siuWME, responderName);
	}


	// ----------------------------------------------------------

	/*
	 * SIU_groupReactToQuestion_responder_possiblySpawnABriefChat
	 */
	
	sequential behavior SIU_groupReactToQuestion_responder_possiblySpawnABriefChat(String myName, CharacterWME myCharacterWME) {
		precondition { (myCharacterWME.hasAttitude(eAttitudeType_leader) == false) } 
		subgoal waitForRand(1000, 2000);
		with (ignore_failure) 
			subgoal testbed_cif_possiblySpawnABriefChat(myName, false, 30, cPerformancePriorityHigher);	// above testbed_reactToQuestion
	}
	
		
	/**
	 * SIU_groupSmalltalk()
	 */	 	
	sequential behavior SIU_groupSmalltalk(SiuWME siuWME) {
		CharacterWME initiator;
		CharactersWME responders;
		String initiatorName;
		
		mental_act {
			log.info("### " +siuWME.getInitiator().getName()+ " starting " +siuNameGroupSmalltalk);
			initiator = siuWME.getInitiator();
			initiatorName = initiator.getName(); 
			responders = siuWME.getResponders(); 
		}
		
		with (ignore_failure)
			subgoal SIU_groupSmalltalk_root(siuWME, initiatorName, responders);
		
		subgoal testbed_endSIU(siuWME);
	}

	parallel behavior SIU_groupSmalltalk_root(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		context_condition { (siuWME.getState()==SiuExecutionState.EXECUTING) } 			
		specificity 1;
		Collection responderCharacters;
		Iterator respondersIterator;
		
		with (priority_modifier 1) mental_act {
			responderCharacters = responders.getCharacterWMEs();
			respondersIterator = responderCharacters.iterator();
		}
	
		// ## INITIATOR
		subgoal SIU_groupSmalltalk_root_initiator(siuWME, initiatorName, responders);
		
		// ## RESPONDERS
		//fixme				
		//with (ignore_failure) 
		//	subgoal SIU_groupSmalltalk_root_responders_launch(siuWME, initiatorName, respondersIterator);
	}

	
	// ---------------------------------------
	// ---------------------------------------

	// ## INITIATOR ##
	
	sequential behavior SIU_groupSmalltalk_root_initiator(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		subgoal createEpisodicMemoryWME(initiatorName, siuNameGroupSmalltalk);
		subgoal SIU_groupSmalltalk_root_initiator_perform(siuWME, initiatorName, responders);
        subgoal performanceCleanupForSiu(siuWME, initiatorName);
	}
	
	sequential behavior SIU_groupSmalltalk_root_initiator_perform(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		mental_act { log.info(initiatorName+ " performing groupSmalltalk"); }
		subgoal testbed_groupMaintenance(siuWME, initiatorName, cPerformancePriorityLow, smallTalk_Default);		
	}
	
	

	
	/**
	 * SIU_groupStudyObject()
	 */	 	
	sequential behavior SIU_groupStudyObject(SiuWME siuWME) {
		CharacterWME initiator;
		CharactersWME responders;
		String initiatorName;
		
		mental_act {
			log.info("### " +siuWME.getInitiator().getName()+ " starting " +siuNameGroupStudyObject+ " with " +siuWME.getResponders().getCharacterWMEs().size()+ " responders");
			initiator = siuWME.getInitiator();
			initiatorName = initiator.getName(); 
			responders = siuWME.getResponders(); 
		}
		
		with (ignore_failure)
			subgoal SIU_groupStudyObject_root(siuWME, initiatorName, responders);
		
		subgoal testbed_endSIU(siuWME);
	}

	// For the player initiating this groupStudyObject, we won't do anything for the initiator (though NPC responders will still look)
	// For NPCs initiating groupStudyObject, they will always look at their own object
	//   all of the NPCs will then look at the object held by the initiator.

	// short circuit if there are no responders	
	parallel behavior SIU_groupStudyObject_root(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		precondition { (responders.getSize() == 0) }
		specificity 2;
		mental_act {
			log.info(initiatorName+ " will skip the " +siuNameGroupStudyObject+ ", no one in group to study object");
		}
	}
	
	parallel behavior SIU_groupStudyObject_root(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		context_condition { (siuWME.getState()==SiuExecutionState.EXECUTING) } 			
		specificity 1;
		Collection responderCharacters;
		Iterator respondersIterator;
		
		with (priority_modifier 1) mental_act {
			responderCharacters = responders.getCharacterWMEs();
			respondersIterator = responderCharacters.iterator();
		}
	
		// ## INITIATOR
		subgoal SIU_groupStudyObject_root_initiator(siuWME, initiatorName, responders);
		
		// ## RESPONDERS				
		with (ignore_failure) 
			subgoal SIU_groupStudyObject_root_responders_launch(siuWME, initiatorName, respondersIterator);
	}

	
	sequential behavior SIU_groupStudyObject_root_responders_launch(SiuWME siuWME, String initiatorName, Iterator respondersIterator) {
		with (persistent when_succeeds)
			subgoal SIU_groupStudyObject_root_responders_launchLoop(siuWME, initiatorName, respondersIterator);
	}

	// spawn into this SIU's root parallel behavior 
	sequential behavior SIU_groupStudyObject_root_responders_launchLoop(SiuWME siuWME, String initiatorName, Iterator respondersIterator) {
		precondition { (respondersIterator.hasNext()) 					
						parentBehavior = (ParallelBehaviorWME signature == "SIU_groupStudyObject_root(SiuWME, String, CharactersWME)") }
		CharacterWME responderCharacterWME;
		mental_act { 
			responderCharacterWME = respondersIterator.next();
			log.info(responderCharacterWME.getName()+ " participating in " +siuNameGroupStudyObject+ " started by " +initiatorName);
		}
		
		spawngoal SIU_groupStudyObject_root_responder(siuWME, initiatorName, responderCharacterWME) at parentBehavior;
	}



	// ---------------------------------------
	// ---------------------------------------

	// ## INITIATOR ##
	
	sequential behavior SIU_groupStudyObject_root_initiator(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		subgoal createEpisodicMemoryWME(initiatorName, siuNameGroupStudyObject);
		subgoal SIU_groupStudyObject_root_initiator_perform(siuWME, initiatorName, responders);
        subgoal performanceCleanupForSiu(siuWME, initiatorName);
	}
	
	// PLAYER INITIATOR
	sequential behavior SIU_groupStudyObject_root_initiator_perform(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		precondition { (initiatorName.equals(playerName) == true) }
		mental_act { log.info(initiatorName+ " initiating groupStudyObject."); }		
		
		subgoal waitFor(500);	// fixme: needed to give time for responder behaviors to take root in root parallel behavior, otherwise the SIU will complete prematurely!		
	}
	
	// NPC INITIATOR
	sequential behavior SIU_groupStudyObject_root_initiator_perform(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		precondition { (initiatorName.equals(playerName) == false) }
		mental_act { log.info(initiatorName+ " ERROR: NPC showing the object is not currently supported. It should be the player showing the object currently."); }
	}
	
	
	// ## RESPONDER ##

	// don't perform in this SIU if we recently studied the object. 	
	sequential behavior SIU_groupStudyObject_root_responder(SiuWME siuWME, String initiatorName, CharacterWME responder) {
		precondition { 	epMemWME=(EpisodicMemoryWME)
						(responder!=null && epMemWME.getCharacterName().equals(responder.getName()) &&
						 epMemWME.getEpisodeName().equals(siuNameGroupStudyObject) &&
						 epMemWME.isMoreRecentThan(cRepetitiveGestureTimeout)) }
		specificity 2;
		mental_act {
			log.info(responder.getName()+ " not studying the object, already studied this object recently");
		}
	}
	
	sequential behavior SIU_groupStudyObject_root_responder(SiuWME siuWME, String initiatorName, CharacterWME responder) {
		specificity 1;
		String responderName;
		mental_act { 
			log.info(responder.getName()+ " studying the object held by " +initiatorName); 
			responderName = responder.getName(); 
		}

		subgoal createEpisodicMemoryWME(responderName, initiatorName, siuNameGroupStudyObject);

		subgoal SIU_groupStudyObject_root_responder_par(siuWME, responderName, initiatorName);
		
        subgoal performanceCleanupForSiu(siuWME, responderName);
	}


	parallel behavior SIU_groupStudyObject_root_responder_par(SiuWME siuWME, String responderName, String initiatorName) {
	
		// internally, this performs persistently
		subgoal testbed_studyOthersObject(siuWME, responderName, initiatorName, cPerformancePriorityMed); // not medhigh, so mirror can override
		
		with (persistent) subgoal SIU_groupStudyObject_responder_possiblySpawnABriefChat(responderName);
	}

	// ----------------------------------------------------------

	/*
	 * SIU_groupStudyObject_responder_possiblySpawnABriefChat
	 */
	sequential behavior SIU_groupStudyObject_responder_possiblySpawnABriefChat(String myName) {
		subgoal waitForRand(2000, 5000);
		mental_act { log.info(myName+ " considering brief chat in groupStudyObject"); }
		with (ignore_failure) 
			subgoal testbed_cif_possiblySpawnABriefChat(myName, false, 25, cPerformancePriorityMedMedHigh); // so can override studyOthersObject 	
	}
	
	/**
	 * SIU_personalSpace()
	 */	 	
	sequential behavior SIU_personalSpace(SiuWME siuWME) {
		CharacterWME initiator;
		CharactersWME responders;
		String initiatorName;
		
		mental_act {
			log.info("### " +siuWME.getInitiator().getName()+ " starting " +siuNamePersonalSpace+ " with " +siuWME.getResponders().getCharacterWMEs().size()+ " responders");
			initiator = siuWME.getInitiator();
			initiatorName = initiator.getName(); 
			responders = siuWME.getResponders(); 
		}
		
		with (ignore_failure)
			subgoal SIU_personalSpace_root(siuWME, initiatorName, responders);
		
		subgoal testbed_endSIU(siuWME);
	}

	parallel behavior SIU_personalSpace_root(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		context_condition { (siuWME.getState()==SiuExecutionState.EXECUTING) } 			
		Collection responderCharacters;
		Iterator respondersIterator;
		
		with (priority_modifier 1) mental_act {
			responderCharacters = responders.getCharacterWMEs();
			respondersIterator = responderCharacters.iterator();
		}
	
		// ## INITIATOR
		subgoal SIU_personalSpace_root_initiator(siuWME, initiatorName, responders);
		
		// ## RESPONDERS				
		with (ignore_failure) 
			subgoal SIU_personalSpace_root_responders_launch(siuWME, initiatorName, respondersIterator);
	}

	
	sequential behavior SIU_personalSpace_root_responders_launch(SiuWME siuWME, String initiatorName, Iterator respondersIterator) {
		with (persistent when_succeeds)
			subgoal SIU_personalSpace_root_responders_launchLoop(siuWME, initiatorName, respondersIterator);
	}

	// spawn into this SIU's root parallel behavior 
	sequential behavior SIU_personalSpace_root_responders_launchLoop(SiuWME siuWME, String initiatorName, Iterator respondersIterator) {
		precondition { (respondersIterator.hasNext()) 					
						parentBehavior = (ParallelBehaviorWME signature == "SIU_personalSpace_root(SiuWME, String, CharactersWME)") }
		CharacterWME responderCharacterWME;
		mental_act { 
			responderCharacterWME = respondersIterator.next();
			log.info(responderCharacterWME.getName()+ " participating in " +siuNamePersonalSpace+ " started by " +initiatorName);
		}
		
		spawngoal SIU_personalSpace_root_responder(siuWME, initiatorName, responderCharacterWME) at parentBehavior;
	}


	// ---------------------------------------
	// ---------------------------------------

	// ## INITIATOR ##
	
	sequential behavior SIU_personalSpace_root_initiator(SiuWME siuWME, String initiatorName, CharactersWME responders) {
		subgoal createEpisodicMemoryWME(initiatorName, siuNamePersonalSpace);
		subgoal SIU_personalSpace_root_initiator_perform(initiatorName, responders);
        subgoal performanceCleanupForSiu(siuWME, initiatorName);
	}

	// PLAYER INITIATOR	
	sequential behavior SIU_personalSpace_root_initiator_perform(String initiatorName, CharactersWME responders) {
		precondition { (initiatorName.equals(playerName) == true) }
		mental_act { log.info(initiatorName+ " participating in personalSpace as initiator"); }		
		
		subgoal waitFor(500);	// fixme: needed to give time for responder behaviors to take root in root parallel behavior, otherwise the SIU will complete prematurely!		
	}
	
	// NPC INITIATOR
	sequential behavior SIU_personalSpace_root_initiator_perform(String initiatorName, CharactersWME responders) {
		precondition { (initiatorName.equals(playerName) == false) }
		mental_act { log.info(initiatorName+ " participating in personalSpace as initiator"); }
	}
	
	
	// ## RESPONDER ##

	sequential behavior SIU_personalSpace_root_responder(SiuWME siuWME, String initiatorName, CharacterWME responder) {
		String responderName;
		
		mental_act { 
			log.info(responder.getName()+ " participating in personalSpace as responder to " +initiatorName); 
			responderName = responder.getName();
		}
		
		subgoal createEpisodicMemoryWME(responderName, initiatorName, siuNamePersonalSpace);		
		subgoal testbed_personalSpace(siuWME, responderName, initiatorName, cPerformancePriorityVeryHighest);			
        subgoal performanceCleanupForSiu(siuWME, responderName);
	}

		
	/**
	 * SIU_requestObject()
	 */	 	
	sequential behavior SIU_requestObject(SiuWME siuWME) {
		CharacterWME initiator;
		String initiatorName;
		String requesteeName;
		
		mental_act {
			log.info("### " +siuWME.getInitiator().getName()+ " starting " +siuNameRequestObject);
			initiator = siuWME.getInitiator();
			initiatorName = initiator.getName(); 
			requesteeName = siuWME.getResponders().get(0).getName();
		}

		subgoal OfferExpectationsForSIU(siuWME);
		
		with (ignore_failure)
			subgoal SIU_requestObject_root(siuWME, initiatorName, requesteeName);
			
		subgoal ClearExpectationsForSIU(siuWME);		
		subgoal testbed_endSIU(siuWME);
	}
	

	parallel behavior SIU_requestObject_root(SiuWME siuWME, String initiatorName, String requesteeName) {
		context_condition { (siuWME.getState()==SiuExecutionState.EXECUTING) } 			
	
		// ## INITIATOR
		subgoal SIU_requestObject_root_initiator(siuWME, initiatorName, requesteeName);
	}

	
	// ---------------------------------------
	// ---------------------------------------

	// ## INITIATOR ##
	
	sequential behavior SIU_requestObject_root_initiator(SiuWME siuWME, String initiatorName, String requesteeName) {
		subgoal createEpisodicMemoryWME(initiatorName, siuNameRequestObject);
		subgoal SIU_requestObject_root_initiator_perform(siuWME, initiatorName, requesteeName);
        subgoal performanceCleanupForSiu(siuWME, initiatorName);
	}
	
	sequential behavior SIU_requestObject_root_initiator_perform(SiuWME siuWME, String initiatorName, String requesteeName) {
		mental_act { log.info(initiatorName+ " performing requestObject"); }
		subgoal testbed_requestObject(siuWME, initiatorName, requesteeName, cPerformancePriorityHigh); 			
	}
	
	

	
	/**
	 * SIU_studyOwnObject()
	 */	 	
	sequential behavior SIU_studyOwnObject(SiuWME siuWME) {
		CharacterWME initiator;
		String initiatorName;
		String giverName;
		
		mental_act {
			log.info("### " +siuWME.getInitiator().getName()+ " starting " +siuNameStudyOwnObject);
			initiator = siuWME.getInitiator();
			initiatorName = initiator.getName(); 
			giverName = "";
		}
		
		with (ignore_failure)
			subgoal SIU_studyOwnObject_root(siuWME, initiatorName, giverName);
		
		subgoal testbed_endSIU(siuWME);
	}
	
	//Check to see if there is an episodic memory that exists of the siu
	//takeObjectFromPlayer that was enacted by this initiator.
   parallel behavior SIU_studyOwnObject_root(SiuWME siuWME, String initiatorName, String giverName) {
      context_condition { (siuWME.getState()==SiuExecutionState.EXECUTING) }     
      precondition {    epMemWME=(EpisodicMemoryWME)
            (initiatorName!=null && epMemWME.getCharacterName().equals(initiatorName) &&
             epMemWME.getEpisodeName().equals(siuNameTakeObjectFromPlayer)) }
      specificity 3;
   
      //We have an appropriate episodic memory. Take the recipient from this and store it as the giver.
      mental_act{
         giverName = epMemWME.getRecipientName();
      }
      
      // ## INITIATOR
      subgoal SIU_studyOwnObject_root_initiator(siuWME, initiatorName, giverName);
   }

   //There is no episodic memory that exists of the siu takeObjectFromPlayer
   //Therefore we don't know who the giver is, so leave it blank.
	parallel behavior SIU_studyOwnObject_root(SiuWME siuWME, String initiatorName, String giverName) {
		context_condition { (siuWME.getState()==SiuExecutionState.EXECUTING) } 			
		specificity 1;
	
		// ## INITIATOR
		subgoal SIU_studyOwnObject_root_initiator(siuWME, initiatorName, giverName);
	}

	
	// ---------------------------------------
	// ---------------------------------------

	// ## INITIATOR ##
	
	sequential behavior SIU_studyOwnObject_root_initiator(SiuWME siuWME, String initiatorName, String giverName) {
		subgoal createEpisodicMemoryWME(initiatorName, siuNameStudyOwnObject);
		subgoal SIU_studyOwnObject_root_initiator_perform(siuWME, initiatorName, giverName);
        subgoal performanceCleanupForSiu(siuWME, initiatorName);
	}
	
	sequential behavior SIU_studyOwnObject_root_initiator_perform(SiuWME siuWME, String initiatorName, String giverName) {
		mental_act { log.info(initiatorName+ " performing studyObject"); }
		subgoal testbed_studyOwnObject(siuWME, initiatorName, giverName, cPerformancePriorityHigh); // high, to override StudyOthersObject			
	}
	
	

	
	/**
	 * SIU_takeObjectFromPlayer()
	 */	 	
	sequential behavior SIU_takeObjectFromPlayer(SiuWME siuWME) {
		CharacterWME initiator;
		CharacterWME responder;
		CharactersWME responders;
		String initiatorName;
		String responderName;
		
		mental_act {
			log.info("### " +siuWME.getInitiator().getName()+ " starting " +siuNameTakeObjectFromPlayer+ " with " +siuWME.getResponders().getCharacterWMEs().size()+ " responders");
			initiator = siuWME.getInitiator();
			initiatorName = initiator.getName(); 
			responders = siuWME.getResponders(); 
			responder = responders.get(0); // I believe there should only ever be a single responder here.
			responderName = responder.getName();
		}
		
		with (ignore_failure)
			subgoal SIU_takeObjectFromPlayer_root(siuWME, initiatorName, responder);
		
		subgoal testbed_endSIU(siuWME);
	}

	// As it is currently written...
	// The player is intended to be the initiator.
	// The responder is the NPC that is taking the object from the player.
	// And if npc has already recently taken an object from the player, then they aren't going to want to do it again.
	parallel behavior SIU_takeObjectFromPlayer_root(SiuWME siuWME, String initiatorName, CharacterWME responder) {
		precondition { 	epMemWME=(EpisodicMemoryWME)
						(epMemWME.getCharacterName().equals(initiatorName) &&
						 epMemWME.getEpisodeName().equals(siuNameTakeObjectFromPlayer) &&
						 epMemWME.isMoreRecentThan(cRepetitiveGestureTimeout))
						(initiatorName.equals(playerName))						 
						}
		specificity 2;
		mental_act {
			log.info(initiatorName+ " will skip the " +siuNameTakeObjectFromPlayer+ ", already had an object taken from them.");
		}
	}
	
	parallel behavior SIU_takeObjectFromPlayer_root(SiuWME siuWME, String initiatorName, CharacterWME responder) {
		context_condition { (siuWME.getState()==SiuExecutionState.EXECUTING) } 			
		specificity 1;
	
		// ## INITIATOR
		subgoal SIU_takeObjectFromPlayer_root_initiator(siuWME, initiatorName, responder);
		
		// ## RESPONDERS				
		with (ignore_failure) 
			subgoal SIU_takeObjectFromPlayer_root_responder_launch(siuWME, initiatorName, responder);
	}

	
	sequential behavior SIU_takeObjectFromPlayer_root_responder_launch(SiuWME siuWME, String initiatorName, CharacterWME responder) {
		//with (persistent when_succeeds) // we're not looping
			subgoal SIU_takeObjectFromPlayer_root_responder_launchLoop(siuWME, initiatorName, responder);
	}

	// spawn into this SIU's root parallel behavior 
	sequential behavior SIU_takeObjectFromPlayer_root_responder_launchLoop(SiuWME siuWME, String initiatorName, CharacterWME responder) {
		precondition { 	//(respondersIterator.hasNext()) // we're not looping 
						parentBehavior = (ParallelBehaviorWME signature == "SIU_takeObjectFromPlayer_root(SiuWME, String, CharacterWME)") }
		mental_act { 
			log.info(responder.getName()+ " participating in " +siuNameTakeObjectFromPlayer+ " started by " +initiatorName);
		}
		
		spawngoal SIU_takeObjectFromPlayer_root_responder(siuWME, initiatorName, responder) at parentBehavior;
	}


	// ---------------------------------------
	// ---------------------------------------

	// ## INITIATOR ##
	
	sequential behavior SIU_takeObjectFromPlayer_root_initiator(SiuWME siuWME, String initiatorName, CharacterWME responder) {
		subgoal createEpisodicMemoryWME(initiatorName, siuNameTakeObjectFromPlayer);
		subgoal SIU_takeObjectFromPlayer_root_initiator_perform(initiatorName, responder);
        subgoal performanceCleanupForSiu(siuWME, initiatorName);
	}
	
	// PLAYER INITIATOR
	sequential behavior SIU_takeObjectFromPlayer_root_initiator_perform(String initiatorName, CharacterWME responder) {
		precondition { (initiatorName.equals(playerName) == true) }
		mental_act { log.info(initiatorName+ " participating in takeObjectFromPlayer as initiator"); }
		
		subgoal waitFor(500);	// fixme: needed to give time for responder behaviors to take root in root parallel behavior, otherwise the SIU will complete prematurely!		
	}
	
	// NPC INITIATOR
	//ERROR -- I do not believe we should hit this case -- the NPC is the responder here.
	sequential behavior SIU_greet_root_initiator_perform(String initiatorName, CharactersWME responders) {
		precondition { (initiatorName.equals(playerName) == false) }		
		mental_act { log.info(initiatorName+ " participating in take object from player as initiator -- ERROR -- only player should be initiato for this SIU"); }	
	}
	
	
	// ## RESPONDER ##

	// don't perform in this SIU if we recently took an object from the responder 	
	sequential behavior SIU_takeObjectFromPlayer_root_responder(SiuWME siuWME, String initiatorName, CharacterWME responder) {
		precondition { 	epMemWME=(EpisodicMemoryWME)
						(responder!=null && epMemWME.getCharacterName().equals(responder.getName()) &&
						 epMemWME.getEpisodeName().equals(siuNameTakeObjectFromPlayer) &&
						 epMemWME.isMoreRecentThan(cRepetitiveGestureTimeout)) }
		specificity 2;
		mental_act {
			log.info(responder.getName()+ " not taking an object from the player -- already done so recently.");
		}
	}
	
	sequential behavior SIU_takeObjectFromPlayer_root_responder(SiuWME siuWME, String initiatorName, CharacterWME responder) {
		specificity 1;
		String responderName;
		String idleAnim;
		float idleAnimDuration;
		
		mental_act { 
			log.info(responder.getName()+ " participating in taking object from player as responder to " +initiatorName); 
			responderName = responder.getName(); 			
		}
		
		subgoal headTrack(responderName, initiatorName);		
	
		subgoal createEpisodicMemoryWME(responderName, initiatorName, siuNameTakeObjectFromPlayer);

		subgoal testbed_takeObjectFromCharacter(siuWME, responderName, initiatorName, cPerformancePriorityHigh);
		
      	subgoal performanceCleanupForSiu(siuWME, responderName);
	}



	/**
	 * testbed_waitForSIUToStart()
	 */	 		
	sequential behavior testbed_waitForSIUToStart(String myName, String siuName) {
		subgoal testbed_waitForSIUToStartAndStop(myName, siuName, false);
	}

	/**
	 * testbed_waitForSIUToStartAndStop()
	 */	 		
	sequential behavior testbed_waitForSIUToStartAndStop(String myName, String siuName) {
		subgoal testbed_waitForSIUToStartAndStop(myName, siuName, true);
	}
		 
	sequential behavior testbed_waitForSIUToStartAndStop(String myName, String siuName, boolean bWaitForStop) {
		SiuWME siuWME;
	
		mental_act { log.info(myName+ " waiting for " +siuName+ " to start and stop"); }
	
		with (success_test { siuWME=(SiuWME)
							 (siuWME.getName().equals(siuName) &&
							  siuWME.getState()==SiuExecutionState.EXECUTING &&						 
							  siuWME.containsCharacter(myName)) } ) wait;

		// possibly also wait for this particular SIU to stop
		with (ignore_failure) subgoal testbed_waitForSIUToStop(siuWME, bWaitForStop);				  
	}

	sequential behavior testbed_waitForSIUToStop(SiuWME siuWME, boolean bWaitForStop) {
		precondition { (bWaitForStop == true) }
		with (success_test {  (siuWME.getState()==SiuExecutionState.TERMINATED) } ) wait;
	}
	

	/**
	 * testbed_endSIU()
	 */	 	
	atomic sequential behavior testbed_endSIU(SiuWME siuWME) {
        mental_act {
        	log.info("## " +siuWME.getName()+ " ending");
			siuWME.setState(SiuExecutionState.TERMINATED);
        } 
        
        subgoal performanceCleanupForAllInSiu(siuWME);      
	}

	
	/**
	 * siu_requestTermination()
	 */	 
	atomic sequential behavior siu_requestTermination(String siuName, String initiatorName) {
		precondition {	siuWME=(SiuWME)
						(siuWME.getName().equals(siuName) && 
						 siuWME.getState()==SiuExecutionState.EXECUTING &&						 
						 siuWME.getInitiator().getName().equals(initiatorName)) }
        specificity 2;
        mental_act {
        	log.info("## " +initiatorName+ " requesting termination of " +siuName);
			siuWME.setState(SiuExecutionState.REQUESTED_TERMINATION);
        }

		// don't do this here -- this cleanup will happen when the SIU actually ends
        //subgoal performanceCleanupForAllInSiu(siuWME);      
	}
	
	atomic sequential behavior siu_requestTermination(String siuName, String initiatorName) {
        specificity 1;
        mental_act { log.info("## WARNING: " +initiatorName+ " cannot find " +siuName+ " to request termination"); }
	}	


	atomic sequential behavior siu_requestTermination(SiuWME siuWME) {
		mental_act { siuWME.setState(SiuExecutionState.REQUESTED_TERMINATION); } 
	}


	
	/**
	 * siu_requestTerminationAllOfSIUsWith()
	 */	 
	atomic sequential behavior siu_requestTerminationAllOfSIUsWith(String myName) {
		precondition {	siuWME=(SiuWME)
						(siuWME.getState()==SiuExecutionState.EXECUTING &&						 
						 siuWME.containsCharacter(myName)) }
		specificity 2;						 
        mental_act {
        	log.info("## Requesting termination of " +siuWME.getName()+ " with " +myName);
			siuWME.setState(SiuExecutionState.REQUESTED_TERMINATION);
        }
        
        // recursively terminate all SIUs
        with (ignore_failure) subgoal siu_requestTerminationAllOfSIUsWith(myName);
	}

	atomic sequential behavior siu_requestTerminationAllOfSIUsWith(String myName) {
		specificity 1;
        mental_act {
        	log.info("## Requested termination of SIUs with " +myName+ " complete");
        }
	}

	
	/**
	 * siu_requestTerminationOfAllAnSIUInGroup()
	 * e.g. terminate all BriefChats occurring in this group 
	 */	 
	atomic sequential behavior siu_requestTerminationOfAllAnSIUInGroup(String myName, String siuName) {
		precondition {	siuWME=(SiuWME)
						(siuWME.getName().equals(siuName) &&
						 siuWME.getState()==SiuExecutionState.EXECUTING)

						myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName))
                     	groupWME=(GroupWME) 
                     	(groupWME.contains(myCharacterWME) && groupWME.contains(siuWME.getInitiator()))
                     	}
		specificity 2;						 
        mental_act {
        	log.info("## Requesting termination of SIUs of " +siuName+ " in group containing " +myName);
			siuWME.setState(SiuExecutionState.REQUESTED_TERMINATION);
        }
        
        // recursively terminate all SIUs
        with (ignore_failure) subgoal siu_requestTerminationOfAllAnSIUInGroup(myName, siuName);
	}

	atomic sequential behavior siu_requestTerminationOfAllAnSIUInGroup(String myName, String siuName) {
		specificity 1;
        mental_act {
        	log.info("## Requested termination of SIUs of " +siuName+ " in group containing " +myName+ " complete");
        }
	}


   /**
    * siu_requestEarlyTransitionOut()
    */
	atomic sequential behavior siu_requestEarlyTransitionOut(SiuWME siuWME) {
		mental_act { siuWME.setState(SiuExecutionState.REQUEST_EARLY_TRANSITION_OUT); } 
	}


   /**
    * testbed_answerQuestion()
    */      
   sequential behavior testbed_answerQuestion(SiuWME siuWME, String responderName, String questionerName, int performancePriority) {
      precondition { observerPhysicalWME = (PhysicalAgentWME)
            (observerPhysicalWME.getId().equals(responderName))    
      }
      PerformanceWME performanceWME;
      mental_act {
         //log.info("## " +responderName+ " preparing for testbed_answerQuestion from " +questionerName); 
         performanceWME = new PerformanceWME(siuWME); 
      }
      
      subgoal setupPerformanceWME(performanceWME, siuWME, responderName, performancePriority, "testbed_answerQuestion");
      with (persistent when_fails) subgoal testbed_answerQuestion(responderName, questionerName, performanceWME);
      subgoal performanceDoneDeleteWME(performanceWME);
      
      //subgoal headTrack(responderName, objectEyeLineLocation);
   }   

	// ## LEADER ##   
   sequential behavior testbed_answerQuestion(String myName, String targetName, PerformanceWME performanceWME) {
		precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
						(myCharacterWME.hasAttitude(eAttitudeType_leader))
						} 
			 
   		specificity 2;
   
		subgoal headTrack(myName, targetName);		
      	subgoal testbed_setFacialExpression(myName, animationFaceStony);
      	subgoal performAnimation_portion(myName, targetName, animationNoticeGestureStarting, cAnimDefaultStartTime, 1.5);
		subgoal headTrack(myName, targetName);		
      	subgoal performAnimation_portion(myName, targetName, animationScratchChin, cAnimDefaultStartTime, 2.5);
		subgoal headTrack(myName, targetName);		
      	subgoal performAnimation_portion(myName, targetName, animationAkimboBothArms, cAnimDefaultStartTime, 1.0);

		spawngoal cif_startCutScene();

		subgoal headTrack(myName, targetName);		
		spawngoal speakDialogue(myName, dialogue_thai_YouComeHereActLikeYouOwnOurCountryAndYouCantEvenSpeakOurLanguage, true, dialogue_gender_male, dialogue_tone_dominant);
		
		// manufacture a pointing signal - fixme - shouldn't be NPC20
		subgoal createSocialSignalWME(socialInterpretationPointLeft, myName, playerName, "NPC20");
		
      	subgoal performAnimation_portion(myName, targetName, animationPointIntoDistanceL, cAnimDefaultStartTime, cAnimDefaultEndTime);
      	subgoal performAnimation_portion(myName, targetName, animationPointIntoDistanceLIdle, cAnimDefaultStartTime, 1.0);
      	subgoal performAnimation_portion(myName, targetName, animationPointIntoDistanceLEmphasis, cAnimDefaultStartTime, cAnimDefaultEndTime);
      	subgoal performAnimation_portion(myName, targetName, animationPointIntoDistanceLIdle, cAnimDefaultStartTime, cAnimDefaultEndTime);
      	subgoal performAnimation_portion(myName, targetName, animationAkimboBothArms, cAnimDefaultStartTime, cAnimDefaultEndTime);

		subgoal headTrack(myName, targetName);		
      	subgoal testbed_setFacialExpression(myName, animationFaceSmile);
		spawngoal speakDialogue(myName, dialogue_thai_JustBecauseYouHaveAGunYouThinkYouCanBossEverybodyAround, true, dialogue_gender_male, dialogue_tone_neutral);
      	subgoal performAnimation_portion(myName, targetName, animationPointIntoDistanceL, cAnimDefaultStartTime, cAnimDefaultEndTime);
      	subgoal performAnimation_portion(myName, targetName, animationPointIntoDistanceLIdle, cAnimDefaultStartTime, 1.0);
      	subgoal performAnimation_portion(myName, targetName, animationPointIntoDistanceLEmphasis, cAnimDefaultStartTime, cAnimDefaultEndTime);
      	subgoal performAnimation_portion(myName, targetName, animationPointIntoDistanceLIdle, cAnimDefaultStartTime, cAnimDefaultEndTime);
   }
   
   
   // ## DEFAULT ##
   sequential behavior testbed_answerQuestion(String myName, String targetName, PerformanceWME performanceWME) {
   		specificity 1;
   		int duration;
   		mental_act { duration = Staging.randRange(5000, 10000); }
   		
		subgoal performanceWait(performanceWME);
		subgoal testbed_answerQuestion_perform_withTimeout(myName, targetName, duration, performanceWME);
   }
            
   parallel behavior testbed_answerQuestion_perform_withTimeout(String myName, String targetName, int duration, PerformanceWME performanceWME) {
		number_needed_for_success 1;
		subgoal testbed_answerQuestion_perform(myName, targetName, performanceWME);
      	subgoal waitFor(duration);
   }
   
   sequential behavior testbed_answerQuestion_perform(String myName, String targetName, PerformanceWME performanceWME) {
		precondition { myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) } 
		context_condition {  (performanceWME.getPerformanceState() == cPerformanceStatePerforming) }
		String anim;
		float duration;
		boolean bPointAtOtherGroup;
		Location faceLocation;
		
		mental_act { 
			bPointAtOtherGroup = (myCharacterWME.hasAttitude(eAttitudeType_hostile) == false);
			faceLocation = null; 
			if (bPointAtOtherGroup) {
				// fixme demo hack -- want to dynamically determine this
				faceLocation = new Location(-10.0, cCharacterHeight, 76.0);
			}
		}
		 							 		
		// answer
      	subgoal testbed_answerQuestion_perform_glancing(myName, targetName, true, bPointAtOtherGroup, faceLocation);
      
        // vary the performance and glancing
      	with (persistent) subgoal testbed_answerQuestion_perform_glancing(myName, targetName, false, bPointAtOtherGroup, faceLocation);
   }

	// First glance   
   sequential behavior testbed_answerQuestion_perform_glancing(String myName, String targetName, boolean bFirstGlance, boolean bPointAtOtherGroup, Location faceLocation) {
		precondition { (bFirstGlance == true) } 
		String anim;
		String faceAnim;
        ReturnValueWME retValWME;
        String audio;
        String tone;
		
		mental_act { retValWME = new ReturnValueWME(); }
        subgoal testbed_getRandomDialog(retValWME, false);
		mental_act {
			anim = bPointAtOtherGroup ? animationPointIntoDistanceR : animationPointIntoDistanceL; 
			faceAnim = animationFaceBigSmile; 
        	audio = retValWME.getString();
        	tone = retValWME.getString2();
		}
      
      	subgoal testbed_answerQuestion_perform_facing(myName, targetName, faceLocation);
      			
      	subgoal testbed_setFacialExpression(myName, faceAnim);                
		spawngoal speakDialogue(myName, audio, true, dialogue_gender_male, tone);
		
		// manufacture a pointing signal - fixme - shouldn't be NPC07
		subgoal createSocialSignalWME(socialInterpretationPointLeft, myName, playerName, "NPC07");
		
      	subgoal performAnimation(myName, targetName, anim);
   }


	sequential behavior testbed_answerQuestion_perform_facing(String myName, String targetName, Location faceLocation) {
		precondition { (faceLocation != null) }
		specificity 2;
		subgoal headTrack(myName, targetName);	
		subgoal turnToFacingPoint(myName, faceLocation);
	}
      	
	sequential behavior testbed_answerQuestion_perform_facing(String myName, String targetName, Location faceLocation) {
		specificity 1;
		subgoal headTrack(myName, targetName);	
	}
      	

   
   // Glance at point target -- fixme
   sequential behavior testbed_answerQuestion_perform_glancing(String myName, String targetName, boolean bFirstGlance, boolean bPointAtOtherGroup, Location faceLocation) {
   	precondition { (bFirstGlance == false) }
		String anim;
		float duration;
		String faceAnim;
        ReturnValueWME retValWME;
        String audio;
        String tone;
		
		mental_act { retValWME = new ReturnValueWME(); }
        subgoal testbed_getRandomDialog(retValWME, false);
		
		subgoal headTrack(myName, targetName);	

		mental_act {
			anim = bPointAtOtherGroup ? animationPointIntoDistanceRIdle : animationPointIntoDistanceLIdle;
			duration = (float)Staging.randRange(1.0, 2.0);
			audio = "";
			tone = "";
			 
			if (Staging.percentChance(50)) { 
				anim = bPointAtOtherGroup ? animationPointIntoDistanceREmphasis : animationPointIntoDistanceLEmphasis; 
				duration = (float)Staging.randRange(2.0, 3.0); 
	        	audio = retValWME.getString();
	        	tone = retValWME.getString2();
			} 
			faceAnim = animationFaceBigSmile; 
		}

		spawngoal speakDialogue(myName, audio, true, dialogue_gender_male, tone);
      
      	subgoal testbed_setFacialExpression(myName, faceAnim);
      	subgoal performAnimation_portion(myName, targetName, anim, cAnimDefaultStartTime, duration);
   }

   
   // Glance at another group member
   sequential behavior testbed_answerQuestion_perform_glancing(String myName, String targetName, boolean bFirstGlance, boolean bPointAtOtherGroup, Location faceLocation) {
   	precondition { (bFirstGlance == false && Staging.percentChance(20)) 
      				myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
            		groupWME=(GroupWME) (groupWME.contains(myCharacterWME))
         }      
      
      CharactersWME othersInFormationCharactersWME;
      String glancePerson;
		String anim;
		float duration;
		String faceAnim;

      // get list of other characters in the formation
      mental_act {
          othersInFormationCharactersWME = GroupUtil.cloneAndRemoveSelf(myName, groupWME.getFormationCharactersWME());
          glancePerson = othersInFormationCharactersWME.getRandom().getName();
          log.info("## " +myName+ " performing testbed_answerQuestion_perform_glancing at " + glancePerson);
      }
      
		subgoal headTrack(myName, targetName);	
      
		mental_act {
			anim = bPointAtOtherGroup ? animationPointIntoDistanceR : animationPointIntoDistanceL; 
			faceAnim = animationFaceBigSmile; 
			duration = (float)Staging.randRange(1.0, 2.0); 
		}
		
      	subgoal testbed_setFacialExpression(myName, faceAnim);
      	subgoal performAnimation_portion(myName, targetName, anim, cAnimDefaultStartTime, duration);
   }
   
   

	/**
	 * testbed_backgroundNPC_launch()
	 */	 	
	sequential behavior testbed_backgroundNPC_launch() {
		precondition { characterWME=(CharacterWME) 
		              (characterWME.getName().equals("NPC21") == true) }
		specificity 2;
		
		mental_act { log.info("testbed_backgroundNPC_launch FOUND NPC21"); }
		subgoal testbed_backgroundNPC_rootParallel();
	}
	
	sequential behavior testbed_backgroundNPC_launch() {
		specificity 1;
		mental_act { log.info("testbed_backgroundNPC_launch NPC21 not found :("); }
	}
	
	parallel behavior testbed_backgroundNPC_rootParallel() {
		//with (persistent) subgoal printPlayerLocation();
		with (persistent) subgoal testbed_backgroundNPC_walkShortPath("NPC21");
		with (persistent) subgoal testbed_backgroundNPC_walkMediumPath("NPC22");
		with (persistent) subgoal testbed_backgroundNPC_walkLongPath("NPC23");
	}
	
	sequential behavior testbed_backgroundNPC_walkShortPath(String myName){
		subgoal testbed_backgroundNPC_walkTo_pivot1(myName);
		subgoal waitForRand(200, 300);
		subgoal testbed_backgroundNPC_walkTo_door2(myName);
		subgoal waitForRand(1000, 2000);
		subgoal testbed_backgroundNPC_walkTo_stall1(myName);
		subgoal waitForRand(300, 500);
		subgoal testbed_backgroundNPC_walkTo_bulletin1(myName);
		subgoal waitForRand(300, 500);
		subgoal testbed_backgroundNPC_walkTo_start(myName);
		subgoal waitForRand(300, 500);
		
	}
	
	sequential behavior testbed_backgroundNPC_walkMediumPath(String myName){
		subgoal waitForRand(8000, 10000);
		subgoal testbed_backgroundNPC_walkTo_start(myName);
		subgoal waitForRand(200, 300);
		subgoal testbed_backgroundNPC_walkTo_pivot1(myName);
		subgoal waitForRand(200, 300);
		subgoal testbed_backgroundNPC_walkTo_stall1(myName);
		subgoal waitForRand(1000, 2000);
		subgoal testbed_backgroundNPC_walkTo_door1(myName);
		subgoal waitForRand(1000, 2000);
		subgoal testbed_backgroundNPC_walkTo_door2(myName);
		subgoal waitForRand(1000, 2000);
		subgoal testbed_backgroundNPC_walkTo_stall2(myName);
		subgoal waitForRand(1000, 2000);
		subgoal testbed_backgroundNPC_walkTo_alley2(myName);
		subgoal waitForRand(100, 500);
		subgoal testbed_backgroundNPC_walkTo_downAlley2(myName);
		subgoal waitForRand(500, 1000);
		subgoal testbed_backgroundNPC_walkTo_alley2(myName);
		subgoal waitForRand(100, 500);
		subgoal testbed_backgroundNPC_walkTo_door2(myName);
		subgoal waitForRand(500, 1000);
		subgoal testbed_backgroundNPC_walkTo_stall1(myName);
		subgoal waitForRand(1000, 2000);
		subgoal testbed_backgroundNPC_walkTo_pivot1(myName);
		subgoal waitForRand(200, 300);
		subgoal testbed_backgroundNPC_walkTo_stall0(myName);
		subgoal waitForRand(1000, 2000);
		subgoal testbed_backgroundNPC_walkTo_start(myName);
		subgoal waitForRand(500, 1000);
	}
	
	sequential behavior testbed_backgroundNPC_walkLongPath(String myName){
		subgoal waitForRand(10000, 20000);
		subgoal testbed_backgroundNPC_walkTo_stall0(myName);
		subgoal waitForRand(1000, 2000);
		subgoal testbed_backgroundNPC_walkTo_bulletin1(myName);
		subgoal waitForRand(1000, 2000);
		subgoal testbed_backgroundNPC_walkTo_stall1(myName);
		subgoal waitForRand(1000, 2000);
		subgoal testbed_backgroundNPC_walkTo_door1(myName);
		subgoal waitForRand(1000, 2000);
		subgoal testbed_backgroundNPC_walkTo_door2(myName);
		subgoal waitForRand(1000, 2000);
		subgoal testbed_backgroundNPC_walkTo_stall2(myName);
		subgoal waitForRand(1000, 2000);
		subgoal testbed_backgroundNPC_walkTo_stall3(myName);
		subgoal waitForRand(1000, 3000);
		subgoal testbed_backgroundNPC_walkTo_alley2(myName);
		subgoal waitForRand(1000, 2000);
		subgoal testbed_backgroundNPC_walkTo_door3(myName);
		subgoal waitForRand(1000, 3000);
		subgoal testbed_backgroundNPC_walkTo_alley2(myName);
		subgoal waitForRand(500, 1000);
		subgoal testbed_backgroundNPC_walkTo_downAlley2(myName);
		subgoal waitForRand(1000, 2000);
		subgoal testbed_backgroundNPC_walkTo_alley2(myName);
		subgoal waitForRand(500, 1000);
		subgoal testbed_backgroundNPC_walkTo_stall2(myName);
		subgoal waitForRand(1000, 2000);
		subgoal testbed_backgroundNPC_walkTo_pivot1(myName);
		subgoal waitForRand(200, 300);
		subgoal testbed_backgroundNPC_walkTo_door0(myName);
		subgoal waitForRand(1000, 2000);
		subgoal testbed_backgroundNPC_walkTo_stall0(myName);
		subgoal waitForRand(1000, 2000);
		subgoal testbed_backgroundNPC_walkTo_start(myName);
		subgoal waitForRand(1000, 2000);
	}
	
	/** Used for bookmarking walking locations **/
	sequential behavior printPlayerLocation(){
		precondition { playerPhysicalWME=(PhysicalAgentWME)
                     	(playerPhysicalWME.getId().equals(playerName)) }
		mental_act{
			log.info("~~~ Player Location: " + playerPhysicalWME.getLocation());
			log.info("*** Player Orientation: " + playerPhysicalWME.getOrientation());
		}
		
		subgoal waitFor(1000);
	}
	
	sequential behavior testbed_backgroundNPC_walkTo_start(String myName) {
        Location pointToWalkTo;
        mental_act{ pointToWalkTo = new Location(13.9,0,55.2); }
		subgoal walkToPoint(myName, pointToWalkTo);
	}
	
	sequential behavior testbed_backgroundNPC_walkTo_stall0(String myName) {
        Location pointToWalkTo;
        double angleToOrientTo;
        mental_act{ pointToWalkTo = new Location(10.3382, 0, 45.1891); angleToOrientTo = 255.9668; }
		subgoal walkToPoint(myName, pointToWalkTo);
		subgoal turnToAngle_NEW(myName, angleToOrientTo);
	}
	
	sequential behavior testbed_backgroundNPC_walkTo_door0(String myName) {
        Location pointToWalkTo;
        double angleToOrientTo;
        mental_act{ pointToWalkTo = new Location(20.8488, 0, 48.0429); angleToOrientTo = 80.21618; }
		subgoal walkToPoint(myName, pointToWalkTo);
		subgoal turnToAngle_NEW(myName, angleToOrientTo);
	}
	
	sequential behavior testbed_backgroundNPC_walkTo_pivot1(String myName) {
        Location pointToWalkTo;
        mental_act{ pointToWalkTo = new Location(12.3357, 0, 30.3995); }
		subgoal walkToPoint(myName, pointToWalkTo);
	}
	
	sequential behavior testbed_backgroundNPC_walkTo_bulletin1(String myName) {
        Location pointToWalkTo;
        double angleToOrientTo;
        mental_act{ pointToWalkTo = new Location(20.7095, 0, 31.0740); angleToOrientTo = 140.9649; }
		subgoal walkToPoint(myName, pointToWalkTo);
		subgoal turnToAngle_NEW(myName, angleToOrientTo);
	}
	
	sequential behavior testbed_backgroundNPC_walkTo_stall1(String myName) {
        Location pointToWalkTo;
        mental_act{ pointToWalkTo = new Location(12.47, 0, 33.63); }
		subgoal walkToPoint(myName, pointToWalkTo);
	}
	
	sequential behavior testbed_backgroundNPC_walkTo_door1(String myName) {
        Location pointToWalkTo;
        double angleToOrientTo;
        mental_act{ pointToWalkTo = new Location(9.29, 0, 25.57); angleToOrientTo = 179.4638; }
		subgoal walkToPoint(myName, pointToWalkTo);
		subgoal turnToAngle_NEW(myName, angleToOrientTo);
	}
	
	sequential behavior testbed_backgroundNPC_walkTo_door2(String myName) {
        Location pointToWalkTo;
        mental_act{ pointToWalkTo = new Location(-2.77, 0, 24.98); }
		subgoal walkToPoint(myName, pointToWalkTo);
	}
	
	sequential behavior testbed_backgroundNPC_walkTo_stall2(String myName) {
        Location pointToWalkTo;
        mental_act{ pointToWalkTo = new Location(-3.27, 0, 39.34); }
		subgoal walkToPoint(myName, pointToWalkTo);
	}
	
	sequential behavior testbed_backgroundNPC_walkTo_stall3(String myName) {
        Location pointToWalkTo;
        mental_act{ pointToWalkTo = new Location(-9.64, 0, 27.51); }
		subgoal walkToPoint(myName, pointToWalkTo);
	}
	
	sequential behavior testbed_backgroundNPC_walkTo_alley2(String myName) {
        Location pointToWalkTo;
        mental_act{ pointToWalkTo = new Location(-18.915, 0, 30.56); }
		subgoal walkToPoint(myName, pointToWalkTo);
	}
	
	sequential behavior testbed_backgroundNPC_walkTo_downAlley2(String myName) {
        Location pointToWalkTo;
        mental_act{ pointToWalkTo = new Location(-30.66, 0, 20.61); }
		subgoal walkToPoint(myName, pointToWalkTo);
	}
	
	sequential behavior testbed_backgroundNPC_walkTo_door3(String myName) {
        Location pointToWalkTo;
        double angleToOrientTo;
        mental_act{ pointToWalkTo = new Location(-23.24, 0, 51.47); angleToOrientTo = 264.2064; }
		subgoal walkToPoint(myName, pointToWalkTo);
		subgoal turnToAngle_NEW(myName, angleToOrientTo);
	}
	
   /**
    * testbed_briefChat()
    */      
   sequential behavior testbed_briefChat(SiuWME siuWME, String myName, String initiator, String responder, boolean bLongerChat, int performancePriority) {
      PerformanceWME performanceWME;
      mental_act {
         //log.info("## " +myName+ " preparing for testbed_briefChat with " +initiator+ " and " +responder); 
         performanceWME = new PerformanceWME(siuWME); 
      }
      
      subgoal setupPerformanceWME(performanceWME, siuWME, myName, performancePriority, "testbed_briefChat");
      
      // Unlike most behaviors, let's not try to restart this brief chat if it gets interrupted
      //with (persistent when_fails) 
      with (ignore_failure) 
      	subgoal testbed_briefChat(myName, initiator, responder, bLongerChat, performanceWME);
      	
      subgoal performanceDoneDeleteWME(performanceWME);      
   }   
   
   sequential behavior testbed_briefChat(String myName, String initiator, String responder, boolean bLongerChat, PerformanceWME performanceWME) {
		subgoal performanceWait(performanceWME);
		subgoal testbed_briefChat_perform(myName, initiator, responder, bLongerChat, performanceWME);
   }

	// ## INITIATOR ##               
	sequential behavior testbed_briefChat_perform(String myName, String initiator, String responder, boolean bLongerChat, PerformanceWME performanceWME) {
   		precondition {	(myName.equals(initiator) == true)
   						myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) } 
		context_condition { (performanceWME.getPerformanceState() == cPerformanceStatePerforming) }
		
		// speak, listen, speak, listen		
		subgoal testbed_briefChat_perform_speak(myName, myCharacterWME, responder, true);
		subgoal testbed_briefChat_perform_listen(myName, myCharacterWME, responder, true);
		with (ignore_failure) subgoal testbed_briefChat_perform_speak(myName, myCharacterWME, responder, bLongerChat);
		with (ignore_failure) subgoal testbed_briefChat_perform_listen(myName, myCharacterWME, responder, bLongerChat);
	}

	// ## RESPONDER ##               
	sequential behavior testbed_briefChat_perform(String myName, String initiator, String responder, boolean bLongerChat, PerformanceWME performanceWME) {
   		precondition {	(myName.equals(initiator) == false) 
   						myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) } 
		context_condition { (performanceWME.getPerformanceState() == cPerformanceStatePerforming) }
		
		// listen, speak, listen, speak		
		subgoal testbed_briefChat_perform_listen(myName, myCharacterWME, initiator, true);
		subgoal testbed_briefChat_perform_speak(myName, myCharacterWME, initiator, true);
		with (ignore_failure) subgoal testbed_briefChat_perform_listen(myName, myCharacterWME, initiator, bLongerChat);
		with (ignore_failure) subgoal testbed_briefChat_perform_speak(myName, myCharacterWME, initiator, bLongerChat);
	}

	sequential behavior testbed_briefChat_perform_speak(String myName, CharacterWME myCharacterWME, String listenerName, boolean bPerform) {
		precondition {	(bPerform == true)  
	            		groupWME=(GroupWME) (groupWME.contains(myCharacterWME))
						}
						
        ReturnValueWME retValWME;
        ReturnValueWME retValWME2;
        String anim;
        String audio;
        String tone;
        float duration;
                
        mental_act {        	
			retValWME = new ReturnValueWME(); 
		}
        subgoal testbed_getRandomDialog(retValWME, true);
        mental_act {
        	anim = "";
        	audio = retValWME.getString();
        	tone = retValWME.getString2();
        	duration = (float)Staging.randRange(1.0, 2.5);
        	
			if (myCharacterWME.hasAttitude(eAttitudeType_leader)) {
				anim = animationArmsCrossedRefusal1;
				if (Staging.percentChance(50)) anim = animationArmsCrossedRefusal2;
	        	duration = cAnimDefaultEndTime;
	        	tone = dialogue_tone_dominant; 
	        	if (Staging.percentChance(75)) audio = "";	// leader probably doesn't speak
	        	
			} else if (myCharacterWME.hasAttitude(eAttitudeType_sympathetic)) {
				anim = animationGestureExplain1;
	        	tone = dialogue_tone_cooperative; 
	        	duration = cAnimDefaultEndTime;
	        	
			} else if (groupWME.getLeaderCharacter() != null) {
	        	tone = dialogue_tone_cooperative; 
			}        	
        }

		subgoal headTrack(myName, listenerName);
		subgoal testbed_briefChat_perform_speak_par(myName, listenerName, duration, anim, audio, tone);
	}
	
	parallel behavior testbed_briefChat_perform_speak_par(String myName, String listenerName, float duration,
															String anim, String audio, String tone) {
		precondition { (anim.equals("") == false) }															
		specificity 2;															
		subgoal performAnimation_portion(myName, myName, anim, cAnimDefaultStartTime, duration);
		with (effect_only, ignore_failure) subgoal speakDialogue(myName, audio, true, dialogue_gender_male, tone);
	}
	
	parallel behavior testbed_briefChat_perform_speak_par(String myName, String listenerName, float duration,
															String anim, String audio, String tone) {
		specificity 1;															
		subgoal performWithAttitude(myName, eAttitudePerform_speak, duration);
		with (effect_only, ignore_failure) subgoal speakDialogue(myName, audio, true, dialogue_gender_male, tone);
	}

			
	// refusal gesture
	sequential behavior testbed_briefChat_perform_listen(String myName, CharacterWME myCharacterWME, String speakerName, boolean bPerform) {
		precondition { (bPerform == true && myCharacterWME.hasAttitude(eAttitudeType_leader)) }
        specificity 2;
        String anim;
        mental_act {
			anim = animationArmsCrossedRefusal1Idle;
			if (Staging.percentChance(50)) anim = animationArmsCrossedRefusal2Idle;
        }

		subgoal headTrack(myName, speakerName);
		subgoal performAnimation_portion(myName, myName, anim, cAnimDefaultStartTime, cAnimDefaultEndTime);
	}

	sequential behavior testbed_briefChat_perform_listen(String myName, CharacterWME myCharacterWME, String speakerName, boolean bPerform) {
		precondition { (bPerform == true) }
        specificity 1;
        float duration;        
        mental_act { duration = (float)Staging.randRange(1.0, 2.5); }
		subgoal performWithAttitude(myName, eAttitudePerform_listen, duration);
	}

	
   /**
    * testbed_confused()
    */      
   sequential behavior testbed_confused(SiuWME siuWME, String responderName, String questionerName, int performancePriority) {
      precondition { observerPhysicalWME = (PhysicalAgentWME)
            (observerPhysicalWME.getId().equals(responderName))    
      }
      PerformanceWME performanceWME;
      mental_act {
         //log.info("## " +responderName+ " preparing for testbed_confused from " +questionerName); 
         performanceWME = new PerformanceWME(siuWME); 
      }
      
      subgoal setupPerformanceWME(performanceWME, siuWME, responderName, performancePriority, "testbed_confused");
      
      // Unlike most behaviors, let's not try to restart this response if it gets interrupted
      // this is because briefChat may interrupt it
      //with (persistent when_fails) 
      with (ignore_failure) 
      	subgoal testbed_confused(responderName, questionerName, performanceWME);
      	
      subgoal performanceDoneDeleteWME(performanceWME);
      
      //subgoal headTrack(responderName, objectEyeLineLocation);
   }   
   
   sequential behavior testbed_confused(String myName, String targetName, PerformanceWME performanceWME) {
   		int duration;
   		mental_act { duration = Staging.randRange(8000, 12000); }
   		
		subgoal performanceWait(performanceWME);
		subgoal testbed_confused_perform_withTimeout(myName, targetName, duration, performanceWME);
   }
            
   parallel behavior testbed_confused_perform_withTimeout(String myName, String targetName, int duration, PerformanceWME performanceWME) {
		number_needed_for_success 1;
		subgoal testbed_confused_perform(myName, targetName, performanceWME);
      	subgoal waitFor(duration);
   }
   
   sequential behavior testbed_confused_perform(String myName, String targetName, PerformanceWME performanceWME) {
      context_condition {  (performanceWME.getPerformanceState() == cPerformanceStatePerforming) }
		String anim;
		float duration;
		boolean bSecondReaction;
		
		mental_act { bSecondReaction = Staging.percentChance(70); }
		 		
		// react to it
      	subgoal testbed_confused_perform_glancing(myName, targetName, true);
      
        // vary the reaction and glancing
      	with (persistent) subgoal testbed_confused_perform_glancing(myName, targetName, false);
   }

	// First glance - look quizzical   
   sequential behavior testbed_confused_perform_glancing(String myName, String targetName, boolean bFirstGlance) {
		precondition { (bFirstGlance == true) } 
		String anim;
		float duration;
		String faceAnim;
		
		subgoal headTrack(myName, targetName);

		mental_act {
			if (Staging.percentChance(25)) anim = animationListenHeadCockLeft1;
			else if (Staging.percentChance(25)) anim = animationListenHeadCockLeft2;
			else if (Staging.percentChance(25)) anim = animationListenHeadCockRight1;
			else anim = animationListenHeadCockRight2; 
			duration = (float)Staging.randRange(1.0, 1.5);
			
			if (Staging.percentChance(10)) faceAnim = animationFaceAnxious;
			else if (Staging.percentChance(20)) faceAnim = animationFaceAnxious2;
			else if (Staging.percentChance(10)) faceAnim = animationFaceNervous;
			else if (Staging.percentChance(10)) faceAnim = animationFaceNervous2;
			else if (Staging.percentChance(10)) faceAnim = animationFaceNervous3;
			else if (Staging.percentChance(10)) faceAnim = animationFaceUnsure;
			else faceAnim = animationFaceShocked;			 
		}
      
      	subgoal testbed_setFacialExpression(myName, faceAnim);
      	subgoal performAnimation_portion(myName, targetName, anim, cAnimDefaultStartTime, duration);
   }

   
   //Glance at another group member
   sequential behavior testbed_confused_perform_glancing(String myName, String targetName, boolean bFirstGlance) {
   	precondition { (bFirstGlance == false && Staging.percentChance(30)) 
      				myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
            		groupWME=(GroupWME) (groupWME.contains(myCharacterWME))
         }      
      
      CharactersWME othersInFormationCharactersWME;
      String glancePerson;
		String faceAnim;

      // get list of other characters in the formation
      mental_act {
			othersInFormationCharactersWME = GroupUtil.cloneAndRemoveSelf(myName, groupWME.getFormationCharactersWME());
			glancePerson = othersInFormationCharactersWME.getRandom().getName();
			log.info("## " +myName+ " performing testbed_confused_perform_glancing at " + glancePerson);
			
			if (Staging.percentChance(10)) faceAnim = animationFaceAnxious;
			else if (Staging.percentChance(10)) faceAnim = animationFaceAnxious2;
			else if (Staging.percentChance(8)) faceAnim = animationFaceNervous;
			else if (Staging.percentChance(8)) faceAnim = animationFaceNervous2;
			else if (Staging.percentChance(8)) faceAnim = animationFaceNervous3;
			else if (Staging.percentChance(10)) faceAnim = animationFaceUnsure;
			else faceAnim = animationFaceShocked;			 
      }
      
		subgoal headTrack(myName, glancePerson);
      	subgoal testbed_setFacialExpression(myName, faceAnim);
 		subgoal performWithAttitude(myName, eAttitudePerform_confused, cAttitudeDefaultDuration);
   }
   
   // Glance at held object
   sequential behavior testbed_confused_perform_glancing(String myName, String targetName, boolean bFirstGlance) {
   	precondition { (bFirstGlance == false) }
		String faceAnim;
      
		subgoal headTrackOthersHeldObject(myName, targetName, 
											playerSkeletonNode_leftHand,	//fixme
											true,
											false);
        
		mental_act { 
			if (Staging.percentChance(10)) faceAnim = animationFaceAnxious;
			else if (Staging.percentChance(10)) faceAnim = animationFaceAnxious2;
			else if (Staging.percentChance(10)) faceAnim = animationFaceNervous;
			else if (Staging.percentChance(10)) faceAnim = animationFaceUnsure;
			else faceAnim = animationFaceShocked;			 
		}

      	subgoal testbed_setFacialExpression(myName, faceAnim);
 		subgoal performWithAttitude(myName, eAttitudePerform_confused, cAttitudeDefaultDuration);
   }
   
      /**
    * testbed_daughterCutScene()
    * Used for the May demo.
    */      
   sequential behavior testbed_daughterCutScene(SiuWME siuWME) {
      PerformanceWME performanceWME;
      mental_act { log.info("## Preparing for testbed_daughterCutScene"); } 
      
      //Place all of the actors where they need to be.
      subgoal testbed_daughterCutScene_setup();
      
      //Have daughter give you an initial wave or two
      subgoal testbed_daughterCutScene_daughterInitialWave();
      
      //Orchestrate everyone walking -- daugter continues to wave, other NPCs block your version of her.
      subgoal testbed_daughterCutScene_perform_root();

   }
   
   //Simultaneously handle two groups of NPCs walking, while the daughter tries to get attention.
   parallel behavior testbed_daughterCutScene_perform_root(){
      subgoal testbed_daughterCutScene_groupOneWalking_root();
      subgoal testbed_daughterCutScene_groupTwoWalking_root();
      subgoal testbed_daughterCutScene_daughterGetsAttention();
   }
   
   //Basic set up -- specify the starting positions of each NPC in the two groups, and the daughter.
   sequential behavior testbed_daughterCutScene_setup(){
      Location group1Location1;
      Location group1Location2;
      Location group1Location3;
      Location group1Location4;
      Location group1Location5;
      
      Location daughterLocation;
      Location group2Location1;
      Location group2Location2;
      Location group2Location3;
      Location group2Location4;
      Location group2Location5;
      
      
      Location generalOffStagePosition1;
      Location generalOffStagePosition2;
      
      mental_act{
         //Create the starting locations for the NPCs to stand in.
         
         log.info("Setting up NPCs for daughter cut scene");
         
            
         /**GROUP 1**/
         /*         
         //CLOSE BY LOCATIONS -- for when the cut scene is by the food stall.
         //Starting Locations
         
         /*
          * Coming in from the far right, behind the fountain.
         group1Location1 = new Location(-18.302, 0.0, 46.034);
         group1Location2 = new Location(-18.92, 0.0, 45.979);
         group1Location3 = new Location(-18.723,0.0,44.845);
         group1Location4 = new Location(-17.67,0.0, 45.23);
         group1Location5 = new Location(-19.01, 0.0, 44.82);
         
         daughterLocation = new Location(-7.638806, 0.0, 47.85197830200195);
         */
         
         //Coming in from the right, in front of the fountain.
         group1Location1 = new Location(-7.873180866, 0.0, 66.859034);
         group1Location2 = new Location(-8.873180866, 0.0, 65.859034);
         group1Location3 = new Location(-7.473180866, 0.0, 66.959034);
         group1Location4 = new Location(-6.873180866, 0.0, 67.859034);
         group1Location5 = new Location(-7.273180866, 0.0, 66.25034);
         
         /**Old attempted locations for Daughter: **/
         //Close to the far right blue stall: -7.638806, 0.0, 47.85197830200195
         //slightly in front of the two person group by the stalls: -1.1146340370178223, 0.0, 53.629119873046875
         //To the side of the fountain, fairly close to the player: -2.670485019683838, 0.0, 57.42435073852539
         //Directly in front of the 2 person group be the stalls: -2.280287027359009, 0.0, 52.659088134765625
         /// (Those two NPCs are 13 and 14 (we can try teleporting them away, possibly? Might help make the girl stand out even more.
         daughterLocation = new Location(-7.638806, 0.0, 47.85197830200195);
         
         
         /**GROUP 2 **/
         //Coming in from the left, In the stall area
         group2Location1 = new Location(-.01744, 0.0, 55.94284);
         group2Location2 = new Location(0.89027, 0.0, 53.8827);
         
         group2Location3 = new Location(1.162, 0.0, 54.59);
         group2Location4 = new Location(1.09, 0.0, 56.695);
         group2Location5 = new Location(-0.012, 0.0, 58.3632);
         
         
         //Coming in from the far left, further than the stall area.
         /*
         group2Location1 = new Location(6.434, 0.0, 65.27808380126953); // 66 = pretty safe, 61 = probably will be in the food stalls.
         group2Location2 = new Location(6.254, 0.0, 64.53434);
         
         group2Location3 = new Location(6.91212, 0.0, 66.6534);
         group2Location4 = new Location(5.311213, 0.0, 66.3442);
         group2Location5 = new Location(7.1323, 0.0, 63.9248);
         */
         
         //For teleporting people when we no longer need them.
         generalOffStagePosition1 = new Location(-47.97972869873047, 0.0, 17.552669525146484);
         generalOffStagePosition2 = new Location(-45.97972869873047, 0.0, 15.552669525146484);
      }
      
      
      //turn head tracking off for cut scene participants
      subgoal headTrackOff("NPC01");
      subgoal headTrackOff("NPC02");
      subgoal headTrackOff("NPC03");
      subgoal headTrackOff("NPC04");
      subgoal headTrackOff("NPC05");
      subgoal headTrackOff("NPC15");
      subgoal headTrackOff("NPC16");
      subgoal headTrackOff("NPC17");
      subgoal headTrackOff("NPC18");
      subgoal headTrackOff("NPC19");
      subgoal headTrackOff("NPC20");
      
      //Teleport the NPCs to where we want them to stand.
      subgoal teleportToPoint("NPC15", group1Location1);
      subgoal  teleportToPoint("NPC16", group1Location2);
      subgoal  teleportToPoint("NPC17", group1Location3);
      subgoal teleportToPoint("NPC01", group1Location4);
      subgoal teleportToPoint("NPC02", group1Location5);
     
      subgoal teleportToPoint("NPC18", group2Location1);
      subgoal teleportToPoint("NPC19", group2Location2);
      subgoal teleportToPoint("NPC03", group2Location3);
      subgoal teleportToPoint("NPC04", group2Location4);
      subgoal teleportToPoint("NPC05", group2Location5);
      
      subgoal teleportToPoint("NPC20", daughterLocation);
      
      //Teleport the group of 2 standing by the food stalls away
      subgoal teleportToPoint("NPC13", generalOffStagePosition1);
      subgoal teleportToPoint("NPC14", generalOffStagePosition2);
      
      /**NPC ORIENTATION **/
      //And have them face the direction we want the to face in.
      subgoal jumpcutToFacingPoint("NPC15", daughterLocation);
      subgoal jumpcutToFacingPoint("NPC16", daughterLocation);
      subgoal jumpcutToFacingPoint("NPC17", daughterLocation);
      subgoal jumpcutToFacingPoint("NPC18", daughterLocation);
      subgoal jumpcutToFacingPoint("NPC19", daughterLocation);
      
      subgoal jumpcutToFacingPoint("NPC01", daughterLocation);
      subgoal jumpcutToFacingPoint("NPC02", daughterLocation);
      subgoal jumpcutToFacingPoint("NPC03", daughterLocation);
      subgoal jumpcutToFacingPoint("NPC04", daughterLocation);
      subgoal jumpcutToFacingPoint("NPC05", daughterLocation);
      
      //45 is too far past the player's left shoulder
      subgoal jumpcutToAngle("NPC20", 25d);
      
   }
   
   //Start group one on their walk.
   sequential behavior testbed_daughterCutScene_groupOneWalking_root(){
      subgoal groupOneWaypointOne();
   }
   
   //Start group two on their walk.
   sequential behavior testbed_daughterCutScene_groupTwoWalking_root(){
      subgoal groupTwoWaypointOne();
   }
   
   //Have every NPC of group 1 walk to new locations.
   sequential behavior groupOneWaypointOne(){
      Location group1Actor1EndPoint;
      Location group1Actor2EndPoint;
      Location group1Actor3EndPoint;
      Location group1Actor4EndPoint;
      Location group1Actor5EndPoint;
      
      mental_act{
         //log.info("Inside of group one waypoint one.");
         // Group 1 starts on the right, ends on the left.
         group1Actor1EndPoint = new Location(-.2174432, 0.0, 55.94284);
         group1Actor2EndPoint = new Location(0.8902712, 0.0, 53.8827);
         group1Actor3EndPoint = new Location(1.162324, 0.0, 53.59); 
         group1Actor4EndPoint = new Location(1.0954, 0.0, 54.495);
         group1Actor5EndPoint = new Location(-0.34312, 0.0, 54.3632);
      }
      
      //Workaround to make sure that we've sequentially created all of the Location objects
      //before we have all the NPCs execute them in parallel.
      subgoal groupOneWaypointOne_perform(group1Actor1EndPoint, group1Actor2EndPoint, group1Actor3EndPoint, group1Actor4EndPoint, group1Actor5EndPoint);
   }
   
   //Start the NPCs on their way, waiting a random amount of time between each NPC starts to 
   //make them seem like they aren't marching in an army.
   sequential behavior groupOneWaypointOne_perform(Location loc1, Location loc2, Location loc3, Location loc4, Location loc5){
      
      spawngoal walkToPoint("NPC15", loc1);
      subgoal waitForRand(0,2000);
      spawngoal walkToPoint("NPC16", loc2);
      subgoal waitForRand(0,2000);
      spawngoal walkToPoint("NPC17", loc3);
      
      subgoal waitForRand(0,2000);
      spawngoal walkToPoint("NPC01", loc4);
      subgoal waitForRand(0,2000);
      spawngoal walkToPoint("NPC02", loc5);
   }
   
   //Specify where Group Two Should walk to.
   sequential behavior groupTwoWaypointOne(){
      //The ending position of each NPC in Group 2 after thier movement.
      Location group2Actor1EndPoint;
      Location group2Actor2EndPoint;      
      Location group2Actor3EndPoint;
      Location group2Actor4EndPoint;
      Location group2Actor5EndPoint;
      
      mental_act{
         
         //Group 2 starts on the left, ends on the right.
         
         
         //Cross from left to right,  behind the fountain
         /*
         group2Actor1EndPoint = new Location(-28.302, 0.0, 46.034);
         group2Actor2EndPoint = new Location(-28.92, 0.0, 45.979);
         group2Actor3EndPoint = new Location(-21.04, 0.0, 46.334);
         group2Actor4EndPoint = new Location(-22.45, 0.0, 47.734);
         group2Actor5EndPoint = new Location(-21.84, 0.0, 46.834);
         */
         
         group2Actor1EndPoint = new Location(-23.302, 0.0, 42.034);
         group2Actor2EndPoint = new Location(-23.92, 0.0, 41.979);
         group2Actor3EndPoint = new Location(-21.04, 0.0, 42.334);
         group2Actor4EndPoint = new Location(-22.45, 0.0, 43.734);
         group2Actor5EndPoint = new Location(-21.84, 0.0, 42.834);
         
         //Cross from left to right, in front of the fountain
         /*
         group2Actor1EndPoint = new Location(-7.873180866, 0.0, 66.859034);
         group2Actor2EndPoint = new Location(-8.873180866, 0.0, 65.859034);
         
         group2Actor3EndPoint = new Location(-7.473180866, 0.0, 66.959034);
         group2Actor4EndPoint = new Location(-6.873180866, 0.0, 67.859034);
         group2Actor5EndPoint = new Location(-7.273180866, 0.0, 66.25034);
         */
      }
      
      //Workaround to make sure that we've sequentially created all of the Location objects
      //before we have all the NPCs execute them in parallel.
      subgoal groupTwoWaypointOne_perform(group2Actor1EndPoint, group2Actor2EndPoint, group2Actor3EndPoint, group2Actor4EndPoint, group2Actor5EndPoint);

      
   }
   
   //Actually set the NPCs of Group 2 on their way.
   sequential behavior groupTwoWaypointOne_perform(Location loc1, Location loc2, Location loc3, Location loc4, Location loc5){
      spawngoal walkToPoint("NPC18", loc1);
      subgoal waitForRand(0,500);
      
      spawngoal walkToPoint("NPC19", loc2);
      subgoal waitForRand(0,500);
      
      spawngoal walkToPoint("NPC03", loc3);
      subgoal waitForRand(0,500);
      
      spawngoal walkToPoint("NPC04", loc4);
      subgoal waitForRand(0,500);
      
      spawngoal walkToPoint("NPC05", loc5);
   }
   
   //The daughter's initial wave at the player, before the crowd starts moving.
   sequential behavior testbed_daughterCutScene_daughterInitialWave(){
      
      //The Daughter turns her head towards the player.
      subgoal headTrack("NPC20", playerName);
          
      //The daughter waves to get the player's attention.
      subgoal performAnimation("NPC20", playerName, animationGetAttentionWave);
      subgoal performAnimation("NPC20", playerName, animationGetAttentionWave2);
   }
   
   //This is meant to be played concurrently with the groups of NPCs crossing in front of the daughter.
   sequential behavior testbed_daughterCutScene_daughterGetsAttention(){
      Location daughterOffStagePosition;
      
      mental_act{
         daughterOffStagePosition = new Location(-49.97972869873047, 0.0, 19.552669525146484);
      }
      
      /**Using 'new' animations, but commented out in the rush to complete everything **/
      /*
      subgoal performAnimation("NPC20", playerName, animationGetAttentionWave);
      subgoal performAnimation("NPC20", playerName, animationGetAttentionWave);
      subgoal performAnimation("NPC20", playerName, animationGetAttentionWave);
      subgoal performAnimation("NPC20", playerName, animationGetAttentionWave);
      subgoal performAnimation("NPC20", playerName, animationGetAttentionWave);
      //subgoal performAnimation("NPC20", playerName, animationGetAttentionWave);
      //subgoal performAnimation("NPC20", playerName, animationGetAttentionWave);
      */
      
      //'OLD WAY', using the same 'animationFrustrated1' animation for many times in a row.
      mental_act{log.info("working with daughter's performance.");}
      subgoal performAnimation_portion("NPC20", playerName, animationFrustrated1, 0.0, 1.5);
      //mental_act{log.info("Finished first animation");}
      subgoal performAnimation_portion("NPC20", playerName, animationFrustrated1, 0.0, 1.5);
      //mental_act{log.info("Finished second animation");}
      subgoal performAnimation_portion("NPC20", playerName, animationFrustrated1, 0.0, 1.5);
      //mental_act{log.info("Finished thrird animation");}
      subgoal performAnimation_portion("NPC20", playerName, animationFrustrated1, 0.0, 1.5);
      //mental_act{log.info("Finished fourth animation");}
      subgoal performAnimation_portion("NPC20", playerName, animationFrustrated1, 0.0, 1.5);
      //mental_act{log.info("Finished fifth animation");}
      
      
      subgoal performAnimation_portion("NPC20", playerName, animationFrustrated1, 0.0, 1.5);
      //mental_act{log.info("Finished sixth animation");}
      
      subgoal performAnimation_portion("NPC20", playerName, animationFrustrated1, 0.0, 1.0);
      //mental_act{log.info("Finished seventh animation");}
      
      subgoal performAnimation_portion("NPC20", playerName, animationFrustrated1, 0.0, 1.0);
      //mental_act{log.info("Finished eighth animation");}
      
      
      subgoal performAnimation_portion("NPC20", playerName, animationFrustrated1, 0.0, 1.0);
      //mental_act{log.info("Finished ninth animation");}
      
      
      
      /*
      subgoal performAnimation_portion("NPC20", playerName, animationFrustrated1, 0.0, 1.0);
      mental_act{log.info("Finished tenth animation");}
      */
      
      //I believe we no longer do this, and instead use some fancy trigger to procedurally make the daughter disappear at the right moment.
//      subgoal teleportToPoint("NPC20", daughterOffStagePosition);
   }
   
   
 	
	/**
	 * testbed_demo_groupSequence()
	 */	 	
	sequential behavior testbed_demo_groupSequence() {
		precondition { charactersWME=(CharactersWME) } 
		Iterator iterator;
		
		// root behavior to place each character
		spawngoal testbed_demo_groupSequence_root();
		
		mental_act { iterator = charactersWME.iterator(); }
		with (persistent when_succeeds) subgoal testbed_demo_groupSequence_loop(iterator);
	}
	
	// Root parallel behavior to put each demo character
	parallel behavior testbed_demo_groupSequence_root() {
		wait;
	}
			
	sequential behavior testbed_demo_groupSequence_loop(Iterator iterator) {
		precondition { (iterator.hasNext()) }				
						//parentBehavior = (ParallelBehaviorWME signature == "testbed_demo_groupSequence_root()") }
		CharacterWME characterWME;
		String characterName;
		mental_act {
			characterWME = iterator.next();
			characterName = characterWME.getName();
			log.info(characterName+ " launching testbed_demo_groupSequence_character()");
		}
		
		spawngoal testbed_demo_groupSequence_character(characterName); //at parentBehavior;		
	}
	 

	sequential behavior testbed_demo_groupSequence_character(String myName) {
		precondition { (myName.equals(playerName) == false)
						(myName.equals("NPC21") == false)
						(myName.equals("NPC22") == false)
						(myName.equals("NPC23") == false) } 
		/** fixme: ^ Couldn't access BackgroundBehavior of characters easily to filter the group sequence
		 ** Ideally would be something like (character.BackgroundBehavior != WALKAROUND) or == OUTSIDE **/
		 
		subgoal testbed_demo_groupSequence_character_main(myName);
	}
	
	sequential behavior testbed_demo_groupSequence_character_main(String myName) {
		subgoal testbed_approachingCharacters(nullSiu, myName);
		subgoal testbed_demo_groupSequence_character_smalltalkAndFormation(myName);
	}


	parallel behavior testbed_demo_groupSequence_character_greet(String myName) {
		precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName))
                     	groupWME=(GroupWME) (groupWME.contains(myCharacterWME))
                     }
                     
		subgoal testbed_LaunchSIU_groupGreet(myName, groupWME, "");
		
		// just needed for demo purposes; goes away when real SIU sequencing is happening
		with (priority_modifier 1) subgoal testbed_waitForSIUToStartAndStop(myName, siuNameGreet);
	} 

	parallel behavior testbed_demo_groupSequence_character_smalltalkAndFormation(String myName) {
		subgoal testbed_LaunchSIU_groupFormation(myName);
		subgoal testbed_LaunchSIU_groupSmalltalk(myName);	
	} 

	
	/**
	 * testbed_demo_walkAcross()
	 */	 		
	sequential behavior testbed_demo_walkAcross(String myName) {
		precondition {	characterPhysicalWME = (PhysicalAgentWME)
                     	(characterPhysicalWME.getId().equals(myName)) }
		Location location;
		mental_act { 
			location = new Location(characterPhysicalWME.getLocation());
			location.incX(20.0);
		} 
		subgoal walkToPoint(myName, location);
	}

	/**
	 * testbed_demo_noticingCharacters()
	 */	 		
	sequential behavior testbed_demo_noticingCharacters(String myName) {
		// pause at start
		subgoal waitForRand(1000, 2000);
		
		subgoal testbed_noticingCharacters(nullSiu, myName);
		
		// pause when done
		subgoal waitForRand(1000, 2000);
	}

	/**
	 * testbed_demo_approachingCharacters()
	 */	 	
	sequential behavior testbed_demo_approachingCharacters(String myName) {
				
		// pause at start
		subgoal waitForRand(1000, 2000);
		
		subgoal testbed_approachingCharacters(nullSiu, myName);
		
		// pause when done
		subgoal waitForRand(1000, 2000);
	}

	/**
	 * testbed_demo_greetCharacters()
	 */	 	
	sequential behavior testbed_demo_greetCharacters(String myName) {
		precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
                     	groupWME=(GroupWME) (groupWME.contains(myCharacterWME))
                     }
        CharactersWME charactersWME;
		mental_act { 
	        // need to clone the formation list if glancing over time, since it can change under our feet
			charactersWME = GroupUtil.cloneAndRemoveSelf(myName, groupWME.getFormationCharactersWME()); 
		} 
		subgoal testbed_greetCharacters(nullSiu, myName, charactersWME, cPerformancePriorityMedHigh);
	}
		
   		

	// ------------------------------------------------------------------------	
	// ------------------------------------------------------------------------	

	/**
	 * testbed_demo_setup()
	 * Establish global friends lists, positions all characters, points each character to their friend list 
	 */	 	
	sequential behavior testbed_demo_setup() {
		precondition { 	activeAgentsWME=(ActiveAgentsWME) 
						playerPhysicalWME = (PhysicalAgentWME)
                     	(playerPhysicalWME.getId().equals(playerName))
                     	}
		Location point;
		double angle;
		int numNPCs;
		String characterName;
		double coneAngle;
		double angleRange;
		Iterator iterator;
					
		subgoal testbed_demo_friendsList_setup();
	
		// setup initial character positions
		with (ignore_failure) subgoal testbed_demo_setup_characters(numNPCs, angleRange);
		with (ignore_failure) subgoal testbed_demo_setup_PlayerInventory();
		with (ignore_failure) subgoal testbed_backgroundNPC_launch();
	}

	sequential behavior testbed_demo_setup_characters(int numNPCs, double angleRange) {
		precondition { charactersWME=(CharactersWME) } 
		Iterator iterator;
		mental_act { iterator = charactersWME.iterator(); }
		with (persistent when_succeeds) subgoal testbed_demo_setup_characters_loop(iterator, numNPCs, angleRange);
	}
			
	sequential behavior testbed_demo_setup_characters_loop(Iterator iterator, int numNPCs, double angleRange) {
		precondition { (iterator.hasNext()) }						
		CharacterWME characterWME;
		String characterName;
		mental_act { 
			characterWME = iterator.next();
			characterName = characterWME.getName();
		}
		
		with (ignore_failure) subgoal testbed_demo_setup_character(numNPCs, characterName, angleRange);		
	}
	
	sequential behavior testbed_demo_setup_character(int numNPCs, String characterName, double angleRange) {
		precondition { 	(characterName.equals(playerName) == false) 
						characterWME=(CharacterWME) (characterWME.getName().equals(characterName)) }
		Location point;
		double angle;
		double angle2;
		double dist;
		float angle2Float;
		int ctr;
		Location origin;
		
		mental_act { log.info("Setting up demo character " +characterName); }
		
		with (ignore_failure) subgoal testbed_demo_assignFriendsList(characterName);
		subgoal testbed_setFacialExpressionTendency(characterWME);
	}
	
	// (April 4-23-13) Put the photo in the player's possession
	sequential behavior testbed_demo_setup_PlayerInventory(){	
		precondition {	characterWME=(CharacterWME) (characterWME.getName().equals(playerName))
					}
		mental_act { characterWME.setObjectHeld(cObjectPhoto); }
	}
	

	/**
	 * testbed_demo_friendsList_setup()
	 */	 	
	sequential behavior testbed_demo_friendsList_setup() {
		precondition {	playerPhysicalWME = (PhysicalAgentWME)
                     	(playerPhysicalWME.getId().equals(playerName)) }
		Location origin; 
		
		mental_act {
			friendsList1 = new CharactersWME();		
			friendsList2 = new CharactersWME();		
			friendsList3 = new CharactersWME();		
			friendsList4 = new CharactersWME();		
			friendsList5 = new CharactersWME();
			friendsEmpty = new CharactersWME();
		}
		
		with (ignore_failure) subgoal testbed_demo_friendsList_add(friendsList1, "NPC01");
		with (ignore_failure) subgoal testbed_demo_friendsList_add(friendsList1, "NPC02");
		with (ignore_failure) subgoal testbed_demo_friendsList_add(friendsList1, "NPC03");
		with (ignore_failure) subgoal testbed_demo_friendsList_add(friendsList1, "NPC04");
		with (ignore_failure) subgoal testbed_demo_friendsList_add(friendsList1, "NPC05");

		with (ignore_failure) subgoal testbed_demo_friendsList_add(friendsList2, "NPC06");
		with (ignore_failure) subgoal testbed_demo_friendsList_add(friendsList2, "NPC07");
		with (ignore_failure) subgoal testbed_demo_friendsList_add(friendsList2, "NPC08");
		// make this whole group hostile
		with (ignore_failure) subgoal addGroupAttitude_main(friendsList2, eAttitudeType_hostile);
		// make one the leader
		with (ignore_failure) subgoal addAttitude("NPC07", eAttitudeType_leader);
		// make one sympathetic 
		with (ignore_failure) subgoal addAttitude("NPC06", eAttitudeType_sympathetic);
		
		with (ignore_failure) subgoal testbed_demo_friendsList_add(friendsList3, "NPC09");
		with (ignore_failure) subgoal testbed_demo_friendsList_add(friendsList3, "NPC10");
		with (ignore_failure) subgoal testbed_demo_friendsList_add(friendsList3, "NPC11");
		with (ignore_failure) subgoal testbed_demo_friendsList_add(friendsList3, "NPC12");		
		
		with (ignore_failure) subgoal testbed_demo_friendsList_add(friendsList4, "NPC13");
		with (ignore_failure) subgoal testbed_demo_friendsList_add(friendsList4, "NPC14");
		
		with (ignore_failure) subgoal testbed_demo_friendsList_add(friendsList5, "NPC15");
		with (ignore_failure) subgoal testbed_demo_friendsList_add(friendsList5, "NPC16");
		with (ignore_failure) subgoal testbed_demo_friendsList_add(friendsList5, "NPC17");
		with (ignore_failure) subgoal testbed_demo_friendsList_add(friendsList5, "NPC18");
		with (ignore_failure) subgoal testbed_demo_friendsList_add(friendsList5, "NPC19");
		with (ignore_failure) subgoal testbed_demo_friendsList_add(friendsList5, "NPC20");
	}
			
	sequential behavior testbed_demo_friendsList_add(CharactersWME friendList, String characterName) {
		precondition { characterWME=(CharacterWME) (characterWME.getName().equals(characterName)) }
		mental_act { friendList.addCharacter(characterWME); } 
	}
	
	sequential behavior testbed_demo_assignFriendsList(String characterName) {
		precondition { characterWME=(CharacterWME) (characterWME.getName().equals(characterName)) }
		mental_act {
			CharactersWME friendsList = null;
			int size;
			if (friendsList1.containsCharacter(characterName)) friendsList = friendsList1;  
			else if (friendsList2.containsCharacter(characterName)) friendsList = friendsList2;  
			else if (friendsList3.containsCharacter(characterName)) friendsList = friendsList3;  
			else if (friendsList4.containsCharacter(characterName)) friendsList = friendsList4;  
			else if (friendsList5.containsCharacter(characterName)) friendsList = friendsList5;
			  
			if (friendsList != null) {
				size = friendsList.getSize(); --size;
				log.info(characterName+ " assigned to friend list with " +size+ " other characters");
				characterWME.setFriendsCharactersWME(friendsList);
			} else {
				friendsList = friendsEmpty;
				characterWME.setFriendsCharactersWME(friendsList);
			}
		}
	}	




	
	/**
	 * testbed_offerObjectToCharacter()
	 */	 	
	sequential behavior testbed_offerObjectToCharacter(SiuWME siuWME, String myName, String targetName, int performancePriority) {
		PerformanceWME performanceWME;
		mental_act {
			log.info("##!! " +myName+ " preparing for testbed_offerObjectToCharacter " +targetName); 
			performanceWME = new PerformanceWME(siuWME); 
		}
		subgoal setupPerformanceWME(performanceWME, siuWME, myName, performancePriority, "testbed_offerObjectToCharacter");
		with (persistent when_fails) subgoal testbed_offerObjectToCharacter(myName, targetName, performanceWME);
		subgoal performanceDoneDeleteWME(performanceWME);
	}
	
	sequential behavior testbed_offerObjectToCharacter(String myName, String targetName, PerformanceWME performanceWME) {
		subgoal performanceWait(performanceWME);
		subgoal testbed_offerObjectToCharacter_perform(myName, targetName, performanceWME);
	}
	
	// Regular NPC version: passing objects between themselves		
	sequential behavior testbed_offerObjectToCharacter_perform(String myName, String targetName, PerformanceWME performanceWME) {
		context_condition {	(performanceWME.getPerformanceState() == cPerformanceStatePerforming) }
		precondition {	characterPhysicalWME = (PhysicalAgentWME)
                     	(characterPhysicalWME.getId().equals(targetName))                     	
						}
		specificity 1;
		Location characterPt;
		SocialSignalWME socialSignal;
		mental_act { 
			log.info("## " +myName+ " performing testbed_offerObjectToCharacter");
			// grab the location of the target
			characterPt = characterPhysicalWME.getLocation(); 
		}

		subgoal headTrack(myName, targetName);
		subgoal turnToFacingPoint(myName, characterPt);
		
        // TO DO: Use Ben's wrapon code
        subgoal performAnimation(myName, targetName, animationOfferObject);

        mental_act {
           socialSignal = new SocialSignalWME(socialInterpretationExtendHand, myName, targetName );
           log.info("##!! " +myName+ " SocialSignalWME Created socialInterpretationExtendHand towards " + targetName);
           BehavingEntity.getBehavingEntity().addWME(socialSignal);
        }
        
        // wait for the person who will take the object to set this flag 
        with (success_test {
           (socialSignal.getChosenInterpretation() != null)
        } ) wait;
      
        act attachObject(myName, idCard_mesh, false);
      
        mental_act {
           log.info("testbed_offerObjectToCharacter has completed");
        }
	}
	
	/**
	 * Special Player Version: replaces redundant "giveObjectToPlayer"
	 */
	sequential behavior testbed_offerObjectToCharacter_perform(String myName, String targetName, PerformanceWME performanceWME) {
		context_condition {	(performanceWME.getPerformanceState() == cPerformanceStatePerforming) }
		precondition {	characterPhysicalWME = (PhysicalAgentWME)
                     	(characterPhysicalWME.getId().equals(targetName)) 
                     	(targetName.equals(playerName) == true)                    	
						}
		specificity 2;
		mental_act { 
	      log.info("(((PLAYER))) ## " +myName+ " performing testbed_offerObjectToCharacter_perform !!PLAYERVERSION!!"); 
	    }
	   
	    // Hold out the arm and hang until the player approaches
	    subgoal performAnimation(myName, targetName, animationOfferObject);

	    // Wait until the player is within CloseConversationDistance
		with (success_test {
						 myPhysicalWME=(PhysicalAgentWME) (myPhysicalWME.getId().equals(myName))
						 targetPhysicalWME=(PhysicalAgentWME) (targetPhysicalWME.getId().equals(targetName))
                         (Staging.getXZDistanceBetweenPoints(myPhysicalWME.getLocation(),
                                                             targetPhysicalWME.getLocation())
                                                        < cExchangeObjectDistance)
                        
            } ) wait;
            
        mental_act {
			log.info("(((PLAYER?!))) CAME IN RANGE! YAY!");
		}
            
        //Hand over the object
		act attachObject(myName, idCard_mesh, false);
            
        // By this point, the object's graphic has changed hands. Update the values!
	   	subgoal testbed_passObjectFromAToB(myName, targetName);
	   	
	   	mental_act {
           log.info("testbed_takeObjectFromCharacter !!PLAYERVERSION!! has completed");
        }  
	}

   
   /**
    * testbed_takeObjectFromCharacter()
    */      
   sequential behavior testbed_takeObjectFromCharacter(SiuWME siuWME, String myName, String targetName, int performancePriority) {
      PerformanceWME performanceWME;
      mental_act {
         //log.info("## " +myName+ " preparing for testbed_offerObjectToCharacter " +targetName); 
         performanceWME = new PerformanceWME(siuWME); 
      }
      subgoal setupPerformanceWME(performanceWME, siuWME, myName, performancePriority, "testbed_takeObjectFromCharacter");
      with (persistent when_fails) subgoal testbed_takeObjectFromCharacter(myName, targetName, performanceWME);
      subgoal performanceDoneDeleteWME(performanceWME);
   }
   
   sequential behavior testbed_takeObjectFromCharacter(String myName, String targetName, PerformanceWME performanceWME) {
      subgoal performanceWait(performanceWME);
      subgoal testbed_takeObjectFromCharacter_perform(myName, targetName, performanceWME);
   }
            
   sequential behavior testbed_takeObjectFromCharacter_perform(String myName, String targetName, PerformanceWME performanceWME) {
      context_condition {  (performanceWME.getPerformanceState() == cPerformanceStatePerforming) }
      precondition { characterPhysicalWME = (PhysicalAgentWME)
                        (characterPhysicalWME.getId().equals(targetName))                       
                  }
      SocialSignalWME socialSignal; 
      Location characterPt;
      mental_act { 
         log.info("## " +myName+ " performing testbed_takeObjectFromCharacter");
         // grab the location of the target
         characterPt = characterPhysicalWME.getLocation(); 
      }
		subgoal headTrack(myName, targetName);
      subgoal turnToFacingPoint(myName, characterPt);
      
      // .getRecipient() changed to .getSignalRecipient()
      with (success_test {
         socialSignal=(SocialSignalWME) 
         (socialSignal.getChosenInterpretation()==null
               && socialSignal.getFirstSocialInterpretation()==socialInterpretationExtendHand 
               && myName.equals(socialSignal.getSignalRecipient())
               && targetName.equals(socialSignal.getSender()))
      } ) wait;
      mental_act {
         log.info(myName + " is reaching out to " + targetName + " to take the object");
      }
      
      subgoal performAnimation_portion(myName, targetName, animationReachAndTakeObject, cAnimDefaultStartTime, 0.5f);
      
      mental_act {
         socialSignal.setChosenInterpretation(socialInterpretationExtendHand);
         log.info("##!! " +myName+ " SocialSignalWME setChosenInterpretation socialInterpretationExtendHand " + targetName);
      }
      
      act attachObject(myName, idCard_mesh, true);
      
      // By this point, the object's graphic has changed hands. Update the values!
   	  subgoal testbed_passObjectFromAToB(targetName, myName);
      
      mental_act {
         log.info("testbed_takeObjectFromCharacter has completed");
      }  
   }
   
   /**
	 * Special Player Version: replaces redundant "takeObjectFromPlayer"
	 */
   sequential behavior testbed_takeObjectFromCharacter_perform(String myName, String targetName, PerformanceWME performanceWME) {
      context_condition {  (performanceWME.getPerformanceState() == cPerformanceStatePerforming) }
      precondition { characterPhysicalWME = (PhysicalAgentWME)
                        (characterPhysicalWME.getId().equals(targetName))
                        (targetName.equals(playerName) == true)                       
                   }
       specificity 2;           
       mental_act { 
	      log.info("## " +myName+ " performing testbed_takeObjectFromCharacter !!PLAYERVERSION!!");
	   }           
	   
	   act attachObject(myName, idCard_mesh, true);
	   
	   // By this point, the object's graphic has changed hands. Update the values!
	   subgoal testbed_passObjectFromAToB(targetName, myName);
      
      mental_act {
         log.info("testbed_takeObjectFromCharacter !!PLAYERVERSION!! has completed");
      }  
   }
   
    // ****** Passing Object Data across Character WMES *******
    
    // Passing the object from one person to another
    // Just removes it from the holder and adds it to the receiver
	sequential behavior testbed_passObjectFromAToB(String holderName, String receiverName) {
		precondition {	holderCharWME = (CharacterWME) (holderCharWME.getName().equals(holderName))
						receiverCharWME = (CharacterWME) (receiverCharWME.getName().equals(receiverName))
						(holderCharWME.getObjectHeld().equals("") == false)
					}
		specificity 2;
		String objName;
		mental_act {
			objName = holderCharWME.getObjectHeld();
			log.info("Passing Object " + objName + " from " + holderName + " to " + receiverName);
			holderCharWME.setObjectHeld("");
			receiverCharWME.setObjectHeld(objName);
		}
		
		subgoal createEpisodicMemoryWME(holderName, receiverName, event_gaveObject);
		subgoal createEpisodicMemoryWME(receiverName, holderName, event_tookObject);
	}
	
	sequential behavior testbed_passObjectFromAToB(String holderName, String receiverName) {
		precondition {	holderCharWME = (CharacterWME) (holderCharWME.getName().equals(holderName))
						receiverCharWME = (CharacterWME) (receiverCharWME.getName().equals(receiverName))
					}
		specificity 1;
		mental_act {
			log.info("^&^&^ ERROR: HOLDER " + holderName + " DOESN'T HAVE OBJ!!!");
		}
	}	
	/**
	 * testbed_joinAndMaintainFormation()
	 * Requires character to already have joined and approached a group
	 */	 	
	sequential behavior testbed_joinAndMaintainFormation(SiuWME siuWME, String myName, int performancePriority) {
		precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
                     	groupWME=(GroupWME) (groupWME.contains(myCharacterWME)) 
                     }
		
		// this automatically removes character from approaching list and updates the formation locations
		// based on the number of characters. It will also create the formation if it doesn't exist
		subgoal addCharacterToFormation(myCharacterWME, groupWME, true); 
		
		with (persistent) subgoal testbed_joinAndMaintainFormation_main_storeFormationPoint(siuWME, myCharacterWME, groupWME, performancePriority);
	}
	
	sequential behavior testbed_joinAndMaintainFormation_main_storeFormationPoint(SiuWME siuWME, CharacterWME myCharacterWME, GroupWME groupWME, int performancePriority) {
		Location initialLocation;
		mental_act { initialLocation = groupWME.getFormationLocation(myCharacterWME); }
		subgoal testbed_joinAndMaintainFormation_main(siuWME, myCharacterWME, groupWME, initialLocation, performancePriority);
	}
	

   sequential behavior testbed_joinAndMaintainFormation_main(SiuWME siuWME, CharacterWME myCharacterWME, GroupWME groupWME, Location initialFormationLocation, int performancePriority) {
      context_condition {
         (groupWME.getFormationLocation(myCharacterWME) != null)
         (Location.equals(initialFormationLocation, groupWME.getFormationLocation(myCharacterWME)))
      }
      
		subgoal testbed_joinAndMaintainFormation_moveToFormationPoint(siuWME, myCharacterWME, groupWME, performancePriority);
		subgoal testbed_joinAndMaintainFormation_stayCloseToFormationPoint(myCharacterWME, groupWME);		
	}

	
   // do nothing if the character is not in the formation
   sequential behavior testbed_joinAndMaintainFormation_moveToFormationPoint(SiuWME siuWME, CharacterWME myCharacterWME, GroupWME groupWME, int performancePriority) {
      precondition { 
         (groupWME.getFormationLocation(myCharacterWME) == null) 
      }
      specificity 2;
      wait;
   }

	// else if the character is in the formation	
   sequential behavior testbed_joinAndMaintainFormation_moveToFormationPoint(SiuWME siuWME, CharacterWME myCharacterWME, GroupWME groupWME, int performancePriority) {
      specificity 1;
		PerformanceWME performanceWME;
		String myName;
				
		mental_act {
			myName = myCharacterWME.getName();
			log.info("## " +myName+ " preparing for testbed_joinAndMaintainFormation_moveToFormationPoint");
			performanceWME = new PerformanceWME(siuWME); 
		}
		subgoal setupPerformanceWME(performanceWME, siuWME, myName, performancePriority, "testbed_joinAndMaintainFormation_moveToFormationPoint");
		with (persistent when_fails) subgoal testbed_joinAndMaintainFormation_moveToFormationPoint_main(myCharacterWME, groupWME, performanceWME);
		subgoal performanceDoneDeleteWME(performanceWME);
	}
	
   sequential behavior testbed_joinAndMaintainFormation_moveToFormationPoint_main(CharacterWME myCharacterWME, GroupWME groupWME, PerformanceWME performanceWME) {
		subgoal performanceWait(performanceWME);
		subgoal testbed_joinAndMaintainFormation_moveToFormationPoint_perform(myCharacterWME, groupWME, performanceWME);
	}
	
   sequential behavior testbed_joinAndMaintainFormation_moveToFormationPoint_perform(CharacterWME myCharacterWME, GroupWME groupWME, PerformanceWME performanceWME) {
		context_condition {	(performanceWME.getPerformanceState() == cPerformanceStatePerforming) }				
		precondition { playerPhysicalWME=(PhysicalAgentWME) (playerPhysicalWME.getId().equals(playerName)) }
      
      Location pointToWalkTo;
      String myName;
      double angle;
      CharacterWME approachingCharacterWME;

      mental_act {
		log.info("## " +myCharacterWME.getName()+ " performing testbed_joinAndMaintainFormation_moveToFormationPoint, (re)establishing formation location"); 
		myName = myCharacterWME.getName();
		pointToWalkTo = groupWME.getFormationLocation(myCharacterWME);
      }

      subgoal testbed_joinAndMaintainFormation_moveToFormationPoint_perform_moveToPoint(myName, pointToWalkTo, groupWME);
      
      // turn toward approaching character, the player, or the origin
      mental_act { 
         if (groupWME.getAnchorCharacter().getName().equals(playerName)) {
            angle = Staging.getXZAngleBetweenPoints(pointToWalkTo, playerPhysicalWME.getLocation());
         } else {
            angle = Staging.getXZAngleBetweenPoints(pointToWalkTo, groupWME.getOrigin());
         }
         
         // if we are first in formation, orient towards approaching character
         approachingCharacterWME = null;
         if (groupWME.getSizeOfFormation() == 1) {
			approachingCharacterWME = groupWME.getRandomApproachingCharacterWME();
		}         
      }
      subgoal testbed_joinAndMaintainFormation_moveToFormationPoint_perform_orient(myName, myCharacterWME, angle, groupWME, approachingCharacterWME);
   }
	
   // If the character isn't that far from the point don't move
   sequential behavior testbed_joinAndMaintainFormation_moveToFormationPoint_perform_moveToPoint(String myName, Location pointToWalkTo, GroupWME groupWME) {
      precondition {
         myPhysicalWME = (PhysicalAgentWME)
         (myPhysicalWME.getId().equals(myName))
         (groupWME.getTightness() == 1.0 &&
         	Staging.getXZDistanceBetweenPoints(myPhysicalWME.getLocation(), pointToWalkTo) < cFormationPointWiggleRoom)
      }
      
      specificity 2;
      succeed_step;
   }
   
	// If the character is the point DO move
	sequential behavior testbed_joinAndMaintainFormation_moveToFormationPoint_perform_moveToPoint(String myName, Location pointToWalkTo, GroupWME groupWME) {
		specificity 1;
		subgoal stepToPoint(myName, pointToWalkTo, groupWME);
	}
   
   
	// if by one's self and someone is approaching, when they get close, turn to them
   sequential behavior testbed_joinAndMaintainFormation_moveToFormationPoint_perform_orient(String myName, CharacterWME myCharacterWME, double angle, GroupWME groupWME, CharacterWME approachingCharacterWME) {
		precondition {	(approachingCharacterWME != null)	
						myPhysicalWME = (PhysicalAgentWME)
                     	(myPhysicalWME.getId().equals(myName))
						targetPhysicalWME = (PhysicalAgentWME)
                     	(targetPhysicalWME.getId().equals(approachingCharacterWME.getName()))
                     	}
      specificity 2;
        String targetName;
        float lookDuration;
		mental_act { 
			angle = Staging.getXZAngleBetweenPoints(myPhysicalWME.getLocation(), targetPhysicalWME.getLocation());
			groupWME.setFormationOrientation(myCharacterWME, new Orientation(angle));
			targetName = approachingCharacterWME.getName();
			lookDuration = (float)Staging.randRange(0.4, 0.8);
		}
		subgoal headTrack(myName, targetName);		
		subgoal performAnimation_portion(myName, myName, animationIdle_SpacingOut1,
											cAnimDefaultStartTime, lookDuration);
		subgoal turnToAngle(myName, angle, groupWME);
	}

   
   // If the character is not facing the origin, do face it
   sequential behavior testbed_joinAndMaintainFormation_moveToFormationPoint_perform_orient(String myName, CharacterWME myCharacterWME, double angle, GroupWME groupWME, CharacterWME approachingCharacterWME) {
      specificity 1;
      mental_act {
		// add noise to the angle
         angle += Staging.randRange(-cFormationOrientationNoise, cFormationOrientationNoise);
		groupWME.setFormationOrientation(myCharacterWME, new Orientation(angle));
      }
      subgoal turnToAngle(myName, angle, groupWME);
   }
   
   
	parallel behavior testbed_joinAndMaintainFormation_stayCloseToFormationPoint(CharacterWME myCharacterWME, GroupWME groupWME) {
		precondition { 	myPhysicalWME = (PhysicalAgentWME)
                     	(myPhysicalWME.getId().equals(myCharacterWME.getName()))
                     	}
		number_needed_for_success 2;     
		                	
	   int sizeOfFormation;
	   float angle;
	   String myName;
	   
	   // store the number of people in the formation
	   // if it changes move to the formation Point
	   with (priority_modifier 1) mental_act {
	      myName = myCharacterWME.getName();
	      sizeOfFormation = groupWME.getSizeOfFormation();
	      angle = (float)(groupWME.getFormationOrientation(myCharacterWME).getAngle());
	   }

		// wait until the size of the formation changes
		subgoal testbed_joinAndMaintainFormation_stayCloseToFormationPoint_test1(myName, groupWME, sizeOfFormation);
		// OR
		// wait until the orientation changes
		//subgoal testbed_joinAndMaintainFormation_stayCloseToFormationPoint_test2(myName, angle);
	}
	
	// wait until the size of the formation changes
	sequential behavior testbed_joinAndMaintainFormation_stayCloseToFormationPoint_test1(String myName, GroupWME groupWME, int sizeOfFormation) {
		with (success_test { 
				(groupWME.getSizeOfFormation() != sizeOfFormation) 
			} ) wait;
		mental_act { log.info ("^^^^^^^^ " +myName+ " FORMATION SIZE TEST ^^^^^^^^"); }
	}
	
	// wait until the orientation changes
	sequential behavior testbed_joinAndMaintainFormation_stayCloseToFormationPoint_test2(String myName, float angle) {
		PhysicalAgentWME myPhysicalWME;
		with (success_test {
				myPhysicalWME = (PhysicalAgentWME)
	            (myPhysicalWME.getId().equals(myName))
				(Math.abs(myPhysicalWME.getOrientation() - angle) > cFormationOrientationNoise)
			} ) wait;
		mental_act { log.info ("^^^^^^^^ " +myName+ " FORMATION ORIENTATION TEST ^^^^^^^^ physAngle=" +myPhysicalWME.getOrientation()+ " formationAngle=" +angle); }
	}

	
	// ------------------------------------------------------------------------
	
	
	/**
	 * testbed_leaveFormation()
	 * Requires character to already have joined and approached a group
	 */	 	
	sequential behavior testbed_leaveFormation(SiuWME siuWME, String myName) {
		PerformanceWME performanceWME;
		mental_act {
			//log.info("## " +myName+ " preparing for testbed_leaveFormation");
			performanceWME = new PerformanceWME(siuWME); 
		} 
		subgoal setupPerformanceWME(performanceWME, siuWME, myName, cPerformancePriorityLow, "testbed_leaveFormation");
		with (persistent when_fails) subgoal testbed_leaveFormation(myName, performanceWME);
		subgoal performanceDoneDeleteWME(performanceWME);
	}
	
	sequential behavior testbed_leaveFormation(String myName, PerformanceWME performanceWME) {
		subgoal performanceWait(performanceWME);
		subgoal testbed_leaveFormation_perform(myName, performanceWME);
	}
	
	sequential behavior testbed_leaveFormation_perform(String myName, PerformanceWME performanceWME) {
		context_condition {	(performanceWME.getPerformanceState() == cPerformanceStatePerforming) }
      	precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
						groupWME=(GroupWME) (groupWME.contains(myCharacterWME)) 
						myPhysicalWME = (PhysicalAgentWME)
                     	(myPhysicalWME.getId().equals(myName))
      }
      
      Location pointToWalkTo;
      double angle;
      double dist;
      
	mental_act {
		log.info("## " +myName+ " performing testbed_leaveFormation"); 
			
		// Walk to a random point anywhere  
		//Location formationLoc = groupWME.getFormationLocation(myCharacterWME);
		//pointToWalkTo = new Location(formationLoc.getX() + Staging.randRange(-20,20), 0, formationLoc.getZ() + Staging.randRange(-20,20));
		
		// Walk to a point somewhere behind self (to avoid walking through the center of the group)
		angle = Staging.getXZAngleBetweenPoints(myPhysicalWME.getLocation(), groupWME.getOrigin());
		angle += Staging.randRange(-10, 10); 
		dist = cFarDistance * Staging.randRange(0.8, 1.2);
		pointToWalkTo = Staging.pointAtAngleAndDist(dist, angle, groupWME.getOrigin());
		     
      }
      
      subgoal removeFormationCharacter(myCharacterWME, groupWME);
      
      subgoal walkToPoint(myName, pointToWalkTo);
   }
	
	
	/**
	 * testbedGUI_populate
	 */
   sequential behavior testbedGUI_populate() {
      mental_act {
         __$thisEntity.behaviorTestBedGUI.addToBehaviorDropDownBox("Group Demo");
         __$thisEntity.behaviorTestBedGUI.addToBehaviorDropDownBox("givePlayerObject");
         __$thisEntity.behaviorTestBedGUI.addToBehaviorDropDownBox("studyOwnObject");
         __$thisEntity.behaviorTestBedGUI.addToBehaviorDropDownBox("studyOthersObject");
         __$thisEntity.behaviorTestBedGUI.addToBehaviorDropDownBox("reactToPersonalSpaceEncroachment");
         __$thisEntity.behaviorTestBedGUI.addToBehaviorDropDownBox("walk across demo");
         __$thisEntity.behaviorTestBedGUI.addToBehaviorDropDownBox("noticingCharacters");
         __$thisEntity.behaviorTestBedGUI.addToBehaviorDropDownBox("approachingCharacters");
         __$thisEntity.behaviorTestBedGUI.addToBehaviorDropDownBox("greetCharacters");
         __$thisEntity.behaviorTestBedGUI.addToBehaviorDropDownBox("joinAndMaintainFormation");
         __$thisEntity.behaviorTestBedGUI.addToBehaviorDropDownBox("smalltalkInGroup");  
         __$thisEntity.behaviorTestBedGUI.addToBehaviorDropDownBox("leaveFormation");
         __$thisEntity.behaviorTestBedGUI.addToBehaviorDropDownBox("giveObjectSIU");
         __$thisEntity.behaviorTestBedGUI.addToBehaviorDropDownBox("groupPassObject");
         __$thisEntity.behaviorTestBedGUI.addToBehaviorDropDownBox("daughterCutScene");
         
         __$thisEntity.behaviorTestBedGUI.addToBehaviorDropDownBox("addAttitude");
         __$thisEntity.behaviorTestBedGUI.addToBehaviorDropDownBox("removeAttitude");
         __$thisEntity.behaviorTestBedGUI.addToBehaviorDropDownBox("addGroupAttitude");
         __$thisEntity.behaviorTestBedGUI.addToBehaviorDropDownBox("removeGroupAttitude");
         //__$thisEntity.behaviorTestBedGUI.addToBehaviorDropDownBox("goodbyeAndLeaveFormation");
      }
   }


	/**
	 * testbedGUI_behaviorLauncher()
	 */	 	
	sequential behavior testbedGUI_behaviorLauncher() {
	   LaunchTestBedBehaviorWME launchWME;
	   String behaviorName;
	   String arg1;
	   String arg2;
	   String arg3;

      mental_act {
      	log.info("### Testbed GUI waiting");
		}
	
      with (success_test {
               launchWME=(LaunchTestBedBehaviorWME)        
             }) wait;      
      mental_act {
         behaviorName = launchWME.getBehaviorToLaunch();
         arg1 = launchWME.getArg1();
         arg2 = launchWME.getArg2();
         arg3 = launchWME.getArg3();
         __$thisEntity.deleteWME(launchWME);
      	log.info("### Testbed GUI launching " +behaviorName);
      }
      
      // SPAWN this, so this launcher can start again
      spawngoal testbedGUI_behaviorLauncher_switch(behaviorName,arg1,arg2,arg3);      
	}
	


   sequential behavior testbedGUI_behaviorLauncher_switch(String behaviorName, String arg1, String arg2, String arg3) {
      precondition { (behaviorName.equals("Group Demo")) }
      subgoal testbed_demo_groupSequence();
   }
   
   sequential behavior testbedGUI_behaviorLauncher_switch(String behaviorName, String arg1, String arg2, String arg3) {
      precondition { (behaviorName.equals("walk across demo")) }
      subgoal testbed_demo_walkAcross(arg1);
   }
   
   sequential behavior testbedGUI_behaviorLauncher_switch(String behaviorName, String arg1, String arg2, String arg3) {
      precondition { (behaviorName.equals("noticingCharacters")) }
      subgoal testbed_noticingCharacters(nullSiu, arg1);
   }
   
   sequential behavior testbedGUI_behaviorLauncher_switch(String behaviorName, String arg1, String arg2, String arg3) {
      precondition { (behaviorName.equals("approachingCharacters")) }
      subgoal testbed_approachingCharacters(nullSiu, arg1);
   }
   
   sequential behavior testbedGUI_behaviorLauncher_switch(String behaviorName, String arg1, String arg2, String arg3) {
      precondition { (behaviorName.equals("greetCharacters")) }
      subgoal testbed_demo_greetCharacters(arg1);
   }
   
   sequential behavior testbedGUI_behaviorLauncher_switch(String behaviorName, String arg1, String arg2, String arg3) {
      precondition { (behaviorName.equals("joinAndMaintainFormation")) }
      subgoal testbed_joinAndMaintainFormation(nullSiu, arg1, cPerformancePriorityHigh);
   }
   
   sequential behavior testbedGUI_behaviorLauncher_switch(String behaviorName, String arg1, String arg2, String arg3) {
      precondition { (behaviorName.equals("smalltalkInGroup")) }
      subgoal testbed_groupMaintenance(nullSiu, arg1, cPerformancePriorityHigh, smallTalk_Default);
   }
      
   sequential behavior testbedGUI_behaviorLauncher_switch(String behaviorName, String arg1, String arg2, String arg3) {
      precondition { (behaviorName.equals("leaveFormation")) }
      subgoal testbed_leaveFormation(nullSiu, arg1);
   }
   
   sequential behavior testbedGUI_behaviorLauncher_switch(String behaviorName, String arg1, String arg2, String arg3) {
      precondition { (behaviorName.equals("giveObjectSIU")) }
      subgoal testbed_LaunchSIU_giveObject(arg1, arg2);
   }
   
   sequential behavior testbedGUI_behaviorLauncher_switch(String behaviorName, String arg1, String arg2, String arg3) {
      precondition { (behaviorName.equals("groupPassObject")) }
      subgoal SIU_groupPassObject(nullSiu, arg1);
   }
   
   //The Daughter Cut Scene
   //Positions NPCs to prepare them for the cut scene where the daughter 
   //waves from the distance, is obfuscated by passing crowds, and then mysteriously disappears.
   sequential behavior testbedGUI_behaviorLauncher_switch(String behaviorName, String arg1, String arg2, String arg3) {
      precondition { (behaviorName.equals("daughterCutScene")) }
      subgoal testbed_daughterCutScene(nullSiu);
   }
   
   
   //Study own object.
   //Notice an object that the person specified in arg1 is holding in their hand.
   //arg2 is the person who handed you the object.
   sequential behavior testbedGUI_behaviorLauncher_switch(String behaviorName, String arg1, String arg2, String arg3) {
      precondition { (behaviorName.equals("studyOwnObject")) }
      subgoal testbed_studyOwnObject(nullSiu, arg1, arg2, cPerformancePriorityHigh);
   }
   
   //Notice a point in space a little below the player's head position.
   //arg1 is the character who will be doing the noticing.
   //arg2 is the character who is holding something that is being noticed.
   sequential behavior testbedGUI_behaviorLauncher_switch(String behaviorName, String arg1, String arg2, String arg3) {
      precondition { (behaviorName.equals("studyOthersObject")) }
      subgoal testbed_studyOthersObject(nullSiu, arg1, arg2, cPerformancePriorityHigh);
   }
   
   //Have an NPC react to a character encroaching on their personal space.
   //arg1 is the character who has had their personal space invaded.
   //arg2 is the character who is doing the invading.
   sequential behavior testbedGUI_behaviorLauncher_switch(String behaviorName, String arg1, String arg2, String arg3) {
      precondition { (behaviorName.equals("reactToPersonalSpaceEncroachment")) }
      subgoal testbed_reactToPersonalSpaceEncroachment(nullSiu, arg1, arg2);
   }
   
   // April 4-24-13: Testing taking the object back from the NPCs
   sequential behavior testbedGUI_behaviorLauncher_switch(String behaviorName, String arg1, String arg2, String arg3) {
      precondition { (behaviorName.equals("givePlayerObject")) }
      subgoal SIU_giveObjectToPlayer_specialEntry(nullSiu);
   }
   
   
   // April 3-8-13: Cleaning up/condensing the attitude WME GUI actions
   // Valid arguments are those found in the attitude type enums, currently: 
   // compliance, frustration, exasperation, jovial, serious, curious, nervous
   
   // TO DO: Figure out how to select a particular group
   sequential behavior testbedGUI_behaviorLauncher_switch(String behaviorName, String arg1, String arg2, String arg3) {
      precondition { (behaviorName.equals("addGroupAttitude")) }
      subgoal addGroupAttitude(arg1); 
   }
   
   sequential behavior testbedGUI_behaviorLauncher_switch(String behaviorName, String arg1, String arg2, String arg3) {
      precondition { (behaviorName.equals("removeGroupAttitude")) }
      subgoal removeGroupAttitude(arg1); 
      // subgoal clearFace(arg1); // TO DO: Move actions out of the GUI and into Smalltalk or somewhere else
   }
   
   // NOTE: arg1 is no longer the name, but now the attitude type, to match the group attitude variation.
   // 		arg2 is now the name.
   sequential behavior testbedGUI_behaviorLauncher_switch(String behaviorName, String arg1, String arg2, String arg3) {
      precondition { (behaviorName.equals("addAttitude")) }
      subgoal addAttitude(arg2, arg1);
   }
   
   sequential behavior testbedGUI_behaviorLauncher_switch(String behaviorName, String arg1, String arg2, String arg3) {
      precondition { (behaviorName.equals("removeAttitude")) }
      subgoal removeAttitude(arg2, arg1);
   }
   
	
	/**
	 * testbed_headTrack()
	 */	 	
	sequential behavior testbed_headTrack(SiuWME siuWME, String myName, String targetName, int minDuration, int maxDuration, int performancePriority) {
		PerformanceWME performanceWME;
		float duration;
		mental_act {
			//log.info("## " +myName+ " preparing for testbed_headTrack " +targetName+ " " +anim); 
			performanceWME = new PerformanceWME(siuWME);
		}
		subgoal setupPerformanceWME(performanceWME, siuWME, myName, performancePriority, cPerformanceTypeExpression, 
									"testbed_headTrack", "");
		with (ignore_failure) subgoal testbed_headTrack(myName, targetName, minDuration, maxDuration, performanceWME);
		subgoal performanceDoneDeleteWME(performanceWME);
	}
	
	sequential behavior testbed_headTrack(String myName, String targetName, int minDuration, int maxDuration, PerformanceWME performanceWME) {
		subgoal performanceWait(performanceWME);
		subgoal testbed_headTrack_perform(myName, targetName, minDuration, maxDuration, performanceWME);
	}
				
	sequential behavior testbed_headTrack_perform(String myName, String targetName, int minDuration, int maxDuration, PerformanceWME performanceWME) {
		context_condition {	(performanceWME.getPerformanceState() == cPerformanceStatePerforming) }
		mental_act { log.info("## " +myName+ " performing testbed_headTrack to " +targetName); } 
		subgoal headTrack(myName, targetName);
		subgoal waitForRand(minDuration, maxDuration);
	}
	
		
	/**
	 * testbed_gestureToCharacter()
	 */	 	
	sequential behavior testbed_gestureToCharacter(SiuWME siuWME, String myName, String targetName, String anim, boolean bAnimationOrWrapOn,
													float duration, boolean bLookTo, boolean bTurnTo, int performancePriority) {
		PerformanceWME performanceWME;
		mental_act {
			//log.info("## " +myName+ " preparing for testbed_gestureToCharacter " +targetName+ " " +anim); 
			performanceWME = new PerformanceWME(siuWME); 
		}
		subgoal setupPerformanceWME(performanceWME, siuWME, myName, performancePriority, cPerformanceTypeExpression, 
									"testbed_gestureToCharacter", anim);
		with (persistent when_fails) subgoal testbed_gestureToCharacter(myName, targetName, anim, bAnimationOrWrapOn,
																		duration, bLookTo, bTurnTo, performanceWME);
		subgoal performanceDoneDeleteWME(performanceWME);
	}
	
	sequential behavior testbed_gestureToCharacter(String myName, String targetName, String anim, boolean bAnimationOrWrapOn, float duration, boolean bLookTo, boolean bTurnTo, PerformanceWME performanceWME) {
		subgoal performanceWait(performanceWME);
		subgoal testbed_gestureToCharacter_perform(myName, targetName, anim, bAnimationOrWrapOn, duration, bLookTo, bTurnTo, performanceWME);
	}
				
	sequential behavior testbed_gestureToCharacter_perform(String myName, String targetName, String anim, boolean bAnimationOrWrapOn, float duration, boolean bLookTo, boolean bTurnTo, PerformanceWME performanceWME) {
		context_condition {	(performanceWME.getPerformanceState() == cPerformanceStatePerforming) }
		mental_act { 
			log.info("## " +myName+ " performing testbed_gestureToCharacter " +anim); 
			if (myName.equals(targetName)) { bLookTo = false; bTurnTo = false; } 
		}				
		with (ignore_failure) subgoal testbed_gestureToCharacter_lookTo(myName, targetName, bLookTo);
		with (ignore_failure) subgoal testbed_gestureToCharacter_turnTo(myName, targetName, bTurnTo);
		subgoal testbed_gestureToCharacter_perform_animOrWrapOn(myName, anim, bAnimationOrWrapOn, duration);								                     
	}
	
	// ## animation
	sequential behavior testbed_gestureToCharacter_perform_animOrWrapOn(String myName, String anim, 
																		boolean bAnimationOrWrapOn, float duration) {
		precondition { (bAnimationOrWrapOn == true) }
		subgoal performAnimation_portion(myName, myName, anim, cAnimDefaultStartTime, duration);								                     
	}
	
	// ## wrapOn
	sequential behavior testbed_gestureToCharacter_perform_animOrWrapOn(String myName, String anim, 
																		boolean bAnimationOrWrapOn, float duration) {
		precondition { (bAnimationOrWrapOn == false) }
 		subgoal performWithAttitude(myName, anim, duration);
	}

	sequential behavior testbed_gestureToCharacter_lookTo(String myName, String targetName, boolean bLookTo) {
		precondition {	(bLookTo == true) }
		subgoal headTrack(myName, targetName);
	}

	sequential behavior testbed_gestureToCharacter_turnTo(String myName, String targetName, boolean bTurnTo) {
		precondition {	(bTurnTo == true) 
						targetPhysicalWME=(PhysicalAgentWME) (targetPhysicalWME.getId().equals(targetName))
						}
		Location targetPt;
		mental_act { targetPt = targetPhysicalWME.getLocation(); }		
		subgoal turnToFacingPoint(myName, targetPt);
	}

		
	/**
	 * testbed_greetCharacters()
	 */	 	
	sequential behavior testbed_greetCharacters(SiuWME siuWME, String myName, CharactersWME charactersWME, int performancePriority) {
		PerformanceWME performanceWME;
		mental_act {
			//log.info("## " +myName+ " preparing for testbed_greetCharacters"); 
			performanceWME = new PerformanceWME(siuWME); 
		}
		subgoal setupPerformanceWME(performanceWME, siuWME, myName, performancePriority,"testbed_greetCharacters"); 
		with (persistent when_fails) subgoal testbed_greetCharacters(myName, charactersWME, performanceWME);
		subgoal performanceDoneDeleteWME(performanceWME);
	}
	
	sequential behavior testbed_greetCharacters(String myName, CharactersWME charactersWME, PerformanceWME performanceWME) {
		subgoal performanceWait(performanceWME);
		subgoal testbed_greetCharacters_perform(myName, charactersWME, performanceWME);
	}
	
	sequential behavior testbed_greetCharacters_perform(String myName, CharactersWME charactersWME, PerformanceWME performanceWME) {
		context_condition {	(performanceWME.getPerformanceState() == cPerformanceStatePerforming) }
		precondition {	myPhysicalWME = (PhysicalAgentWME)
                     	(myPhysicalWME.getId().equals(myName))
                     	charWME = (CharacterWME) (charWME.getName().equals(myName) == true)
                     	groupWME=(GroupWME) (groupWME.contains(charWME))
						}
        double angle;
        CharactersWME greetCharactersWME;
		mental_act { 
			log.info("## " +myName+ " performing testbed_greetCharacters"); 
			greetCharactersWME = new CharactersWME(); 
		} 

		// sense the locations of all characters
		subgoal cloneCharactersWMESenseAndRemoveSelf(myName, charactersWME, greetCharactersWME);
        
        mental_act { 
        	//point = groupWME.getOrigin();
			angle = GroupUtil.getAverageAngleToCharacters(myPhysicalWME.getLocation(), 
															greetCharactersWME.getCharacterWMEs());															 
        } 
		subgoal headTrackOff(myName);
		//subgoal turnToFacingPoint(myName, point);
		subgoal turnToAngle(myName, angle, groupWME);
		subgoal testbed_greetCharacters_main(myName, greetCharactersWME);
		subgoal headTrackOff(myName);
	}
		
	parallel behavior testbed_greetCharacters_main(String myName, CharactersWME greetCharactersWME) {
		subgoal testbed_greetCharacters_greet(myName);
		subgoal glanceAmongCharacters(myName, greetCharactersWME);
	}
	
	sequential behavior testbed_greetCharacters_greet(String myName) {
		//subgoal waitForRand(200, 800);
		subgoal performAnimation(myName, myName, animationBowSmallGreet, true);						
	}
		
   	 
	/**
	 * testbed_groupMaintenance()
	 *
	 * April (1-30-13)
	 * For now, testbed_groupMaintenance_demo() calls the functions in this section
	 * Each option is dependent on the social situation in order of specificity:
	 * 1. Speak
	 * 2. Listen to speaker
	 * 3. While doing 1 and 2, look at other people in the group
	 */	 	
	 
	// Current Dialogue Variation Parameters in AblHeader
    // smallTalk_Default -- What I made first
    // smallTalk_DiscussDistant -- Looking at staring at the player suspiciously and obviously
    // smallTalk_DiscussClose -- Repeated glances/motions at player as the topic of discussion in-group
    // smallTalk_DiscussTopic -- Quick gestures, listening behaviors that look like talking

	sequential behavior testbed_groupMaintenance(SiuWME siuWME, String myName, int performancePriority, String variation) {
		PerformanceWME performanceWME;
		mental_act {
			//log.info("## " +myName+ " preparing for testbed_groupMaintenance"); 
			performanceWME = new PerformanceWME(siuWME); 

			// for development, override incoming parameter with this
			//variation = smallTalk_Default;
			//variation = smallTalk_DiscussDistant;
			//variation = smallTalk_DiscussClose;
			//variation = smallTalk_DiscussTopic;
		}
		subgoal setupPerformanceWME(performanceWME, siuWME, myName, performancePriority, "testbed_groupMaintenance");
		
		// do smalltalk indefinitely 
		with (persistent /*when_fails*/) subgoal testbed_groupMaintenance(myName, performanceWME, variation);
		
		subgoal performanceDoneDeleteWME(performanceWME);
	}
	
	sequential behavior testbed_groupMaintenance(String myName, PerformanceWME performanceWME, String variation) {
		subgoal performanceWait(performanceWME);
		subgoal testbed_groupMaintenance_perform(myName, performanceWME, variation);
	}
	
	sequential behavior testbed_groupMaintenance_perform(String myName, PerformanceWME performanceWME, String variation) {
		context_condition {	(performanceWME.getPerformanceState() == cPerformanceStatePerforming) }
		precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
                     	groupWME=(GroupWME) (groupWME.contains(myCharacterWME))
                     }                     	
        CharactersWME othersInFormationCharactersWME;
		ReturnValueWME retValWME;
        
        // get list of other characters in the formation
		mental_act {
			log.info("## " +myName+ " performing testbed_groupMaintenance"); 
			othersInFormationCharactersWME = GroupUtil.cloneAndRemoveSelf(myName, groupWME.getFormationCharactersWME());
			retValWME = new ReturnValueWME(); retValWME.setString(variation);
		}

		// possibly convert default variation to discuss distant
		with (ignore_failure) subgoal testbed_groupMaintenance_updateVariation(myCharacterWME, groupWME, retValWME);
		mental_act { variation = retValWME.getString(); }
		
		with (ignore_failure) subgoal testbed_groupMaintenance_cleanUpGroupAngle(myName);
		subgoal testbed_groupMaintenance_performWithHeadtrack(myName, othersInFormationCharactersWME, variation);
	}

	
	// if the player has approached a group, 
	// and if the player is not in our group, 
	// then discuss the player   
	// unless we're hostile, then we don't
	sequential behavior testbed_groupMaintenance_updateVariation(CharacterWME myCharacterWME, GroupWME groupWME, ReturnValueWME retValWME) {
		precondition { 	(myCharacterWME.hasAttitude(eAttitudeType_hostile) == false)
						(EpisodicMemoryWME characterName==playerName episodeName==siuNameApproach)
						playerCharacterWME=(CharacterWME) (playerCharacterWME.getName().equals(playerName))
						(groupWME.contains(playerCharacterWME) == false) 
						}
		mental_act { retValWME.setString(smallTalk_DiscussDistant); }
	}
	
	parallel behavior testbed_groupMaintenance_performWithHeadtrack(String myName, CharactersWME othersInFormationCharactersWME, String variation) {
		subgoal testbed_groupMaintenance_smallTalk(myName, othersInFormationCharactersWME, variation);
				
		with (persistent, effect_only) subgoal testbed_groupMaintenance_headtrackPlayer(myName, othersInFormationCharactersWME, variation);
		with (persistent, effect_only) subgoal testbed_groupMaintenance_headtrackInsider(myName, othersInFormationCharactersWME, variation);

		// possibly launch a briefChat SIU in parallel with this SIU		
		with (ignore_failure) subgoal testbed_cif_possiblySpawnABriefChat(myName, true, 20, cPerformancePriorityMedLow);	// above groupMaintenance
	}
	
	sequential behavior testbed_groupMaintenance_headtrackInsider(String myName, CharactersWME othersInFormationCharactersWME, String variation) {
		// replacing precondition with success test
		precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
                     	groupWME=(GroupWME) (groupWME.contains(myCharacterWME)) 
						(groupWME.getConversationWME() != null) 
						characterWME=(CharacterWME) 
						(othersInFormationCharactersWME.containsCharacter(characterWME.getName()) == true)
						(characterWME.getName().equals(myName) == false) }
						
		String target;
		
		subgoal waitForRand(1000,4000);
		
		with (success_test { (groupWME.getConversationWME().getState().equals("glaring")) }) wait;
			
		mental_act {
			target = characterWME.getName();
		}

		// this was only head tracking and setting a facial expression; 
		// facial expressions are now handled in the FaceMgr; 
		// so just do the headtrack here
		//subgoal performWithAttitude(eAttitudePerform_glance, myName, target);
		subgoal headTrack(myName, target);
		
		subgoal waitForRand(1000,2000);
	}
	
	/*
	 * There are 3 versions of headtrackPlayer for smalltalk.
	 * All of them track the player, just for varying amounts of time
	 */
	
	sequential behavior testbed_groupMaintenance_headtrackPlayer(String myName, CharactersWME othersInFormationCharactersWME, String variation) {
		// replacing  precondition with success test
		precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
                     	groupWME=(GroupWME) (groupWME.contains(myCharacterWME)) 
						(groupWME.getConversationWME() != null) 
						characterWME=(CharacterWME) 
						(othersInFormationCharactersWME.containsCharacter(characterWME.getName()) == false)
						(characterWME.getName().equals(myName) == false)
						(variation.equals(smallTalk_Default)) }
						
		String target;
		subgoal waitForRand(4000,5000);
		with (success_test { (groupWME.getConversationWME().getState().equals("glaring")) }) wait;
			
		mental_act {
			target = playerName;
		}
		
		// Glance at the player for a little bit
		
		// this was only head tracking and setting a facial expression; 
		// facial expressions are now handled in the FaceMgr; 
		// so just do the headtrack here
		//subgoal performWithAttitude(eAttitudePerform_glance, myName, target);
		subgoal headTrack(myName, target);
		
		subgoal waitForRand(1000,2000);
	}
	
	sequential behavior testbed_groupMaintenance_headtrackPlayer(String myName, CharactersWME othersInFormationCharactersWME, String variation) {
		// replacing  precondition with success test
		precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
                     	groupWME=(GroupWME) (groupWME.contains(myCharacterWME)) 
						(groupWME.getConversationWME() != null) 
						characterWME=(CharacterWME) 
						(othersInFormationCharactersWME.containsCharacter(characterWME.getName()) == false)
						(characterWME.getName().equals(myName) == false)
						(variation.equals(smallTalk_DiscussDistant)) }
						
		String target;
		subgoal waitForRand(500,2000);
		with (success_test { (groupWME.getConversationWME().getState().equals("glaring")) }) wait;
			
		mental_act {
			target = playerName;
		}

		// this was only head tracking and setting a facial expression; 
		// facial expressions are now handled in the FaceMgr; 
		// so just do the headtrack here
		//subgoal performWithAttitude(eAttitudePerform_glance, myName, target);
		subgoal headTrack(myName, target);

		// Glare at the outsider longer
		subgoal waitForRand(4000,5000);
	}
	
	sequential behavior testbed_groupMaintenance_headtrackPlayer(String myName, CharactersWME othersInFormationCharactersWME, String variation) {
		// replacing  precondition with success test
		precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
                     	groupWME=(GroupWME) (groupWME.contains(myCharacterWME)) 
						(groupWME.getConversationWME() != null) 
						characterWME=(CharacterWME) 
						(othersInFormationCharactersWME.containsCharacter(characterWME.getName()) == false)
						(characterWME.getName().equals(myName) == false)
						(variation.equals(smallTalk_DiscussClose) || variation.equals(smallTalk_DiscussTopic)) }
						
		String target;
		subgoal waitForRand(2000,3000);
		with (success_test { (groupWME.getConversationWME().getState().equals("glaring")) }) wait;
			
		mental_act {
			target = playerName;
		}

		// this was only head tracking and setting a facial expression; 
		// facial expressions are now handled in the FaceMgr; 
		// so just do the headtrack here
		//subgoal performWithAttitude(eAttitudePerform_glance, myName, target);
		subgoal headTrack(myName, target);

		// Glance at the player quickly
		subgoal waitForRand(500,1000);
	}

	sequential behavior testbed_groupMaintenance_headtrackSpeaker(String myName, String variation) {
		precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
                     	groupWME=(GroupWME) (groupWME.contains(myCharacterWME)) 
						(groupWME.getConversationWME() != null) 
						}

		String speaker;
		
		with (success_test  { (groupWME.getConversationWME().getState().equals("glaring")) }) wait;
		
		// wait until I'm not the speaker
		with (success_test { (groupWME.getConversationWME().getSpeakerName().equals(myName) == false) }) wait;
			
		mental_act {
			speaker = groupWME.getConversationWME().getSpeakerName();			
			//log.info(myName + " notices another speaker " + speaker + " speaks!");
		}
		subgoal headTrack(myName, speaker);
		
		subgoal waitFor(1000);
	}
	
	// There is no one else to speak to, so delete the WME
	sequential behavior testbed_groupMaintenance_pickNewSpeaker(String myName, CharactersWME othersInFormationCharactersWME, String variation) {                     	 
		precondition {	(othersInFormationCharactersWME.getSize() == 0) 
						myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
                     	groupWME=(GroupWME) (groupWME.contains(myCharacterWME))
						(groupWME.getConversationWME() != null) 
						(groupWME.getConversationWME().getSpeakerName().equals(myName) == true)
					}		
		mental_act {
			ConversationWME conversationWME;		
			conversationWME = groupWME.getConversationWME(); 
			//log.info(myName + " no one to pass speaking to, DELETE it"); 
			__$thisEntity.deleteWME(conversationWME);
			groupWME.setConversationWME(null);			
		}
	
	}
	
	// Grabs any old listener (except the player) and lets them be the speaker
	sequential behavior testbed_groupMaintenance_pickNewSpeaker(String myName, CharactersWME othersInFormationCharactersWME, String variation) {
		precondition {	(othersInFormationCharactersWME.getSize() != 0) }
		
		String nextSpeaker;

		mental_act {
			// choose a new speaker, but not the player
			nextSpeaker = "";
			do { 
				nextSpeaker = othersInFormationCharactersWME.getRandom().getName();
			} while (nextSpeaker.equals(playerName));
			
			//log.info(myName + " passing speaking torch to " + nextSpeaker);
		}
		
		subgoal testbed_groupMaintenance_createConversationWMEForNewSpeaker(myName, nextSpeaker, variation);
		
	}

	sequential behavior testbed_groupMaintenance_setNewSpeaker(GroupWME groupWME, String newSpeaker, String variation) {
		String oldSpeaker;
		mental_act { oldSpeaker = groupWME.getConversationWME().getSpeakerName(); }
		subgoal testbed_groupMaintenance_createConversationWMEForNewSpeaker(oldSpeaker, newSpeaker, variation);
	} 
	
	
	// Grabs an updated group for the new speaker and makes their WME
	sequential behavior testbed_groupMaintenance_createConversationWMEForNewSpeaker(String oldSpeaker, String newSpeaker, String variation) {
		precondition {	oldDWME=(ConversationWME)
						(oldDWME.getSpeakerName().equals(oldSpeaker) == true)
						
						myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(newSpeaker)) 
                     	groupWME=(GroupWME) (groupWME.contains(myCharacterWME))
                     } 
                     
        CharactersWME othersInFormationCharactersWME;
        ConversationWME conversationWME;
        
        // get list of other characters in the formation
		mental_act {
			log.info("$$$ DELETING conversationWME for " + oldSpeaker);
			__$thisEntity.deleteWME(oldDWME);
			
			othersInFormationCharactersWME = GroupUtil.cloneAndRemoveSelf(newSpeaker, groupWME.getFormationCharactersWME());
			conversationWME = new ConversationWME(newSpeaker, othersInFormationCharactersWME, groupWME, variation);
			__$thisEntity.addWME(conversationWME);
			
			log.info("$$$ Registered conversationWME for " + newSpeaker);
		}        
	}
	
	
	/**
	 * Specificity/Flow of Small Talk
	 * (4): A speaker has triggered a glare at a character. GLARE AT THEM!
	 * (3): No one else has arrived, look impatient -- catch when the group is empty
	 * (3): If I left a hanging conversationWME, pass the torch -- catch when the speaker has left
	 * (3): A conversationWME exists and it's mine! Speak, then pass the torch -- I must perform!
	 *		-> 2 versions, 1 for normal, 1 for signaling to glare at the player
	 * (2): No dialogue WME exists, create one -- People are around but no one is speaking
	 * (2): Someone else is speaking, listen to them -- People are around and they are speaking
	 *		-> 2 versions, 1 for normal, 1 for listening for the glare signal
	 * 
	 */
	 
	 /*
	  * testbed_groupMaintenance_smallTalk()
	  * A speaker has triggered a glare at a character (probably the player). GLARE AT THEM!	
	  */
	  
	sequential behavior testbed_groupMaintenance_smallTalk(String myName, CharactersWME othersInFormationCharactersWME, String variation) {
		precondition {	charWME = (CharacterWME) (charWME.getName().equals(myName) == true)
                     	groupWME=(GroupWME) (groupWME.contains(charWME))
						(groupWME.getConversationWME() != null) 
						(groupWME.getConversationWME().getState().equals("glaring"))
						(variation.equals(smallTalk_DiscussDistant))
                     }
                     
        context_condition{ (groupWME.getConversationWME() != null)
        				   (groupWME.getConversationWME().getState().equals("glaring")) }
        specificity 4;
        String target;
        
        
    	mental_act { 	target = groupWME.getConversationWME().getSubjectName();
    					//log.info(myName + " gotta glare at " + target);
    			   }
    	subgoal testbed_groupMaintenance_glareAt(myName, target, variation);
	} 
	
	/*
	 * testbed_groupMaintenance_smallTalk()
	 * No one else is around. Do something idle!
	 */
	sequential behavior testbed_groupMaintenance_smallTalk(String myName, CharactersWME othersInFormationCharactersWME, String variation) {
		precondition {	(othersInFormationCharactersWME.getSize() == 0) 
						myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
                     	groupWME=(GroupWME) (groupWME.contains(myCharacterWME))
                     }                     	

        specificity 3;
        String targetName;
        mental_act {
        	CharacterWME characterWME;
        	characterWME = groupWME.getRandomApproachingCharacterWME();
        	if (characterWME != null) {
	        	targetName = characterWME.getName();
	        	//log.info(myName + " NO ONE ELSE HAS ARRIVED! LOOK IMPATIENT at approaching " +targetName);
	        } else { 
	        	targetName = myName;
	        	//log.info(myName + " NO ONE ELSE HAS ARRIVED! LOOK IMPATIENT!");
	        } 
        }

		subgoal performAnimation_portion(myName, myName, animationIdle_Impatient,
											cAnimDefaultStartTime, 2.0);
    }

		
	/*
	 * testbed_groupMaintenance_smallTalk()
	 * If speaker has left the formation without deleting their ConversationWME - delete it and start smalltalk again
	 */
/* This was triggering when we didn't want -- let's not do this
	sequential behavior testbed_groupMaintenance_smallTalk(String myName, CharactersWME othersInFormationCharactersWME, String variation) {
		precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
                     	groupWME=(GroupWME) (groupWME.contains(myCharacterWME))
						(groupWME.getConversationWME() != null) 
						(groupWME.getConversationWME().getSpeakerName().equals(myName) == false)
						(othersInFormationCharactersWME.containsCharacter(groupWME.getConversationWME().getSpeakerName()) == false)
                      }
        specificity 3;
		        
		mental_act { 
			ConversationWME conversationWME;		
			conversationWME = groupWME.getConversationWME(); 
			//log.info(conversationWME.getSpeakerName() + " was speaking and left.  DELETING conversationWME"); 
			__$thisEntity.deleteWME(conversationWME); 
			groupWME.setConversationWME(null); 
		}
	}
*/	
	
	/*
	 * testbed_groupMaintenance_smallTalk()
	 * No one else is speaking, so speak! -- DEFAULT
	 */
	sequential behavior testbed_groupMaintenance_smallTalk(String myName, CharactersWME othersInFormationCharactersWME, String variation) {
		precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName))  
                     	groupWME=(GroupWME) (groupWME.contains(myCharacterWME)) 
                     	(groupWME.getConversationWME() == null)
                     }
        specificity 2;
        ConversationWME conversationWME;
        mental_act {
        	//log.info(myName+ " CREATING ConversationWME for self to speak");
			conversationWME = new ConversationWME(myName, othersInFormationCharactersWME, groupWME, variation);
			__$thisEntity.addWME(conversationWME);
			//log.info("Registered conversationWME for " + myName);
		}
		
		subgoal testbed_groupMaintenance_smallTalk(myName, othersInFormationCharactersWME, variation);
	}
		
		
	/*
	 * testbed_groupMaintenance_smallTalk()
	 * I'm speaking, so speak!
	 */
	sequential behavior testbed_groupMaintenance_smallTalk(String myName, CharactersWME othersInFormationCharactersWME, String variation) {
		precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
                     	groupWME=(GroupWME) (groupWME.contains(myCharacterWME)) 
						(groupWME.getConversationWME() != null) 
						(groupWME.getConversationWME().getSpeakerName().equals(myName) == true)
						(variation.equals(smallTalk_Default) || variation.equals(smallTalk_DiscussClose))
                      }
        specificity 3;
        ReturnValueWME retValWME;
        ReturnValueWME retValWME2;
        String audio1;
        String audio2;
        String tone;
                
        mental_act {        	
        	//log.info(myName + " has ConversationWME and is about to speak (#Default or #Close)");
        	// Animation handled in AttitudeManager
        	
			retValWME = new ReturnValueWME(); 
			retValWME2 = new ReturnValueWME(); 
		}
        subgoal testbed_getRandomDialog(retValWME, false);
        subgoal testbed_getRandomDialog(retValWME2, false);
        mental_act {
        	audio1 = retValWME.getString();
        	audio2 = retValWME2.getString();
        	tone = retValWME2.getString2();
        }
		
		// SPEAK animation
		subgoal testbed_groupMaintenance_smallTalk_speak(myName, audio1, audio2, tone);
		
		mental_act {
			//log.info(myName + " finished speaking. DELETING conversationWME"); 
			//log.info(myName + " finished speaking.");
			//__$thisEntity.deleteWME(conversationWME); 
		}
		
		// I'm done speaking, so pick new speaker
		subgoal testbed_groupMaintenance_pickNewSpeaker(myName, othersInFormationCharactersWME, variation);
	}
	
	/*
	 * testbed_groupMaintenance_smallTalk()
	 * I'm speaking, so speak! -- DiscussTopic
	 */
	sequential behavior testbed_groupMaintenance_smallTalk(String myName, CharactersWME othersInFormationCharactersWME, String variation) {
		precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
                     	groupWME=(GroupWME) (groupWME.contains(myCharacterWME)) 
						(groupWME.getConversationWME() != null) 
						(groupWME.getConversationWME().getSpeakerName().equals(myName) == true)
						(variation.equals(smallTalk_DiscussTopic))
                      }
        specificity 3;
        ReturnValueWME retValWME;
        ReturnValueWME retValWME2;
        String audio1;
        String audio2;
        String tone;
                
        mental_act {
        	int i;
        	//log.info(myName + " has ConversationWME and is about to speak (#Default or #Close)");
        	// Animation handled in AttitudeManager
        	
			retValWME = new ReturnValueWME(); 
			retValWME2 = new ReturnValueWME(); 
		}
        
        subgoal testbed_getRandomDialog(retValWME, false);
        subgoal testbed_getRandomDialog(retValWME2, false);
        mental_act {
        	audio1 = retValWME.getString();
        	audio2 = retValWME2.getString();
        	tone = retValWME2.getString2();
        }

		// SPEAK animation
		subgoal testbed_groupMaintenance_smallTalk_speakFast(myName, audio1, audio2, tone);
		
		mental_act {
			//log.info(myName + " finished speaking. DELETING conversationWME"); 
			//log.info(myName + " finished speaking.");
			//__$thisEntity.deleteWME(conversationWME); 
		}
		
		// I'm done speaking, so pick new speaker
		subgoal testbed_groupMaintenance_pickNewSpeaker(myName, othersInFormationCharactersWME, variation);
	}
	
	/*
	 * testbed_groupMaintenance_smallTalk() 
	 * I'm speaking, so speak! -- DISTANT
	 */
	sequential behavior testbed_groupMaintenance_smallTalk(String myName, CharactersWME othersInFormationCharactersWME, String variation){
		precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
                     	groupWME=(GroupWME) (groupWME.contains(myCharacterWME)) 
						(groupWME.getConversationWME() != null) 
						(groupWME.getConversationWME().getSpeakerName().equals(myName) == true)
						(variation.equals(smallTalk_DiscussDistant))
                      }
        specificity 3;
        ReturnValueWME retValWME;
        ReturnValueWME retValWME2;
        String audio1;
        String audio2;
        String tone;
                
        mental_act {
        	//log.info(myName + " has ConversationWME and is about to speak (#Distant)");
        	// Animation handled in AttitudeManager
        	
			retValWME = new ReturnValueWME(); 
			retValWME2 = new ReturnValueWME(); 
		}
        
        subgoal testbed_getRandomDialog(retValWME, false);
        subgoal testbed_getRandomDialog(retValWME2, false);
        mental_act {
        	audio1 = retValWME.getString();
        	audio2 = retValWME2.getString();
        	tone = retValWME2.getString2();
        }
		
		with (ignore_failure) subgoal testbed_groupMaintenance_glanceRandom(myName, othersInFormationCharactersWME, tone);

		// SPEAK animation
		subgoal testbed_groupMaintenance_smallTalk_speak(myName, audio1, audio2, tone);
		
		mental_act {
			//log.info(myName + " finished speaking. DELETING dialogueWME"); 
			//log.info(myName + " finished speaking.");
			//__$thisEntity.deleteWME(dialogueWME); 
			
			// Trigger the glaring!
			//log.info(myName + " TRIGGERING GLARE.");
			groupWME.getConversationWME().setSubjectName(playerName);
			groupWME.getConversationWME().setState("glaring");
		}
		
		// Glare at the player when I'm done talking
		subgoal testbed_groupMaintenance_glareAt(myName, playerName, variation);
		
		mental_act {
			// Finish the glaring!
			//log.info(myName + " FINISHED GLARE.");
			groupWME.getConversationWME().setSubjectName("");
			groupWME.getConversationWME().setState("talking");
		}
		
		// pick new speaker
		subgoal testbed_groupMaintenance_pickNewSpeaker(myName, othersInFormationCharactersWME, variation);
	}
	
				
	/*
	 * testbed_groupMaintenance_smallTalk_speak
	 */	
	parallel behavior testbed_groupMaintenance_smallTalk_speak(String myName, String audio, String audio2, String tone) {
		subgoal performWithAttitude(myName, eAttitudePerform_speak, cAttitudeDefaultDuration);
		with (ignore_failure, effect_only) subgoal testbed_groupMaintenance_smallTalk_speak_audio(myName, audio, audio2, tone);
	}
	
	/*
	 * testbed_groupMaintenance_smallTalk_speakFast -- For DisucssTopic variant
	 */	
	parallel behavior testbed_groupMaintenance_smallTalk_speakFast(String myName, String audio, String audio2, String tone) {
		subgoal performWithAttitude(myName, eAttitudePerform_speak, cAttitudeDefaultDuration);
		with (ignore_failure, effect_only) subgoal testbed_groupMaintenance_smallTalk_speak_audio(myName, audio, audio2, tone);
	}
											
	sequential behavior testbed_groupMaintenance_smallTalk_speak_audio(String myName, String audio, String audio2, String tone) {
	
		// fixme: only play audio if player is close enough; Unity should handle this
		precondition { 	myPhysicalWME=(PhysicalAgentWME)
                     	(myPhysicalWME.getId().equals(myName))
						playerPhysicalWME=(PhysicalAgentWME)
                     	(playerPhysicalWME.getId().equals(playerName))
                     	(Staging.getXZDistanceBetweenPoints(myPhysicalWME.getLocation(), 
                     											playerPhysicalWME.getLocation()) 
                     										< cAudibleDistance)
					}
			
		subgoal speakDialogue(myName, audio, true, dialogue_gender_male, tone);
		subgoal speakDialogue(myName, audio2, true, dialogue_gender_male, tone);
	}
	
		
	/*
	 * testbed_groupMaintenance_smallTalk()
	 * Someone else is speaking -- nod, laugh or look confused -- DEFAULT
	 */
	sequential behavior testbed_groupMaintenance_smallTalk(String myName, CharactersWME othersInFormationCharactersWME, String variation) {
		precondition {	charWME = (CharacterWME) (charWME.getName().equals(myName) == true)
                     	groupWME=(GroupWME) (groupWME.contains(charWME))
						(groupWME.getConversationWME() != null) 
						(variation.equals(smallTalk_Default) || variation.equals(smallTalk_DiscussClose))
                     }
                     	
        // No other conversationWMEs pop up for which I am the speaker
        context_condition { (groupWME.getConversationWME() != null)
        					(groupWME.getConversationWME().getSpeakerName().equals(myName) == false) }
							
        specificity 2;
        String speaker;
        
        mental_act {
         	speaker = groupWME.getConversationWME().getSpeakerName();         	
         	//log.info(myName + " is listening in smalltalk to " + speaker + " (#Default or #Close)");
		}
		
		subgoal headTrack(myName, speaker);
		
		subgoal performWithAttitude(myName, eAttitudePerform_listen, cAnimDefaultEndTime);
	}
	
	/*
	 * testbed_groupMaintenance_smallTalk()
	 * Someone else is speaking -- nod, laugh or look confused -- DiscussTopic
	 */
	sequential behavior testbed_groupMaintenance_smallTalk(String myName, CharactersWME othersInFormationCharactersWME, String variation) {
		precondition {	charWME = (CharacterWME) (charWME.getName().equals(myName) == true)
                     	groupWME=(GroupWME) (groupWME.contains(charWME))
						(groupWME.getConversationWME() != null) 
						(variation.equals(smallTalk_DiscussTopic))
                     }
                     	
        // No other conversationWMEs pop up for which I am the speaker
        context_condition { (groupWME.getConversationWME() != null)
        					(groupWME.getConversationWME().getSpeakerName().equals(myName) == false) }
							
        specificity 2;
        String speaker;
        
        mental_act {
         	speaker = groupWME.getConversationWME().getSpeakerName();         	
         	//log.info(myName + " is listening in smalltalk to " + speaker + " (#DiscussTopic)");
		}
		
		subgoal headTrack(myName, speaker);
		
		subgoal performWithAttitude(myName, eAttitudePerform_listen, cAnimDefaultEndTime);
	}
	
	/*
	 * testbed_groupMaintenance_smallTalk()
	 * Someone else is speaking -- nod, laugh or look confused -- DISTANT
	 */
	sequential behavior testbed_groupMaintenance_smallTalk(String myName, CharactersWME othersInFormationCharactersWME, String variation) {
		precondition {	charWME = (CharacterWME) (charWME.getName().equals(myName) == true)
                     	groupWME=(GroupWME) (groupWME.contains(charWME))
						(groupWME.getConversationWME() != null) 
						(variation.equals(smallTalk_DiscussDistant))
                     }
                     	
        // No other conversationWMEs pop up for which I am the speaker
        context_condition { (groupWME.getConversationWME() != null)
        					(groupWME.getConversationWME().getSpeakerName().equals(myName) == false)
        					(groupWME.getConversationWME().getState().equals("talking") == true) 
        				  }
							
        specificity 2;
        String speaker;
        
        mental_act {
         	speaker = groupWME.getConversationWME().getSpeakerName();         	
         	//log.info(myName + " is listening in smalltalk to " + speaker + " (#Distant)");
		}
		
		subgoal headTrack(myName, speaker);
		
		subgoal performWithAttitude(myName, eAttitudePerform_listen, cAnimDefaultEndTime);
	}

	
	/*
	 * testbed_groupMaintenance_glanceRandom
	 */	
	sequential behavior testbed_groupMaintenance_glanceRandom(String myName, CharactersWME othersInFormationCharactersWME, String variation) {
		precondition { (othersInFormationCharactersWME.getSize() > 0) }
		String target;
		mental_act {
			target = othersInFormationCharactersWME.getRandom().getName();
			//log.info(myName + " GLANCING AT.... " + target);
		}
		subgoal headTrack(myName, target);
	}
	
	/*
	 * testbed_groupMaintenance_glareAt
	 */
	sequential behavior testbed_groupMaintenance_glareAt(String myName, String target, String variation) {
		subgoal testbed_groupMaintenance_startGlare(myName, target, variation);
		subgoal testbed_groupMaintenance_continueGlare(myName, target, variation);
		subgoal testbed_groupMaintenance_finishGlare(myName, target, variation);
	}
	
	/*
	 * testbed_groupMaintenance_startGlare
	 * Figure out where the target is and face them
	 * TO DO: Change this to turning toward them 1/2 way, leaning, or some sublter form
	 */
	sequential behavior testbed_groupMaintenance_startGlare(String myName, String target, String variation) {
		precondition {  myPhysicalWME = (PhysicalAgentWME)
                     	(myPhysicalWME.getId().equals(myName))
						targetPhysicalWME = (PhysicalAgentWME)
                     	(targetPhysicalWME.getId().equals(target)) 
                     	charWME = (CharacterWME) (charWME.getName().equals(myName) == true)
                     	groupWME=(GroupWME) (groupWME.contains(charWME))
						(groupWME.getConversationWME() != null) 
                     	(groupWME.getConversationWME().getState().equals("glaring"))
                     }
        specificity 2;
        double playerAngle;
        double groupOriginAngle;
        double halfAngle;
        mental_act { //log.info(myName + " STARTED GLARING AT.... " + target);

					 playerAngle = Staging.getXZAngleBetweenPoints(myPhysicalWME.getLocation(), targetPhysicalWME.getLocation()); 
					 groupOriginAngle = Staging.getXZAngleBetweenPoints(myPhysicalWME.getLocation(), groupWME.getOrigin());
					 
					 halfAngle = (playerAngle + groupOriginAngle)/2;
					 //log.info("AngleToPlayer: " + playerAngle);
					 //log.info("AngleToGroupCenter: " + groupOriginAngle);
					 //log.info("new halfAngle: " + halfAngle);
					 
				   }
				   
		subgoal headTrack(myName, target);		
		subgoal turnToAngle(myName, halfAngle, groupWME);
	}
	
	/*
	 * testbed_groupMaintenance_continueGlare
	 * Some filler action, either waiting or animating. TO DO: having a target may change facing of the character on its own
	 */
	sequential behavior testbed_groupMaintenance_continueGlare(String myName, String target, String variation) {
		precondition { charWME = (CharacterWME) (charWME.getName().equals(myName) == true)
                     	groupWME=(GroupWME) (groupWME.contains(charWME))
						(groupWME.getConversationWME() != null) 
                     	(groupWME.getConversationWME().getState().equals("glaring"))
					 }
		specificity 2;
		subgoal waitForRand(500, 1000);
	}
	
	/*
	 * testbed_groupMaintenance_finishGlare
	 * Return to looking/facing toward the middle of the group
	 */
	sequential behavior testbed_groupMaintenance_finishGlare(String myName, String target, String variation) {
		with (ignore_failure) subgoal testbed_groupMaintenance_cleanUpGroupAngle(myName);
	}
	
	/*
	 * testbed_groupMaintenance_cleanUpGroupAngle
	 * Return to looking/facing toward the middle of the group
	 */
	sequential behavior testbed_groupMaintenance_cleanUpGroupAngle(String myName) {
		precondition {  myPhysicalWME = (PhysicalAgentWME)
                     	(myPhysicalWME.getId().equals(myName))
                     	charWME = (CharacterWME) (charWME.getName().equals(myName) == true)
                     	groupWME=(GroupWME) (groupWME.contains(charWME))
                     	
						// don't do this if we're hostile
						(charWME.hasAttitude(eAttitudeType_hostile) == false)
					 }

		double groupOriginAngle;
		mental_act { 
					 groupOriginAngle = Staging.getXZAngleBetweenPoints(myPhysicalWME.getLocation(), groupWME.getOrigin());
				   }

		subgoal turnToAngle(myName, groupOriginAngle, groupWME);
	}

		
	
	

   /**
    * testbed_reactToAppeal()
    */      
   sequential behavior testbed_reactToAppeal(SiuWME siuWME, String responderName, String questionerName, int performancePriority) {
      precondition { observerPhysicalWME = (PhysicalAgentWME)
            (observerPhysicalWME.getId().equals(responderName))    
      }
      PerformanceWME performanceWME;
      mental_act {
         //log.info("## " +responderName+ " preparing for testbed_reactToAppeal from " +questionerName); 
         performanceWME = new PerformanceWME(siuWME); 
      }
      
      subgoal setupPerformanceWME(performanceWME, siuWME, responderName, performancePriority, "testbed_reactToAppeal");
      
      // Unlike most behaviors, let's not try to restart this response if it gets interrupted
      // this is because briefChat may interrupt it
      //with (persistent when_fails) 
      with (ignore_failure) 
      	subgoal testbed_reactToAppeal(responderName, questionerName, performanceWME);
      	
      subgoal performanceDoneDeleteWME(performanceWME);
      
      //subgoal headTrack(responderName, objectEyeLineLocation);
   }   
   
   sequential behavior testbed_reactToAppeal(String myName, String targetName, PerformanceWME performanceWME) {
   		int duration;
   		mental_act { duration = Staging.randRange(5000, 7000); }
   		
		subgoal performanceWait(performanceWME);
		subgoal testbed_reactToAppeal_perform_withTimeout(myName, targetName, duration, performanceWME);
   }
            
   parallel behavior testbed_reactToAppeal_perform_withTimeout(String myName, String targetName, int duration, PerformanceWME performanceWME) {
		number_needed_for_success 1;
		subgoal testbed_reactToAppeal_perform(myName, targetName, performanceWME);
      	subgoal waitFor(duration);
   }


	// ## LEADER ##   
	sequential behavior testbed_reactToAppeal_perform(String myName, String targetName, PerformanceWME performanceWME) {
		precondition {	myCharacterWME=(CharacterWME) 
						(myCharacterWME.getName().equals(myName) && 
							myCharacterWME.hasAttitude(eAttitudeType_leader))						
						 }
		context_condition {  (performanceWME.getPerformanceState() == cPerformanceStatePerforming) }
		specificity 2;
		String leaderName;
		mental_act { 
			log.info(myName+ " leader reactToAppeal");
			leaderName = myCharacterWME.getName(); 
		}
		
		with (ignore_failure) subgoal testbed_reactToAppeal_perform_leader_emotionalReaction(myName, targetName);
		//with (persistent) subgoal testbed_reactToAppeal_perform_leader(myName, targetName, leaderName);
	}

   // If leader, if haven't had emotional reaction yet, do so 
   sequential behavior testbed_reactToAppeal_perform_leader_emotionalReaction(String myName, String targetName) {
		precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
						!(EpisodicMemoryWME characterName==myName episodeName==animationGestureAngryQuick1)
						}						
		subgoal createEpisodicMemoryWME(myName, animationGestureAngryQuick1);
		subgoal headTrack(myName, targetName);
      	subgoal testbed_setFacialExpression(myName, animationFaceAngry2);
      	subgoal testbed_reactToAppeal_perform_leader_emotionalReaction_par(myName, targetName);
	}
	
	parallel behavior testbed_reactToAppeal_perform_leader_emotionalReaction_par(String myName, String targetName) {
		subgoal testbed_reactToAppeal_perform_leader_emotionalReaction_anim(myName, targetName);
		subgoal testbed_reactToAppeal_perform_leader_emotionalReaction_speak(myName, targetName);
	}
   
	sequential behavior testbed_reactToAppeal_perform_leader_emotionalReaction_anim(String myName, String targetName) {
		subgoal headTrack(myName, targetName);
      	subgoal performAnimation_portion(myName, targetName, animationGestureAngryQuick1, cAnimDefaultStartTime, cAnimDefaultEndTime);
		subgoal headTrack(myName, targetName);
      	subgoal performAnimation_portion(myName, targetName, animationGestureAngryQuick2, cAnimDefaultStartTime, cAnimDefaultEndTime);
		subgoal headTrack(myName, targetName);
      	subgoal performAnimation_portion(myName, targetName, animationGestureAngryQuick3, cAnimDefaultStartTime, cAnimDefaultEndTime);
		subgoal headTrack(myName, targetName);
      	subgoal performAnimation_portion(myName, targetName, animationIdle_Agitated2, cAnimDefaultStartTime, 3.0);
	}

	sequential behavior testbed_reactToAppeal_perform_leader_emotionalReaction_speak(String myName, String targetName) {
		subgoal speakDialogue(myName, dialogue_thai_HeyYouShouldLetHimIn, true, dialogue_gender_male, dialogue_tone_dominant);
		subgoal waitForRand(500, 1000);
		subgoal speakDialogue(myName, dialogue_thai_WhyDoesItMatterSoMuch, true, dialogue_gender_male, dialogue_tone_dominant);
		subgoal waitForRand(500, 1000);
		subgoal speakDialogue(myName, dialogue_thai_ItReallyPissesMeOff, true, dialogue_gender_male, dialogue_tone_dominant);
	}
	
	sequential behavior testbed_reactToAppeal_perform_leader(String myName, String targetName, String leaderName) {			 		
		// look at the questioner
      	subgoal testbed_reactToAppeal_perform_glancing(myName, targetName, eAttitudeParam_firstGlance);
   }


   // ## SYMPATHETIC ##
	sequential behavior testbed_reactToAppeal_perform(String myName, String targetName, PerformanceWME performanceWME) {
		precondition {	myCharacterWME=(CharacterWME) 
						(myCharacterWME.getName().equals(myName) && 
							myCharacterWME.hasAttitude(eAttitudeType_sympathetic))						
						 }
		context_condition {  (performanceWME.getPerformanceState() == cPerformanceStatePerforming) }
		specificity 2;
		String sympatheticName;
		mental_act { 
			log.info(myName+ " sympathetic reactToAppeal");
			sympatheticName = myCharacterWME.getName(); 
		}
		
		with (ignore_failure) subgoal testbed_reactToAppeal_perform_sympathetic_emotionalReaction(myName, targetName);
		//with (persistent) subgoal testbed_reactToAppeal_perform_sympathetic(myName, targetName, sympatheticName);
	}
	
	// if sympathetic and haven't had emotional reaction yet, do so
   sequential behavior testbed_reactToAppeal_perform_sympathetic_emotionalReaction(String myName, String targetName) {
		precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
						!(EpisodicMemoryWME characterName==myName episodeName==animationStartledDenial)
						}						
		subgoal createEpisodicMemoryWME(myName, animationStartledDenial);
		subgoal headTrack(myName, targetName);
      	subgoal testbed_setFacialExpression(myName, animationFaceShocked);
      	subgoal performAnimation_portion(myName, targetName, animationStartledDenial, cAnimDefaultStartTime, cAnimDefaultEndTime);
	}

	sequential behavior testbed_reactToAppeal_perform_sympathetic(String myName, String targetName, String sympatheticName) {			 		
		// look at the questioner
      	subgoal testbed_reactToAppeal_perform_glancing(myName, targetName, eAttitudeParam_firstGlance);
   }


	// ## DEFAULT ##   
	sequential behavior testbed_reactToAppeal_perform(String myName, String targetName, PerformanceWME performanceWME) {
		context_condition {  (performanceWME.getPerformanceState() == cPerformanceStatePerforming) }
		specificity 1;
		String anim;
		float duration;
		boolean bSecondReaction;
		String firstGlance;
		
		mental_act {
			firstGlance = Staging.percentChance(70) ? eAttitudeParam_firstGlance : ""; 
		}
		 		
		// react to it - possibly twice
      	subgoal testbed_reactToAppeal_perform_glancing(myName, targetName, eAttitudeParam_firstGlance);
      	subgoal testbed_reactToAppeal_perform_glancing(myName, targetName, firstGlance);
   }

	// First glance - look quizzical   
   sequential behavior testbed_reactToAppeal_perform_glancing(String myName, String targetName, String firstGlance) {
		precondition {	(firstGlance.equals(eAttitudeParam_firstGlance) == true)  
						myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName))
						} 
		String anim;
		float duration;
		String faceAnim;
		boolean bHostile;				
		
		subgoal headTrack(myName, targetName);

		mental_act {
			bHostile = myCharacterWME.hasAttitude(eAttitudeType_hostile);
			
			if (Staging.percentChance(25)) anim = animationListenHeadCockLeft1;
			else if (Staging.percentChance(25)) anim = animationListenHeadCockLeft2;
			else if (Staging.percentChance(25)) anim = animationListenHeadCockRight1;
			else anim = animationListenHeadCockRight2; 
			duration = (float)Staging.randRange(1.0, 3.0);
			
			if (bHostile) {
				faceAnim = animationFaceVeryAnnoyed;
				if (Staging.percentChance(10)) faceAnim = animationFaceStony;
				else if (Staging.percentChance(10)) faceAnim = animationFaceVeryAnnoyed;
				
			} else {
				if (Staging.percentChance(20)) faceAnim = animationFaceAnxious;
				else if (Staging.percentChance(20)) faceAnim = animationFaceAnxious2;
				else if (Staging.percentChance(10)) faceAnim = animationFaceNervous;
				else if (Staging.percentChance(10)) faceAnim = animationFaceNervous2;
				else if (Staging.percentChance(10)) faceAnim = animationFaceNervous3;
				else faceAnim = animationFaceUnsure;
			} 
		}
      
      	subgoal testbed_setFacialExpression(myName, faceAnim);
      	subgoal performAnimation_portion(myName, targetName, anim, cAnimDefaultStartTime, duration);
   }

   
   //Glance at another group member
   sequential behavior testbed_reactToAppeal_perform_glancing(String myName, String targetName, String firstGlance) {
   	precondition { (firstGlance.equals(eAttitudeParam_firstGlance) == false) 
      				myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
            		groupWME=(GroupWME) (groupWME.contains(myCharacterWME))
         }      
      
      CharactersWME othersInFormationCharactersWME;
      String glancePerson;
		float duration;

      // get list of other characters in the formation
      mental_act {
          othersInFormationCharactersWME = GroupUtil.cloneAndRemoveSelf(myName, groupWME.getFormationCharactersWME());
          glancePerson = othersInFormationCharactersWME.getRandom().getName();
          log.info("## " +myName+ " performing testbed_reactToAppeal_perform_glancing at " + glancePerson);
			duration = (float)Staging.randRange(1.0, 2.0); 
      }
      
		subgoal headTrack(myName, glancePerson);
		subgoal performWithAttitude(myName, eAttitudePerform_notice, duration, firstGlance);
   }

   
   // Glance at held object
   sequential behavior testbed_reactToAppeal_perform_glancing(String myName, String targetName, String firstGlance) {
   	precondition { (firstGlance.equals(eAttitudeParam_firstGlance) == false && Staging.percentChance(50)) }
		float duration;
		mental_act { 
			duration = (float)Staging.randRange(1.0, 2.0); 
		}
      
		subgoal headTrackOthersHeldObject(myName, targetName, 
											playerSkeletonNode_leftHand,	//fixme
											true,
											false);
		subgoal performWithAttitude(myName, eAttitudePerform_notice, duration, firstGlance);
   }
   
   
   /**
    * testbed_reactToQuestion()
    */      
   sequential behavior testbed_reactToQuestion(SiuWME siuWME, String responderName, String questionerName, int performancePriority) {
      precondition { observerPhysicalWME = (PhysicalAgentWME)
            (observerPhysicalWME.getId().equals(responderName))    
      }
      PerformanceWME performanceWME;
      mental_act {
         //log.info("## " +responderName+ " preparing for testbed_reactToQuestion from " +questionerName); 
         performanceWME = new PerformanceWME(siuWME); 
      }
      
      subgoal setupPerformanceWME(performanceWME, siuWME, responderName, performancePriority, "testbed_reactToQuestion");
      
      // Unlike most behaviors, let's not try to restart this response if it gets interrupted
      // this is because briefChat may interrupt it
      //with (persistent when_fails) 
      with (ignore_failure) 
      	subgoal testbed_reactToQuestion(responderName, questionerName, performanceWME);
      	
      subgoal performanceDoneDeleteWME(performanceWME);
      
      //subgoal headTrack(responderName, objectEyeLineLocation);
   }   
   
   sequential behavior testbed_reactToQuestion(String myName, String targetName, PerformanceWME performanceWME) {
   		int duration;
   		mental_act { duration = Staging.randRange(2000, 5000); }
   		
		subgoal performanceWait(performanceWME);
		subgoal testbed_reactToQuestion_perform_withTimeout(myName, targetName, duration, performanceWME);
   }
            
   parallel behavior testbed_reactToQuestion_perform_withTimeout(String myName, String targetName, int duration, PerformanceWME performanceWME) {
		number_needed_for_success 1;
		subgoal testbed_reactToQuestion_perform(myName, targetName, performanceWME);
      	subgoal waitFor(duration);
   }

	
	// ## NON-LEADER - look back and forth between questioner and leader ##   
	sequential behavior testbed_reactToQuestion_perform(String myName, String targetName, PerformanceWME performanceWME) {
		precondition {	myCharacterWME=(CharacterWME) 
						(myCharacterWME.getName().equals(myName) && myCharacterWME.hasAttitude(eAttitudeType_leader) == false)						
	            		groupWME=(GroupWME) (groupWME.contains(myCharacterWME))
						leaderCharacterWME=(CharacterWME) 
						(leaderCharacterWME.hasAttitude(eAttitudeType_leader) &&
							groupWME.formationContains(leaderCharacterWME))						
						 }
		context_condition {  (performanceWME.getPerformanceState() == cPerformanceStatePerforming) }
		specificity 2;
		String leaderName;
		mental_act { 
			log.info(myName+ " non-leader reactToQuestion");
			leaderName = leaderCharacterWME.getName(); 
		}
				
		with (persistent) subgoal testbed_reactToQuestion_perform_nonLeader(myName, targetName, leaderName);
	}


	sequential behavior testbed_reactToQuestion_perform_nonLeader(String myName, String targetName, String leaderName) {
			 		
		// look at the questioner
      	subgoal testbed_reactToQuestion_perform_glancing(myName, targetName, eAttitudeParam_firstGlance);
      	      
        // look at leader
      	subgoal testbed_reactToQuestion_perform_glancing(myName, leaderName, eAttitudeParam_firstGlance);
   }


	// ## DEFAULT ##   
	sequential behavior testbed_reactToQuestion_perform(String myName, String targetName, PerformanceWME performanceWME) {
		context_condition {  (performanceWME.getPerformanceState() == cPerformanceStatePerforming) }
		specificity 1;
		String anim;
		float duration;
		String firstGlance;
		
		mental_act { firstGlance = Staging.percentChance(70) ? eAttitudeParam_firstGlance : ""; }
		 		
		// react to it - possibly twice
      	subgoal testbed_reactToQuestion_perform_glancing(myName, targetName, eAttitudeParam_firstGlance);
      	subgoal testbed_reactToQuestion_perform_glancing(myName, targetName, firstGlance);
      
        // vary the reaction and glancing
      	with (persistent) subgoal testbed_reactToQuestion_perform_glancing(myName, targetName, "");
   }

	// First glance - look quizzical   
   sequential behavior testbed_reactToQuestion_perform_glancing(String myName, String targetName, String firstGlance) {
		precondition {	(firstGlance.equals(eAttitudeParam_firstGlance) == true)  
						myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName))
						} 
		String anim;
		float duration;
		String faceAnim;
		boolean bHostile;				
		
		subgoal headTrack(myName, targetName);

		mental_act {
			bHostile = myCharacterWME.hasAttitude(eAttitudeType_hostile);
			
			if (Staging.percentChance(25)) anim = animationListenHeadCockLeft1;
			else if (Staging.percentChance(25)) anim = animationListenHeadCockLeft2;
			else if (Staging.percentChance(25)) anim = animationListenHeadCockRight1;
			else anim = animationListenHeadCockRight2; 
			duration = (float)Staging.randRange(1.0, 3.0);
			
			if (bHostile) {
				faceAnim = animationFaceVeryAnnoyed;
				if (Staging.percentChance(10)) faceAnim = animationFaceStony;
				else if (Staging.percentChance(10)) faceAnim = animationFaceVeryAnnoyed;
				
			} else {
				if (Staging.percentChance(20)) faceAnim = animationFaceAnxious;
				else if (Staging.percentChance(20)) faceAnim = animationFaceAnxious2;
				else if (Staging.percentChance(10)) faceAnim = animationFaceNervous;
				else if (Staging.percentChance(10)) faceAnim = animationFaceNervous2;
				else if (Staging.percentChance(10)) faceAnim = animationFaceNervous3;
				else faceAnim = animationFaceUnsure;
			} 
		}
      
      	subgoal testbed_setFacialExpression(myName, faceAnim);
      	subgoal performAnimation_portion(myName, targetName, anim, cAnimDefaultStartTime, duration);
   }

   
   //Glance at another group member
   sequential behavior testbed_reactToQuestion_perform_glancing(String myName, String targetName, String firstGlance) {
   	precondition { (firstGlance.equals(eAttitudeParam_firstGlance) == false) 
      				myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
            		groupWME=(GroupWME) (groupWME.contains(myCharacterWME))
         }      
      
      CharactersWME othersInFormationCharactersWME;
      String glancePerson;
		float duration;

      // get list of other characters in the formation
      mental_act {
          othersInFormationCharactersWME = GroupUtil.cloneAndRemoveSelf(myName, groupWME.getFormationCharactersWME());
          glancePerson = othersInFormationCharactersWME.getRandom().getName();
          log.info("## " +myName+ " performing testbed_reactToQuestion_perform_glancing at " + glancePerson);
			duration = (float)Staging.randRange(1.0, 2.0); 
      }
      
		subgoal headTrack(myName, glancePerson);
		subgoal performWithAttitude(myName, eAttitudePerform_notice, duration, firstGlance);
   }

   
   // Glance at held object
   sequential behavior testbed_reactToQuestion_perform_glancing(String myName, String targetName, String firstGlance) {
   	precondition { (firstGlance.equals(eAttitudeParam_firstGlance) == false && Staging.percentChance(50)) }
		float duration;
		mental_act { 
			duration = (float)Staging.randRange(1.0, 2.0); 
		}
		subgoal headTrackOthersHeldObject(myName, targetName, 
											playerSkeletonNode_leftHand,	//fixme
											true,
											false);
		subgoal performWithAttitude(myName, eAttitudePerform_notice, duration, firstGlance);
   }
   
   
   
   /**
    * testbed_requestObject()
    */      
   sequential behavior testbed_requestObject(SiuWME siuWME, String myName, String targetName, int performancePriority) {
      precondition { myPhysicalWME = (PhysicalAgentWME)
            (myPhysicalWME.getId().equals(myName))    
      }
      PerformanceWME performanceWME;
      mental_act {
         log.info("## " +myName+ " preparing for testbed_requestObject " +targetName); 
         performanceWME = new PerformanceWME(siuWME); 
      }

      subgoal setupPerformanceWME(performanceWME, siuWME, myName, performancePriority, "testbed_requestObject");
      with (persistent when_fails) subgoal testbed_requestObject(myName, targetName, performanceWME);
      subgoal performanceDoneDeleteWME(performanceWME);
   }
   
   sequential behavior testbed_requestObject(String myName, String targetName, PerformanceWME performanceWME) {
      subgoal performanceWait(performanceWME);
      subgoal testbed_requestObject_perform(myName, targetName, performanceWME);
   }
   
   sequential behavior testbed_requestObject_perform(String myName, String targetName, PerformanceWME performanceWME) {
      context_condition {  (performanceWME.getPerformanceState() == cPerformanceStatePerforming) }
      precondition { targetPhysicalWME = (PhysicalAgentWME)
                        (targetPhysicalWME.getId().equals(targetName))
      					} 
  
        ReturnValueWME retValWME;
        String audio;
        String tone;
		Location targetPt;
		mental_act { 
			targetPt = targetPhysicalWME.getLocation();
		}
		
		mental_act { retValWME = new ReturnValueWME(); }
        subgoal testbed_getRandomDialog(retValWME, true);
		mental_act {
        	audio = retValWME.getString();
        	tone = retValWME.getString2();
		}
       
      subgoal headTrack(myName, targetName);
      
	 	spawngoal speakDialogue(myName, audio, true, dialogue_gender_male, tone);

		// turn and reach for the object
		subgoal turnToFacingPoint(myName, targetPt);
      	subgoal performAnimation(myName, targetName, animationOfferObject);   
        
        // if the requestee's most recent gesture is offering the object,
        // then create a duplicate signal now automatically, for the give itself to be triggered by
        subgoal cif_regenerateMostRecentSignalIf(socialInterpretationExtendHand, targetName, myName, 10000); 
            
        // wait for the requestee to give it
      	subgoal testbed_requestObject_perform_par(myName, targetName);
   }
   
   parallel behavior testbed_requestObject_perform_par(String myName, String targetName) {
   		number_needed_for_success 1;
   
   		// wait for requestee to give the object
		with (persistent) subgoal testbed_requestObject_performLoop(myName, targetName);

		// eventually timeout
		subgoal waitForRand(18000, 22000);
	}
	   
   sequential behavior testbed_requestObject_performLoop(String myName, String targetName) {
      subgoal headTrack(myName, targetName);

		// buggy -- can return immediately      
      subgoal performAnimation(myName, targetName, animationOfferObjectIdle);
   }
   
   
   
	/**
	 * testbed_noticingCharacters()
	 * NPC orients towards the average angle to all the other characters in the scene,
	 * and quickly glances among them
	 */	 	
	sequential behavior testbed_noticingCharacters(SiuWME siuWME, String myName) {
		PerformanceWME performanceWME;
		mental_act {
			//log.info("## " +myName+ " preparing for testbed_noticingCharacters");
			performanceWME = new PerformanceWME(siuWME); 
		}
		subgoal setupPerformanceWME(performanceWME, siuWME, myName, cPerformancePriorityLow, "testbed_noticingCharacters");
		with (persistent when_fails) subgoal testbed_noticingCharacters(myName, performanceWME);
		subgoal performanceDoneDeleteWME(performanceWME);
	}
	
	sequential behavior testbed_noticingCharacters(String myName, PerformanceWME performanceWME) {
		subgoal performanceWait(performanceWME);
		subgoal testbed_noticingCharacters_perform(myName, performanceWME);
	}
				
	// NB this is currently disabled; see FIXME below
	sequential behavior testbed_noticingCharacters_perform(String myName, PerformanceWME performanceWME) {
		precondition {	myPhysicalWME = (PhysicalAgentWME)
                     	(myPhysicalWME.getId().equals(myName))
						playerPhysicalWME = (PhysicalAgentWME)
                     	(playerPhysicalWME.getId().equals(playerName))
                     	charWME = (CharacterWME) (charWME.getName().equals(myName) == true)
                     	groupWME=(GroupWME) (groupWME.contains(charWME))
                     }
		context_condition {	(performanceWME.getPerformanceState() == cPerformanceStatePerforming) }
                     
		CharactersWME otherCharactersWME;
		Iterator iterator;
		double angle;
		
		// get list of other characters in the scene
		mental_act { 
			log.info("## " +myName+ " performing testbed_noticingCharacters"); 
			otherCharactersWME = new CharactersWME(); 
		}
		subgoal getOtherCharactersWME(myName, otherCharactersWME);
		
		// face toward them
		mental_act { 
			// FIXME use PhysicalAgentWME here, if we revive this behavior
//			angle = GroupUtil.getAverageAngleToCharacters(otherCharactersWME.getMyTempLocation(), 
//																					otherCharactersWME.getCharacterWMEs()); 
			angle = 0;
			//log.info(myName + " average angle to others is " +angle);
		}
		/*
		// face the player
		mental_act { 
			angle = Staging.getXZAngleBetweenPoints(myPhysicalWME.getLocation(), playerPhysicalWME.getLocation());
			//log.info(myName + " is " +angle+ " degrees between player " +playerPhysicalWME.getLocation()+ " and self " +myPhysicalWME.getLocation());
		}
		*/

		subgoal turnToAngle(myName, angle, groupWME);
		
		// loop through them, looking at each of them briefly
		// Loop idiom
		mental_act { iterator = otherCharactersWME.iterator(); }
		with (ignore_failure) subgoal testbed_noticingCharacters_main(iterator, myName);
	}
	
	// loop idiom
	sequential behavior testbed_noticingCharacters_main(Iterator iterator, String myName) {
		with (persistent when_succeeds) subgoal testbed_noticingCharacters_loop(iterator, myName);
	}
				
	sequential behavior testbed_noticingCharacters_loop(Iterator iterator, String myName) {
		precondition { (iterator.hasNext()) }						
		CharacterWME otherCharacterWME;
		String otherCharacterName;
		mental_act { 
			otherCharacterWME = iterator.next();
			otherCharacterName = otherCharacterWME.getName(); 
		}
		subgoal headTrack(myName, otherCharacterName);
		subgoal waitForRand(500, 1000);
	}


	// ------------------------------------------------------------------------	
	// ------------------------------------------------------------------------	

		
	/**
	 * testbed_approachingCharacters()
	 */	 	
	sequential behavior testbed_approachingCharacters(SiuWME siuWME, String myName) {
		CharactersWME friendsCharactersWME;
		ReturnValueWME retValWME;
		PerformanceWME performanceWME;
		GroupWME groupWME;
		
		mental_act {
			//log.info("## " +myName+ " preparing for testbed_approachingCharacters");
			// get list of friends characters in the scene
			friendsCharactersWME = new CharactersWME(); 
		} 
		
		//subgoal getOtherCharactersWME(myName, otherCharactersWME);
		subgoal getFriendsCharactersWME(myName, friendsCharactersWME);
		
		// find a group friends are in, or create one 
		mental_act { retValWME = new ReturnValueWME(); }
		subgoal testbed_approachingCharacters_findAndJoinGroup(retValWME, friendsCharactersWME, myName);
		mental_act { groupWME = retValWME.getGroupWME(); }

		mental_act { performanceWME = new PerformanceWME(siuWME); } 
		subgoal setupPerformanceWME(performanceWME, siuWME, myName, cPerformancePriorityLow, "testbed_approachingCharacters");
//		with (persistent when_fails) subgoal testbed_approachingCharacters(myName, performanceWME);
		subgoal performanceDoneDeleteWME(performanceWME);
	}
	
	sequential behavior testbed_approachingCharacters(String myName, PerformanceWME performanceWME) {
		subgoal performanceWait(performanceWME);
		subgoal testbed_approachingCharacters_perform(myName, performanceWME);
	}
	
	sequential behavior testbed_approachingCharacters_perform(String myName, PerformanceWME performanceWME) {
		specificity 2;
		precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
                     	groupWME=(GroupWME) (groupWME.contains(myCharacterWME))
						myPhysicalWME=(PhysicalAgentWME) (myPhysicalWME.getId().equals(myName))
                     	(Staging.getXZDistanceBetweenPoints(myPhysicalWME.getLocation(), 
                     											groupWME.getOrigin()) 
                     										< cApproachGroupDistance)
                     }
		mental_act { log.info("## " +myName+ " already close enough in testbed_approachingCharacters"); }                      
	}
	
	sequential behavior testbed_approachingCharacters_perform(String myName, PerformanceWME performanceWME) {
		specificity 1;
		context_condition {	(performanceWME.getPerformanceState() == cPerformanceStatePerforming) }
		precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
                     	groupWME=(GroupWME) (groupWME.contains(myCharacterWME))
						myPhysicalWME = (PhysicalAgentWME) (myPhysicalWME.getId().equals(myName))
                     }
		Location walkToPoint;
		Location lookToPoint;
				
		// walk to the group origin point
		mental_act { 
			double angle;
			log.info("## " +myName+ " performing testbed_approachingCharacters"); 
			angle = Staging.getXZAngleBetweenPoints(myPhysicalWME.getLocation(), groupWME.getOrigin());
			walkToPoint = Staging.pointAtAngleAndDist(cApproachGroupDistance, angle, groupWME.getOrigin());			
			lookToPoint = new Location(groupWME.getOrigin().getX(), cCharacterHeight, groupWME.getOrigin().getZ());
		}
		
		subgoal headTrackOff(myName);
		subgoal walkToPoint(myName, walkToPoint); 
	}

	
	// try to find and join a group any others are in
	atomic sequential behavior testbed_approachingCharacters_findAndJoinGroup(ReturnValueWME retValWME, CharactersWME otherCharactersWME, String myName) {
		String otherCharacterName;
		
		// Anyone in my other characters WME, are they in a group?
		subgoal findAGroupAnyOthersAreIn(retValWME, otherCharactersWME);

		// if one doesn't exist, prepare to create a group with self and one of the others
		mental_act {
			int numOtherCharacters;
			int which;
			numOtherCharacters = otherCharactersWME.getCharacterWMEs().size();
			which = Staging.randRange(0, numOtherCharacters - 1);
			
			otherCharacterName = "";
			if (retValWME.getGroupWME() == null) { // Will be null the first time through				
				otherCharacterName = otherCharactersWME.get(which).getName();
			}
		}
		
		subgoal testbed_approaching_findAndJoinGroup_more(retValWME, otherCharactersWME, myName, otherCharacterName);
	}
		
		
	// if one doesn't exist, create a group with self and one of the others
	// It wont stop running until it's done! Avoids other groups being made in the middle of it
	atomic sequential behavior testbed_approaching_findAndJoinGroup_more(ReturnValueWME retValWME, CharactersWME otherCharactersWME, String myName, String otherCharacterName) {
		precondition { 	(retValWME.getGroupWME() == null)
						myPhysicalWME = (PhysicalAgentWME)
                     	(myPhysicalWME.getId().equals(myName))
						otherPhysicalWME = (PhysicalAgentWME)
                     	(otherPhysicalWME.getId().equals(otherCharacterName))
						playerPhysicalWME = (PhysicalAgentWME)
                     	(playerPhysicalWME.getId().equals(playerName))
                     	myCharacterWME=(CharacterWME) 
                     	(myCharacterWME.getName().equals(myName)) 
                     	otherCharacterWME=(CharacterWME) 
                     	(otherCharacterWME.getName().equals(otherCharacterName)) 
                     	}
		specificity 2;
		mental_act {
			GroupWME groupWME;
			Location origin;
			
			log.info(myName+ " creating an approaching group with self and " +otherCharacterWME.getName());
			
			// Find the midpoint between the two people that will start this group
			//origin = Staging.getMidwayBetweenPoints(myPhysicalWME.getLocation(), otherPhysicalWME.getLocation());			
			/* relative to player			
			origin = new Location(
					playerPhysicalWME.getLocation().getX() + Staging.randRange(-10.0f, 10.0f),
					0.0,
					playerPhysicalWME.getLocation().getZ() + Staging.randRange(4.0f, 18.0f)
					);
			*/
			// use my location as origin. (Characters are positioned in Unity)
			origin = myPhysicalWME.getLocation();

			
			//log.info("origin = " +origin);
			groupWME = new GroupWME(origin);
			groupWME.addApproachingCharacter(myCharacterWME);
			BehavingEntity.getBehavingEntity().addWME(groupWME);
			retValWME.setGroupWME(groupWME); 
		}		
	}


	atomic sequential behavior testbed_approaching_findAndJoinGroup_more(ReturnValueWME retValWME, CharactersWME otherCharactersWME, String myName, String otherCharacterName) {
		precondition { myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) }
		specificity 1;	 							
		mental_act {
			
			// if already part of the group, do nothing 
			if (retValWME.getGroupWME().contains(myCharacterWME)) {
				log.info(myName+ " already approaching/in an existing group");
	 							
			// otherwise become an approacher of the found group 
			} else {
				log.info(myName+ " now approaching/joining an existing group");
				retValWME.getGroupWME().addApproachingCharacter(myCharacterWME);
			} 			
		}		
	}
	
	
	/**
	 * testbed_personalSpace()
	 */	 	
	sequential behavior testbed_personalSpace(SiuWME siuWME, String myName, String targetName, int performancePriority) {
		PerformanceWME performanceWME;
		mental_act {
			//log.info("## " +myName+ " preparing for testbed_personalSpace " +targetName+ " " +gesture); 
			performanceWME = new PerformanceWME(siuWME); 
		}
		subgoal setupPerformanceWME(performanceWME, siuWME, myName, performancePriority, "testbed_personalSpace");
		with (ignore_failure) //persistent when_fails) 
			subgoal testbed_personalSpace(myName, targetName, performanceWME);
		subgoal performanceDoneDeleteWME(performanceWME);
	}
	
	sequential behavior testbed_personalSpace(String myName, String targetName, PerformanceWME performanceWME) {
		subgoal performanceWait(performanceWME);
		subgoal testbed_personalSpace_perform(myName, targetName, performanceWME);
	}
				
	sequential behavior testbed_personalSpace_perform(String myName, String targetName, PerformanceWME performanceWME) {
		context_condition {	(performanceWME.getPerformanceState() == cPerformanceStatePerforming) }
		precondition {	characterPhysicalWME = (PhysicalAgentWME)
                     	(characterPhysicalWME.getId().equals(targetName))
						}
		Location characterPt;
		mental_act { 
			log.info("## " +myName+ " performing testbed_personalSpace"); 
			characterPt = characterPhysicalWME.getLocation();
		}				
		subgoal turnToFacingPoint(myName, characterPt);
		subgoal headTrack(myName, targetName);
      	subgoal testbed_setFacialExpression(myName, animationFaceAngry2);
      	spawngoal testbed_personalSpace_perform_speak(myName);
		subgoal performAnimation_portion(myName, myName, animationAssertiveStop, cAnimDefaultStartTime, cAnimDefaultEndTime);								                     
      	subgoal testbed_setFacialExpression(myName, animationFaceAngry);
		subgoal performAnimation_portion(myName, myName, animationAssertiveStopIdle, cAnimDefaultStartTime, cAnimDefaultEndTime);								                     
      	subgoal testbed_setFacialExpression(myName, animationFaceAngry2);
		subgoal performAnimation_portion(myName, myName, animationAssertiveStopIdle, cAnimDefaultStartTime, cAnimDefaultEndTime);								                     
      	subgoal testbed_setFacialExpression(myName, animationFaceVeryAnnoyed);
		subgoal performAnimation_portion(myName, myName, animationAssertiveStopIdle, cAnimDefaultStartTime, cAnimDefaultEndTime);								                     
	}

	sequential behavior testbed_personalSpace_perform_speak(String myName) {
		String audio;
		mental_act { audio = Staging.percentChance(50) ? dialogue_thai_ItReallyPissesMeOff : dialogue_thai_WhyCantYouLetHimIn; } 
		subgoal speakDialogue(myName, audio, true, dialogue_gender_male, dialogue_tone_dominant);
	}

	
	/////////////////////////
	//testbed_reactToPersonalSpaceEncroachment
	//Have an NPC express discomfort if another character gets too physically close to them
	//(i.e. invades their personal space)
	////////////////////////
	
	sequential behavior testbed_reactToPersonalSpaceEncroachment(SiuWME siuWME, String myName, String targetName){
	   PerformanceWME performanceWME;
      mental_act{
         //log.info("## " +myName+ " preparing for testbed_reactToPersonalSpaceEncroachment " +targetName); 
           performanceWME = new PerformanceWME(siuWME); 
        }
      subgoal setupPerformanceWME(performanceWME, siuWME, myName, cPerformancePriorityHigh, "testbed_reactToPersonalSpaceEncroachment");
      with (persistent when_fails) subgoal testbed_reactToPersonalSpaceEncroachment(myName, targetName, performanceWME);
      subgoal performanceDoneDeleteWME(performanceWME);
	}
	
	sequential behavior testbed_reactToPersonalSpaceEncroachment(String myName, String targetName, PerformanceWME performanceWME) {
	   mental_act{
	      //log.info("## " +myName+ " in the middle of testbed_reactToPersonalSpaceEncroachment " +targetName); 
	     }
	   subgoal performanceWait(performanceWME);
	   subgoal testbed_reactToPersonalSpaceEncroachment_perform(myName, targetName, performanceWME);
	}
	
	sequential behavior testbed_reactToPersonalSpaceEncroachment_perform(String myName, String targetName, PerformanceWME performanceWME) {
	   context_condition {  (performanceWME.getPerformanceState() == cPerformanceStatePerforming) }

	   mental_act { 
	      //log.info("## " +myName+ " performing testbed_reactToPersonalSpaceEncroachment_perform "); 
	   }           
	   
	   subgoal headTrack(myName, targetName);
	   
	   subgoal testbed_reactToPersonalSpaceEncroachment_perform_stepBack(myName, targetName);
	   subgoal testbed_reactToPersonalSpaceEncroachment_perform_idle(myName, targetName);
	  
	}
	
	parallel behavior testbed_reactToPersonalSpaceEncroachment_perform_stepBack(String myName, String targetName){
	   subgoal performAnimation(myName, targetName, animationFaceShocked);
	   subgoal performAnimation(myName, targetName, animationPersonalSpaceStepBack);  
	}
	
	parallel behavior testbed_reactToPersonalSpaceEncroachment_perform_idle(String myName, String targetName){
	   subgoal performAnimation(myName, targetName, animationFaceShocked);
	   subgoal performAnimation(myName, targetName, animationPersonalSpaceIdle); 
	}
	
	
   /**
    * testbed_studyOthersObject()
    */      
   sequential behavior testbed_studyOthersObject(SiuWME siuWME, String observerName, String objectHolderName, int performancePriority) {
      precondition { observerPhysicalWME = (PhysicalAgentWME)
            		(observerPhysicalWME.getId().equals(observerName))    
      }
      PerformanceWME performanceWME;
      mental_act {
         //log.info("## " +observerName+ " preparing for testbed_studyOthersObject " +objectHolderName); 
         performanceWME = new PerformanceWME(siuWME); 
      }
            
      subgoal setupPerformanceWME(performanceWME, siuWME, observerName, performancePriority, "testbed_studyOthersObject");
      with (persistent when_fails) subgoal testbed_studyOthersObject(observerName, objectHolderName, performanceWME);
      subgoal performanceDoneDeleteWME(performanceWME);      
   }   

   
   sequential behavior testbed_studyOthersObject(String myName, String targetName, PerformanceWME performanceWME) {
      subgoal performanceWait(performanceWME);
      subgoal testbed_studyOthersObject_perform(myName, targetName, performanceWME);
   }
            
   sequential behavior testbed_studyOthersObject_perform(String myName, String targetName, PerformanceWME performanceWME) {
      context_condition {  (performanceWME.getPerformanceState() == cPerformanceStatePerforming) }
      precondition { 	targetPhysicalWME = (PhysicalAgentWME)
                        (targetPhysicalWME.getId().equals(targetName))
						myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 						
	            		groupWME=(GroupWME) (groupWME.contains(myCharacterWME))
				      } 
		String anim;
		float duration;
		Location targetPt;
		int chanceOfGlancingAtGroupMember;
		 
		// begin head tracking the held object      
        subgoal testbed_studyOthersObject_headTrackOthersHeldObject(myName, targetName, performanceWME);
                
        // wait a very short bit
		mental_act {
			if (Staging.percentChance(50)) duration = 0;
			else duration = (float)Staging.randRange(1.0, 3.0);
			anim = animationIdle_Conversation;
			if (Staging.percentChance(20)) anim = animationIdle_Agitated1;
			else if (Staging.percentChance(20)) anim = animationIdle_Impatient;
			else if (Staging.percentChance(20)) anim = animationIdle_SpacingOut1;
			else if (Staging.percentChance(20)) anim = animationIdle_SpacingOut2;
			
			targetPt = targetPhysicalWME.getLocation();
			
			chanceOfGlancingAtGroupMember = 30;
			if (myCharacterWME.hasAttitude(eAttitudeType_leader) == false &&
					groupWME.getLeaderCharacter() != null) {
				log.info(myName+ " non-leader in studyOthersObject");
				chanceOfGlancingAtGroupMember = 100; 
			}
		}
		
		subgoal waitForRand(0, 500);
		subgoal turnToFacingPoint(myName, targetPt);
		
		subgoal performAnimation_portion(myName, targetName, anim, cAnimDefaultStartTime, duration);
		
		// react to it
      	subgoal testbed_studyOthersObject_perform_glancing(myName, targetName, eAttitudeParam_firstGlance, chanceOfGlancingAtGroupMember, performanceWME);
      
        // vary the reaction and glancing
      	with (persistent) subgoal testbed_studyOthersObject_perform_glancing(myName, targetName, "", chanceOfGlancingAtGroupMember, performanceWME);
   }
	

   // If sympathetic, and if first glance, and haven't had emotional reaction, 
   // then glance at the object followed by an emotional reaction
   sequential behavior testbed_studyOthersObject_perform_glancing(String myName, String targetName, 
   																	String firstGlance, int chanceOfGlancingAtGroupMember,
   																	PerformanceWME performanceWME) {
		precondition {	(firstGlance.equals(eAttitudeParam_firstGlance) == true)
						myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
						(myCharacterWME.hasAttitude(eAttitudeType_sympathetic) == true)		 
						!(EpisodicMemoryWME characterName==myName episodeName==animationArmsCrossedEmotional2)
						}						
		specificity 2;								
		String facialExpression;
		mental_act { facialExpression = Staging.percentChance(50) ? animationFaceAnxious : animationFaceAnxious2; }

		subgoal createEpisodicMemoryWME(myName, animationArmsCrossedEmotional2);
		
		// do glance
        subgoal testbed_studyOthersObject_headTrackOthersHeldObject(myName, targetName, performanceWME);
      	subgoal testbed_setFacialExpression(myName, facialExpression);
      	subgoal performAnimation_portion(myName, targetName, animationArmsCrossedEmotional1, cAnimDefaultStartTime, 2.0);
		
		// set future face expression tendency to anxious 
		mental_act { myCharacterWME.setFacialExpressionTendency(facialExpression); }
		
		// do emotional reaction
      	subgoal testbed_setFacialExpression(myName, animationFaceShocked);
      	subgoal performAnimation_portion(myName, targetName, animationArmsCrossedEmotional2, cAnimDefaultStartTime, cAnimDefaultEndTime);
	}

   // Option 1: Glance at the object (first glance or later glance)
   sequential behavior testbed_studyOthersObject_perform_glancing(String myName, String targetName, 
   																	String firstGlance, int chanceOfGlancingAtGroupMember,
   																	PerformanceWME performanceWME) {
		specificity 1;								
		subgoal testbed_studyOthersObject_perform_glanceAtObject(myName, targetName, firstGlance, performanceWME);
	}

   
   // Option 2: Glance at the person holding the ID in the eyes (using one of several potential 'listening' animations.)
   sequential behavior testbed_studyOthersObject_perform_glancing(String myName, String targetName, 
   																	String firstGlance, int chanceOfGlancingAtGroupMember,
   																	PerformanceWME performanceWME) {
		precondition { (firstGlance.equals(eAttitudeParam_firstGlance) == false && 
						Staging.percentChance(100-chanceOfGlancingAtGroupMember)) }
		specificity 1;		
		subgoal headTrack(myName, targetName);      	
		subgoal performWithAttitude(myName, eAttitudePerform_notice, cAttitudeDefaultDuration);
      
   }
   
   // Option 3: Glance at another group member
   sequential behavior testbed_studyOthersObject_perform_glancing(String myName, String targetName, 
   																	String firstGlance, int chanceOfGlancingAtGroupMember) {
		precondition { (firstGlance.equals(eAttitudeParam_firstGlance) == false && 
						Staging.percentChance(chanceOfGlancingAtGroupMember)) 
      				myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
            		groupWME=(GroupWME) (groupWME.contains(myCharacterWME))
		}      
		specificity 1;								
      
      CharactersWME othersInFormationCharactersWME;
      String glancePerson;
		float duration;
		String leader;

      // get list of other characters in the formation
      mental_act {
			//log.info("^^^^^^^^^^^^ " +myName+ " glancing at leader");      
      		leader = "";
      		if (groupWME.getLeaderCharacter() != null) 
      			leader = groupWME.getLeaderCharacter().getName();
      		  
      		if (leader.equals("") == false && leader.equals(myName) == false) {
      			glancePerson = groupWME.getLeaderCharacter().getName();
      		} else {
	          othersInFormationCharactersWME = GroupUtil.cloneAndRemoveSelf(myName, groupWME.getFormationCharactersWME());
    	      glancePerson = othersInFormationCharactersWME.getRandom().getName();
    	    }
          log.info("## " +myName+ " performing testbed_studyOthersObject_perform_glancing at " + glancePerson);
          
      }
      
		subgoal headTrack(myName, glancePerson);
      
		mental_act { 
			duration = cAttitudeDefaultDuration;			
			if (glancePerson.equals(leader)) duration = (float)Staging.randRange(0.5, 1.0);
			else if (myCharacterWME.hasAttitude(eAttitudeType_hostile)) { 
				duration = (float)Staging.randRange(1.0, 2.0);
			}
		}

		subgoal performWithAttitude(myName, eAttitudePerform_notice, duration);
   }
         
   sequential behavior testbed_studyOthersObject_perform_glanceAtObject(String myName, String targetName, String firstGlance, PerformanceWME performanceWME) {
		precondition {	myCharacterWME=(CharacterWME) (myCharacterWME.getName().equals(myName)) 
	            		groupWME=(GroupWME) (groupWME.contains(myCharacterWME))
						}						
		float duration;
		String leader;		
		
        subgoal testbed_studyOthersObject_headTrackOthersHeldObject(myName, targetName, performanceWME);
                  
		mental_act { 
			//log.info("^^^^^^^^^^^^ " +myName+ " glancing at object");      
			duration = cAttitudeDefaultDuration;

			// if we are hostile, and not the leader, take less time to glance
      		leader = "";
      		if (groupWME.getLeaderCharacter() != null) { 
      			leader = groupWME.getLeaderCharacter().getName();
      		}			
			if (myCharacterWME.hasAttitude(eAttitudeType_hostile)) { 
				if (leader.equals("") == false && myName.equals(leader) == false) 
					duration = (float)Staging.randRange(1.0, 2.0);
				else duration = (float)Staging.randRange(2.0, 3.0);
			}			
		}
		
		subgoal performWithAttitude(myName, eAttitudePerform_notice, duration);
   }
   

	// fixme: Only look at the player hand node if we're in the first 5 seconds of this testbed behavior 
	sequential behavior testbed_studyOthersObject_headTrackOthersHeldObject(String myName, String targetName, PerformanceWME performanceWME) {
		boolean useNode;		
		
		mental_act {
			useNode = targetName.equals(playerName) && performanceWME.isMoreRecentThan(5000);
		}
		
		subgoal headTrackOthersHeldObject(myName, targetName, playerSkeletonNode_leftHand, true, useNode);
	}
   

   
 
   /**
    * testbed_studyOwnObject()
    * Look at an object in your own hand
    */      
   sequential behavior testbed_studyOwnObject(SiuWME siuWME, String myName, String targetName, int performancePriority){
      precondition { myPhysicalWME = (PhysicalAgentWME)
            (myPhysicalWME.getId().equals(myName))    
      }
      PerformanceWME performanceWME;
      mental_act {
         //log.info("## " +myName+ " preparing for testbed_StudyOwnObject " +targetName+ " " +gesture); 
         performanceWME = new PerformanceWME(siuWME); 
      }

      subgoal setupPerformanceWME(performanceWME, siuWME, myName, performancePriority, "testbed_studyOwnObject");
      with (persistent when_fails) subgoal testbed_studyOwnObject(myName, targetName, performanceWME);
      subgoal performanceDoneDeleteWME(performanceWME);
   }
   
   sequential behavior testbed_studyOwnObject(String myName, String targetName, PerformanceWME performanceWME) {
      subgoal performanceWait(performanceWME);
      subgoal testbed_studyOwnObject_perform(myName, targetName, performanceWME);
   }
   
   sequential behavior testbed_studyOwnObject_perform(String myName, String targetName, PerformanceWME performanceWME) {
      context_condition {  (performanceWME.getPerformanceState() == cPerformanceStatePerforming) }
      precondition { characterPhysicalWME = (PhysicalAgentWME)
                        (characterPhysicalWME.getId().equals(myName))
      } 
  
      //FIRST LOOK AT HELD OBJECT
      //I believe the animation for this is pending, so we'll use a stub animation for now.
      //subgoal headTrackOwnHeldObject(myName, true);
      // use this for now
      subgoal headTrackOff(myName);
      
      subgoal performAnimation(myName, targetName, animationLookAtHeldObject);   
            
      subgoal testbed_studyOwnObject_perform_par(myName, targetName);
   }
   
   parallel behavior testbed_studyOwnObject_perform_par(String myName, String targetName){
   		number_needed_for_success 1;
   
		//go back and forth between glancing at the person who handed you the object, and continuing to look at your own object
		with (persistent) subgoal testbed_studyOwnObject_performLoop(myName, targetName);

		// eventually end
//subgoal waitFor(20000);
		subgoal waitForRand(3000, 6000);
	}
	   
   //continue to simply look at your own held object
   sequential behavior testbed_studyOwnObject_performLoop(String myName, String targetName){
      subgoal headTrackOff(myName);
      subgoal performAnimation_portion(myName, targetName, animationLookAtHeldObjectIdle, 1000f, 3000f);
   }
   
   
   //glance at the person who handed you the object.
   //If no one handed you the object, this won't be called, and the above behavior is the only one which will play (studying
   //the held object on your own indefinitely.
   sequential behavior testbed_studyOwnObject_performLoop(String myName, String targetName){
      precondition{(!targetName.equals(""))}
      
      subgoal testbed_studyOwnObject_performGlanceAtSpeaker(myName, targetName);
   }
   
   //The speaker has to not be the person specified by 'myName', and has to exist
   sequential behavior testbed_studyOwnObject_performGlanceAtSpeaker(String myName, String targetName){
      specificity 10;
        precondition {
           (targetName != null)
           (!targetName.isEmpty())
           (!myName.equals(targetName))
        }
        
        mental_act {    
           log.info(myName + " is about to track head towards speaker " + targetName);
        }
        
           subgoal headTrack(myName, targetName,true);
           subgoal performAnimation_portion(myName, targetName, animationLookAtHeldObjectIdle, 1000f, 3000f);
   }
   
   //the default one, where we don't do anything.
   sequential behavior testbed_studyOwnObject_performGlanceAtSpeaker(String myName, String targetName){
      specificity 1;
      mental_act{
         log.info("no speaker, so we won't bother trying to glance at one.");  
      }
   }

   
	sequential behavior initial_setups() {
		
		mental_act { nullSiu = null; }
		
		// wait for initialization to settle...
		subgoal waitFor(1000);
					
		subgoal testbed_demo_setup();
		subgoal awarenessMgr_setup();
		subgoal faceMgr_setup();
		
		subgoal initial_setup_complete();
	}
	
	
	sequential behavior initial_setup_complete() {
		// do an initial sense of PhysicalAgentWME to be sure these exist
		precondition { physicalAgentWME=(PhysicalAgentWME) }
				
		// Comment out to do testbed development
		mental_act { log.info("Starting group demo"); }
		subgoal testbed_demo_groupSequence();
	}
	

	//-----------------------------------------------------------------------//
	//-- The Initial Tree ---------------------------------------------------//
	//-----------------------------------------------------------------------//	

	initial_tree {

		subgoal initial_setups();		
		
		
		with (priority 100, persistent) subgoal cif_globalListener();
					
		with (priority 10) subgoal testbedGUI_populate();
		with (persistent) subgoal testbedGUI_behaviorLauncher();
		
		with (priority 1) subgoal CiFVolitionDaemonInit();
		with (persistent) subgoal CiFVolitionDaemon();
		with (persistent) subgoal CiFSiuLaunchListenerInit();

		subgoal coachMgr();
		
		//with (persistent) subgoal printPlayerPosition();
	}
	
}
