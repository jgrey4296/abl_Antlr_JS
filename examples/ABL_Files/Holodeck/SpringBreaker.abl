package eis.ablsl.agents;
import eis.ablsl.*;
import eis.ablsl.actions.*;
import eis.ablsl.sensors.*;
import eis.ablsl.wmes.*;
import java.lang.*; // so the ABL compiler can resolve String (in act invocations)
import java.util.Random;
import java.util.ArrayList;

//adding this comment to test nppdocshare

behaving_entity SpringBreaker 
{
    //CONFLICTS 
    conflict walkTo walkTo;
    conflict turnTowards turnTowards;
    conflict playGesture playGesture;
	conflict sitOn sitOn;
	conflict stand stand;
	conflict nudgeMove nudgeMove;
	conflict walkTo turnTowards playGesture;
	conflict walkToObject turnTowards playGesture;
	conflict walkToObjectById turnTowards playGesture;
	conflict nudgeRotate nudgeRotate;
	conflict wearItem wearItem;
	conflict removeItem removeItem;
	conflict giveItem giveItem;
	conflict walkToObject walkTo;
	conflict walkToObjectById walkTo;
	conflict walkToObject walkToObjectById;
	conflict touchObject touchObject;
	conflict touchObject touchObjectById;
	conflict touchObjectById touchObjectById;
	conflict lookAtObject lookAtObject;
	conflict lookAtObjectById lookAtObject;
	conflict lookAtObjectById lookAtObjectById;
	conflict PlayGesture PlayGesture;
	
	//conflict DoWalkAndWait MaintainMinSocialDistance;
	
	//Goal conflicts? uses priorities on subgoal action
	
    //ACTIONS 
	//NOTE: action method signatures cannot combine Objects with primitives, like: doSomething(double, String);
    register action walkTo(double, double, double) with WalkTo; //walkTo(someLocX, someLocY)
	register action walkTo(String) with WalkTo; //walkTo("someAvatarName")
    register action turnTowards(String) with TurnTowards; //turnTowards("someAvatarName")
	register action turnTowards(double, double) with TurnTowards; //turnTowards(someLocx, someLocy) -- seems to always put the agent facing a bit to far their right.
    register action turnTowards(double, double, double) with TurnTowards; //turnTowards(x, y, overshootDegrees)
	register action turnTowards(String, Double) with TurnTowards; //turnTowards("name", overshootDegrees)
	register action playGesture(String) with PlayGesture; //playGesture("gesturename")
	register action debugPrint(String) with DebugPrint; //sends string output to log window in C#
	register action sitOn(String) with SitOn; //sitOn("someObjectName")
	register action sitOnById(String) with SitOnById; //sitOn("objectID")
	register action stand() with Stand;
	register action stopMovement() with Stop;

	//Nudge direction options: Nudge.LEFT, Nudge.RIGHT, Nudge.FORWARD, Nudge.BACKWARD
	register action nudgeMove(String) with NudgeMove;  //default nudge move - looks the best, but no distance control
	//nudge(string direction, double distance, SelfWME self) - uses current rotation of self as reference for directions
	register action nudgeMove(String, Double, SelfWME) with NudgeMove;  
	//Same as above, but this uses the direction from self to other as reference instead of self rotation
	//This version only works with Nudge.FORWARD and Nudge.BACKWARD currently
	register action nudgeMove(String, Double, SelfWME, AvatarWME) with NudgeMove;  
	
	register action nudgeRotate(double) with NudgeRotate; //rotate body positive or negative around the z-axis (vertical) - positive is left, negative is right
	
	//rotate chosen body partpositive or negative around the z-axis (vertical) - positive is left, negative is right
	//Body part options: NudgeRotate.TARGET_HEAD and NudgeRotate.TARGET_BODY -- currently head rotation doesn't seem to work
	register action nudgeRotate(Double, String) with NudgeRotate; 
														
	register action walkToObject(String) with WalkToObject; //walkToObject("someObjectName")
	register action walkToObjectById(String) with WalkToObjectById; //walkToObjectById("someObjectId")
	register action wearItem(String) with WearItem; //wearItem("someItemName") - wear item (replacing any existing ones) - used for attaching drinks, etc
    register action removeItem(String) with RemoveItem; //removeItem("someItemName") - detach item from avatar
	register action giveItem(String, String) with GiveItem; //giveItem("itemName","avatarName") - give an item to an avatar
	register action touchObject(String) with TouchObject; //touchObject("objectName") - do touch animation 
	register action touchObject(String, Boolean) with TouchObject; //touchObject("objectId", stopTouch) - do touch animation and whether to stop it or not
    register action touchObject() with TouchObject; //Stops touching action
	register action touchObjectById(String) with TouchObjectById; //touchObject("objectId") - do touch animation 
	register action touchObjectById(String, Boolean) with TouchObjectById; //touchObject("objectId", stopTouch) - do touch animation and whether to stop it or not
    register action touchObjectById() with TouchObjectById; //Stops touching action
	register action lookAtObject(String) with LookAtObject; //lookAtObject("objectName")
	register action lookAtObjectById(String) with LookAtObjectById; //lookAtObject("objectId")
	//assuming the head rotation works, this will reset the head rotation to the body rotation
	register action resetHead() with ResetHead;
	
	register wme AnimationWME with AnimationSensor; //x, y, z, animationName, avatarName 
    register wme AvatarWME with AvatarSensor; //x, y, z, rotx, roty, rotz, name
    register wme SelfWME with SelfSensor; //x, y, z, rotx, roty, rotz, name
	register wme ObjectWME with ObjectSensor; //contains x, y, z location variables, objectname (string)
	register wme ItemReceivedWME with ItemReceivedSensor; //contains itemName, and avatarName of offerer (these are items in "Objects" folder - typically drinks)

	/* Objects with automatic timeouts after a certain timespan has passed:
	 * AnimationWME - 5 seconds
	 * ItemReceivedWME - 8 seconds
	 * NOTE: This timeout/stale removal window can be changed in the respective WME files for each type
	 */
	
	double PERSONAL_BUFFER = 1.5;

	Random randomNumGen = new Random(System.currentTimeMillis());
	
	Boolean TrueObject = new Boolean(true);
	Boolean FalseObject = new Boolean(false);

	String[] DRINK_ITEMS = new String[] {"Straw-Banana Daiquiri", "Margarita", "MANHATTAN", "Bloody Mary", 
											"Pina Colada", "Cabernet", "Key Lime Colada", "Draft Beer", 
											"Long Island Ice Tea", "Frosty Mug", "Tropical Paradise", "Blue Raspberry Colada"};
		
	
	/**
	 * Some locations of useful bar regions.
	 */
	double barFrontX = 161.42;
	double barFrontY = 221.60;
	double barFrontZ = 23.82;
	double barBehindX = 157.67;
	double barBehindY = 222.76;
	double barBehindZ = 24.2;
	double stageX = 166.103;
	double stageY = 233.183;
	double stageZ = 24.312;
	double faceBarFromStageX = 165.976;
	double faceBarFromStageY = 231.348;
	double faceBarFromStageZ = 24.29;
	

	
	/**
	*
	*  Used to keep track of anger when somebody bumps into us
	**/
	wme AngryWME {
		String name;
		double strength;
		long lastIncident;
	}
	
	
	/**
	 * Keeps the type of previous behavior subtree around when transitioning to a new 
	 * subtree. This is used for subtrees like GetDrink that may execute then go back to
	 * the previous subtree.
	 */
	wme LastStateWME {
		String stateName;
	}
	
	/**
	 * A WME used by behavior trees to trigger animations to play. Used when the
	 * conversation monitoring and response logic is in a different behavior than the
	 * performance logic.
	 */
	wme PerformGestureWME {
		String gestureName;
		String targetName;
		boolean isResponse;
	}
	
	/**
	 * A WME to control the GetDrink behavior subtree.
	 */
	wme GetDrinkWME {
		String name;
	}
	
	/**
	 * A WME to control the StageDance behavior subtree.
	 */
	wme StageDanceWME {
		long startTime;
	}
	
	/**
	 * A WME to control the SoloDance behavior subtree.
	 */
	wme SoloDanceWME {
		long startTime;
		long lastDanceTime;
		boolean performer;
		String target;
	}
	
	/**
	 * A WME to flag that we are autopiloting currently
	 */

	wme AutoPilotWME {
		double x;
		double y;
		double z;
	}
	
	/**
	 * A WME to flag that we are currently have a drink in hand
	 */
	wme HaveDrinkWME {
		String name;
		long startTime;
	}
	

	
	/**
	 * A WME to control the Greet behavior subtree.
	 */
	wme GreetWME {
		long startTime;
		String targetName;
	}
	
	
	wme LastTargetWME {
		String name;
		long startTime;
	}
	
	wme FindDancePartnerWME {
		String name;
		long startTime;
	}	/**************************************************************************
	* General and utility behaviors.
	**************************************************************************/
	/**
	 * Do random, noisy human-like movement
	 */
	 sequential behavior HumanLocationAdjustment() {
		long startTime;
		double randomRotateDeg;
		int translationCase;
		mental_act {
			startTime = System.currentTimeMillis();
		}
		
		with (success_test {
			(SelfWME sitting==false)
			!(AutoPilotWME)
			((System.currentTimeMillis() - startTime) > 3500)
		}) wait;
		
		mental_act {
			randomRotateDeg = 0.0;
			translationCase = -1;

			if(randomNumGen.nextDouble() < 0.5) //50% random rotation
			{
				
				randomRotateDeg = -35.0 + (70.0 * randomNumGen.nextDouble()); 
				
				
			}
			
			if(randomNumGen.nextDouble() < 0.4)
			{
				translationCase = randomNumGen.nextInt(4);
				
			}
		}
		
		subgoal RandomNudgeMove(translationCase);
		act nudgeRotate(randomRotateDeg);

	 }
	 
	sequential behavior RandomNudgeMove(int translationCase) {
		precondition {
			(translationCase > -1)
		}
		String direction;
		mental_act {
			switch(translationCase) {
			
				case 0: 
					direction = NudgeMove.FORWARD;
					break;
				case 1:
					direction = NudgeMove.BACKWARD;
					break;
				case 2:
					direction = NudgeMove.LEFT;
					break;
				case 3:
					direction = NudgeMove.RIGHT;
					break;
				default:
					direction = NudgeMove.FORWARD;
			}
		
		}
		
		act nudgeMove(direction);
	}
	
	sequential behavior RandomNudgeMove(int translationCase) {
		precondition { (translationCase == -1) }
		
		succeed_step;
	}
	/**
	 *
	 * Put a known item in hand and remove it in order to clear hands of any drinks
	 */
	sequential behavior ClearDrinksInHand() {
		subgoal Wait(3000);
		act wearItem("MANHATTAN");
		subgoal Wait(750);
		act removeItem("MANHATTAN");
	}
	
	
	/* Remove drink from hand over time
	 *
	 */
	sequential behavior TimeoutDrink() {
		String drinkName;
		long drinkStartTime;
		HaveDrinkWME drinkWME;
		with( success_test {
				drinkWME = (HaveDrinkWME name::drinkName startTime::drinkStartTime)
				((System.currentTimeMillis() - drinkStartTime) > 140000)	
		}) wait;
		
		mental_act {
		
			BehavingEntity.getBehavingEntity().deleteWME(drinkWME);
		}
		act removeItem(drinkName);
	}
	
	/* 
	 * Always take drink from somebody and drink from it
	 */
	 sequential behavior AlwaysTakeDrink() {
		String drinkName;
		String avName;
		long drinkStartTime;
		ItemReceivedWME itemWME;
		with( success_test {
				itemWME = (ItemReceivedWME itemName::drinkName avatarName::avName)
				(ItemReceivedWME.isInList(drinkName, DRINK_ITEMS))
		}) wait;
		
		mental_act {
			
			BehavingEntity.getBehavingEntity().deleteAllWMEClass("HaveDrinkWME");
			BehavingEntity.getBehavingEntity().deleteWME(itemWME);
			BehavingEntity.getBehavingEntity().addWME(new HaveDrinkWME(drinkName, System.currentTimeMillis()));
		}
		subgoal Wait(2000);
		subgoal TurnAndWait(avName);
		subgoal Wait(1000);
		subgoal PlayGesture(";)");
		subgoal Wait(3500);
		act wearItem(drinkName);
		subgoal Wait(10000);
	}
	
	
	 /*
	 *	Play Dance Gesture, with no head movement (assumed to be using hotkeys)
	 *
	 */
	 sequential behavior PlayGesture(String gestureName)
	 {
		specificity 2;
		precondition {
			(AnimationWME.isDance(gestureName)) //dance gesture
			(SelfWME name::selfName)
			(ObjectWME name=="footobject" ownerName==selfName objectId::objId)
			(randomNumGen.nextDouble() < 0.65)
		}
		
		
		
		subgoal Wait(350);
		act playGesture(gestureName);
		subgoal Wait(1500);
		
	 
	 
	 }
	 
	 /*
	 *	Play Gesture, with a head movement to ground
	 *
	 */
	 sequential behavior PlayGesture(String gestureName)
	 {
		specificity 1;
		precondition {
			(SelfWME name::selfName)
			(ObjectWME name=="footobject" ownerName==selfName objectId::objId)
			(randomNumGen.nextDouble() < 0.5)
		}
		
		
		act lookAtObjectById(objId);
		subgoal Wait(2500);
		act resetHead();
		subgoal Wait(50);
		act resetHead();
		act playGesture(gestureName);
		subgoal Wait(500);
		
	 
	 
	 }
	 
	 sequential behavior PlayGesture(String gestureName)
	 {

		subgoal Wait(350);
		act playGesture(gestureName);
		subgoal Wait(1500);
	 
	 
	 }
	 
	 
	 sequential behavior StandIfSitting() {
	 
		precondition {
			(SelfWME sitting == true)
		}
		
		act stand();
	}
	
	sequential behavior StandIfSitting() {
	
		precondition {
			(SelfWME sitting==false)
		}
		
		succeed_step;
	}
	
	
	sequential behavior Wait(int millis) {
		long startTime;
		mental_act
		{
			startTime = System.currentTimeMillis();
		}
		with( success_test {
				((System.currentTimeMillis() - startTime) > (long)millis)
		}) wait;
		
	}
				
	sequential behavior TurnAndWait(String avatarName) {
		
		act turnTowards(avatarName);
		subgoal Wait(700);

	}
	
	sequential behavior TurnAndWait(double x, double y) {
	
	
		act turnTowards(x, y);
		subgoal Wait(700);
	}
	
	//better name for this, but it moves to a location and returns when
	//the location is reached
	
	sequential behavior WalkAndWait(double x, double y, double z) {
		double buffer;
		mental_act { buffer = 0.0; }
		
		with (priority 10) subgoal DoWalkAndWait(x, y, z, buffer);
	}
	
	sequential behavior WalkAndWait(double x, double y, double z, double buffer) {
		
		with (priority 10) subgoal DoWalkAndWait(x, y, z, buffer);
	}
	
	
	sequential behavior DoWalkAndWait(double x, double y, double z, double buffer) {
		specificity 1;
		precondition {
			(SelfWME x::myX y::myY z::myZ)
		}
		SelfWME self;
		long startTime;
		double currentDistance, normX, normY, newX, newY;
		mental_act {
			currentDistance = Math.sqrt((myX-x)*(myX-x) +(myY-y)*(myY-y));
			normX = (x-myX) / currentDistance;
			normY = (y-myY) / currentDistance;
			newX = x - normX * buffer; //newX = myX + (x - myX) + (buffer * normX * -1.0) 
			newY = y - normY * buffer; //newY = myY + (y - myY) + (buffer * normY * -1.0) 
		}
		act walkTo(newX,newY,z);
		mental_act
		{
			startTime = System.currentTimeMillis();
			
			//Add new AutoPilotWME signifying navigation
			BehavingEntity.getBehavingEntity().deleteAllWMEClass("AutoPilotWME");
			
			BehavingEntity.getBehavingEntity().addWME(new AutoPilotWME(newX, newY, z));
			
		}	
		
		with( success_test { 
				self = (SelfWME)
				(
					( 
						(Math.abs(self.getX() - newX) <= 1.5) && 
						(Math.abs(self.getY() - newY) <= 1.5)
					) 
					||
					((System.currentTimeMillis() - startTime) > 4000)
				) 
				} ) wait;
				
				
		mental_act
		{
			
			
			//Remove auto pilot wme signalling completion of navigation
			BehavingEntity.getBehavingEntity().deleteAllWMEClass("AutoPilotWME");
		}	
		
		succeed_step;
	}
	

	sequential behavior WalkAndWait(String targetName, double buffer) {
		precondition {
			(AvatarWME name == targetName x::targetX y::targetY z::targetZ)
		}
		
		subgoal WalkAndWait(targetX, targetY, targetZ, buffer);
		
	}
	
	
	sequential behavior WalkAndWait(String targetName) {
		
		with (priority 10) subgoal DoWalkAndWait(targetName);
	}
	
	
	sequential behavior DoWalkAndWait(String targetName) {
		precondition {
			self = (SelfWME)
			(AvatarWME name == targetName x::targetX y::targetY z::targetZ)
			/*( 
				!((Math.abs(self.getX() - targetX) <= 1.0) && 
				(Math.abs(self.getY() - targetY) <= 1.0))
			) */
		}
		long startTime;
		
		act walkTo(targetName);
		mental_act
		{
			startTime = System.currentTimeMillis();
			//Add new AutoPilotWME signifying navigation
			BehavingEntity.getBehavingEntity().deleteAllWMEClass("AutoPilotWME");
			
			BehavingEntity.getBehavingEntity().addWME(new AutoPilotWME(targetX, targetY, targetZ));
		}
		with( success_test { 
				self = (SelfWME)
				//(AvatarWME name == targetName x::targetX y::targetY)
				(
					/*( 
						(Math.abs(self.getX() - targetX) <= 1.0) && 
						(Math.abs(self.getY() - targetY) <= 1.0)
					) */
					
					( 
						(Math.abs(self.getX() - targetX) <= 1.0) && 
						(Math.abs(self.getY() - targetY) <= 1.0)
					) 
					||
					((System.currentTimeMillis() - startTime) > 4000)
				) 
				} ) wait;
		
		mental_act
		{
			
			
			//Remove auto pilot wme signalling completion of navigation
			BehavingEntity.getBehavingEntity().deleteAllWMEClass("AutoPilotWME");
		}	
		
		succeed_step;
	}	
	
	/**
	 * If any character is within a minimum distance of the agent, back up.
	 */
	parallel behavior MaintainMinSocialDistance() {
		
		with (persistent) subgoal TimeoutAnger();
		with (persistent) subgoal WaitForBump();
	}
	
	
	/*
	 *	
	 *
	 */
	sequential behavior TimeoutAnger() {
		long lastTime;
		AngryWME angerWME;
		with( success_test {
				angerWME = (AngryWME lastIncident::lastTime)
				((System.currentTimeMillis() - lastTime) > 25000)	
		}) wait;
		
		mental_act {
		
			BehavingEntity.getBehavingEntity().deleteWME(angerWME);
		}

	}
	
	sequential behavior WaitForBump() {
		AvatarWME a;
		SelfWME self;
		String nudgeDir;
		String avatarName;
		
		
		
		with( success_test  {
			a = (AvatarWME x::otherX y::otherY name::avatarName)
			self = (SelfWME x::selfX y::selfY)
			//distance from avatar to self
			(AvatarWME.withinSocialDistance(AvatarWME.SocialDistance.INTIMATE, a, self))
			!(AutoPilotWME)
			//(minDist >= Math.sqrt( (selfX - otherX)*(selfX - otherX) + (selfY - otherY)*(selfY - otherY)))
		}) wait;

		mental_act {
		
			nudgeDir = NudgeMove.BACKWARD;
			
		}
		
		subgoal KeepDistancePerformance(avatarName, nudgeDir);
	}
		
	
	
	
	
	
	
	/* Group member response - always neutral, no emotional gesture
	 */
	sequential behavior KeepDistancePerformance(String avatarName, String nudgeDirection) {
	
		precondition {
			(GroupMemberWME name == avatarName)

		}
		
		subgoal Wait(300);
		subgoal TurnAndWait(avatarName);
		
		act nudgeMove(nudgeDirection);
	
		subgoal Wait(500);

	}
	
	/* Normal non-group member non-angry bump response
	 */
	sequential behavior KeepDistancePerformance(String avatarName, String nudgeDirection) {
	
		precondition {
			!(GroupMemberWME name == avatarName)
			!(AngryWME name == avatarName)
		
		}
		
		subgoal Wait(300);
		subgoal TurnAndWait(avatarName);
		subgoal Wait(2000);
		act nudgeMove(nudgeDirection);
		
		mental_act {
			BehavingEntity.getBehavingEntity().addWME(new AngryWME(avatarName, 0.0, System.currentTimeMillis()));
		}
		
		subgoal Wait(500);
		
		
	
	}

	
	/* Anger-building bump response, for non group members
     *
	 */
	sequential behavior KeepDistancePerformance(String avatarName, String nudgeDirection) {
	
		precondition {
			anger = (AngryWME name == avatarName strength < 1.0 strength::oldStrength lastIncident::lastTime)
			((System.currentTimeMillis() - lastTime) < 15000)
		
		}
		
	
		subgoal TurnAndWait(avatarName);
		subgoal Wait(300);
		mental_act {
		
			anger.setStrength(anger.getStrength() + 0.2);
			anger.setLastIncident(System.currentTimeMillis());
		}
		act nudgeMove(nudgeDirection);
		subgoal Wait(700);
		subgoal PlayGesture("/no");
		subgoal Wait(500);
	
	
	}
	
	/* Very angry bump response, for non group members
	 *
	 */
	sequential behavior KeepDistancePerformance(String avatarName, String nudgeDirection) {
	
		precondition {
			anger = (AngryWME name == avatarName strength > 1.0 strength::oldStrength lastIncident::lastTime)
			((System.currentTimeMillis() - lastTime) < 15000)
		
		}
		
	
		subgoal TurnAndWait(avatarName);
		mental_act {
		
			anger.setLastIncident(System.currentTimeMillis());
		}
		act nudgeMove(nudgeDirection);
		subgoal Wait(100);
		subgoal PlayGesture("/scold");
		subgoal Wait(500);
	
	
	}
	
	sequential behavior ShuffleWME(String wmeType) {
        //Total Hack: Manually shuffle story state so author goals can match randomly to WME's
        mental_act {
          

			
            List tempWMEList = BehavingEntity.getBehavingEntity().lookupWME(wmeType);
            BehavingEntity.getBehavingEntity().deleteAllWMEClass(wmeType);
            Collections.shuffle(tempWMEList);
            BehavingEntity.getBehavingEntity().getWorkingMemory().addWMEs(tempWMEList);
        }
    }
	
	sequential behavior EliminateDuplicateAnimationEvents() {
		AnimationWME anim1, anim2;
		String selfName, animName, avName;
		long animTime1, animTime2;
		
		
		with( success_test  {
			self = (SelfWME name::selfName)
			anim1 = (AnimationWME avatarName::avName animationName::animName timeMS::animTime1)
			anim2 = (AnimationWME avatarName==avName animationName==animName timeMS::animTime2)
			(anim1 != anim2)
			(Math.abs(animTime1 - animTime2) < 100)	
		}) wait;

		mental_act {
		
			Bot.println("Deleted duplicate animation " + animName + " from " + avName);
			
			BehavingEntity.getBehavingEntity().deleteWME(anim2);
			
		}
	}
			/**************************************************************************
	 * Transition Behaviors - behaviors that clean up WMEs to move to a new behavior subtree.
	 *************************************************************************/
	 
	sequential behavior CleanForTransition() {
		
		
		mental_act {
			Object[] wmes;
			
			//last state WMEs
			wmes = BehavingEntity.getBehavingEntity().lookupWME("LastStateWME").toArray();
			if (wmes.length > 0)  
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((LastStateWME)wmes[i]);
			
			//subtree WMEs
			
			//clean ChatCircleWMEs
			wmes = BehavingEntity.getBehavingEntity().lookupWME("ChatCircleWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((ChatCircleWME)wmes[i]);
				BehavingEntity.getBehavingEntity().addWME(new LastStateWME("ChatCircle"));
			}
			//clean DanceCircleWMEs
			wmes = BehavingEntity.getBehavingEntity().lookupWME("DanceCircleWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((DanceCircleWME)wmes[i]);
				BehavingEntity.getBehavingEntity().addWME(new LastStateWME("DanceCircle"));
			}
			//clean FindDancePartnerWMEs
			wmes = BehavingEntity.getBehavingEntity().lookupWME("FindDancePartnerWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((FindDancePartnerWME)wmes[i]);
				BehavingEntity.getBehavingEntity().addWME(new LastStateWME("FindDancePartner"));
			}
			//clean GetDrinkWMEs
			wmes = BehavingEntity.getBehavingEntity().lookupWME("GetDrinkWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((GetDrinkWME)wmes[i]);
				BehavingEntity.getBehavingEntity().addWME(new LastStateWME("GetDrink"));
			}
			//clean StageDanceWMES
			wmes = BehavingEntity.getBehavingEntity().lookupWME("StageDanceWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((StageDanceWME)wmes[i]);
				BehavingEntity.getBehavingEntity().addWME(new LastStateWME("StageDanceWME"));
			}
			//clean GreetWMES
			wmes = BehavingEntity.getBehavingEntity().lookupWME("GreetWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((GreetWME)wmes[i]);
				BehavingEntity.getBehavingEntity().addWME(new LastStateWME("Greet"));
			}
			//clean SoloDanceWMES
			wmes = BehavingEntity.getBehavingEntity().lookupWME("SoloDanceWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((SoloDanceWME)wmes[i]);
				BehavingEntity.getBehavingEntity().addWME(new LastStateWME("SoloDance"));
			}
			//Utility WMEs
			
			//clean PerformGestureWMEs
			wmes = BehavingEntity.getBehavingEntity().lookupWME("PerformGestureWME").toArray();
			if (wmes.length > 0)  
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((PerformGestureWME)wmes[i]);
					
			Bot.println("CleanForTransition() - done");
		}
	}
	
	sequential behavior TransitionTest() {
		subgoal CleanForTransition();
		mental_act {
			BehavingEntity.getBehavingEntity().addWME(new StageDanceWME(System.currentTimeMillis()));
			Bot.println("TransitionTest() - cleaned for transition and StageDanceWME registered.");
		}
	}
	
	/**
	 * Returns avatar behavior to that of the previous subtree.
	 */

	
	sequential behavior TransitionToPreviousSubtree() {
		specificity 1;
		precondition {
			(LastStateWME stateName=="GetDrink")
		}
		mental_act {
			Bot.println("SUBTREE TRANSITION: previous GetDrink");
		}
		
		subgoal TransitionToGetDrink();
	}
	
	sequential behavior TransitionToPreviousSubtree() {
		specificity 1;
		precondition {
			(LastStateWME stateName=="StageDance")
		}
		mental_act {
			Bot.println("SUBTREE TRANSITION: previous StageDance");
		}
		
		subgoal TransitionToStageDance();
	}
	
	sequential behavior TransitionToPreviousSubtree() {
		specificity 1;
		precondition {
			(LastStateWME stateName=="FindDancePartner")
		}
		mental_act {
			Bot.println("SUBTREE TRANSITION: previous FindDancePartner");
		}
		
		subgoal TransitionToStageDance();
	}
	
	sequential behavior TransitionToPreviousSubtree() {
		specificity 0;
		
		mental_act {
			Bot.println("SUBTREE TRANSITION: no previous - default of FindDancePartner");
		}
		
		subgoal TransitionToFindDancePartner();
	}
	
	/**
	 * Transitions to the StageDance behavior tree.
	 */
	
	//new style
	sequential behavior TransitionToStageDance() {
		specificity 1; //specificity is only used to use the new style transition behavior instead of the old one -- remove when removing old behaviors
		/* mental_act {
			
			Bot.println("TransitionToStageDance() - begin.");
		} */
		subgoal CleanForTransition();
		/* mental_act {
			
			Bot.println("TransitionToStageDance() - cleaned.");
		} */
		mental_act {
			BehavingEntity.getBehavingEntity().addWME(new StageDanceWME(System.currentTimeMillis()));
			Bot.println("TransitionToStageDance() - cleaned for transition and StageDanceWME registered.");
		}
		//subgoal Wait(10);
	}
	
	//old style 
	sequential behavior TransitionToStageDance() {
		specificity 2;
		mental_act {
			StageDanceWME sdWME = new StageDanceWME();
			BehavingEntity.getBehavingEntity().addWME(sdWME);
			Bot.println("SUBTREE TRANSITION: StageDance");
			
			Object[] wmes;
			
			//last state WMEs
			wmes = BehavingEntity.getBehavingEntity().lookupWME("LastStateWME").toArray();
			if (wmes.length > 0)  
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((LastStateWME)wmes[i]);
			
			//subtree WMEs
			
			//clean ChatCircleWMEs
			wmes = BehavingEntity.getBehavingEntity().lookupWME("ChatCircleWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((ChatCircleWME)wmes[i]);
				BehavingEntity.getBehavingEntity().addWME(new LastStateWME("ChatCircle"));
			}
			//clean DanceCircleWMEs
			wmes = BehavingEntity.getBehavingEntity().lookupWME("DanceCircleWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((DanceCircleWME)wmes[i]);
				BehavingEntity.getBehavingEntity().addWME(new LastStateWME("DanceCircle"));
			}
			//clean FindDancePartnerWMEs
			wmes = BehavingEntity.getBehavingEntity().lookupWME("FindDancePartnerWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((FindDancePartnerWME)wmes[i]);
				BehavingEntity.getBehavingEntity().addWME(new LastStateWME("FindDancePartner"));
			}
			//clean GetDrinkWMEs
			wmes = BehavingEntity.getBehavingEntity().lookupWME("GetDrinkWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((GetDrinkWME)wmes[i]);
				BehavingEntity.getBehavingEntity().addWME(new LastStateWME("GetDrink"));
			}
			//clean GreetWMES
			wmes = BehavingEntity.getBehavingEntity().lookupWME("GreetWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((GreetWME)wmes[i]);
				BehavingEntity.getBehavingEntity().addWME(new LastStateWME("Greet"));
			}
			//clean SoloDanceWMES
			wmes = BehavingEntity.getBehavingEntity().lookupWME("SoloDanceWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((SoloDanceWME)wmes[i]);
				BehavingEntity.getBehavingEntity().addWME(new LastStateWME("SoloDance"));
			}
			//Utility WMEs
			
			//clean PerformGestureWMEs
			wmes = BehavingEntity.getBehavingEntity().lookupWME("PerformGestureWME").toArray();
			if (wmes.length > 0)  
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((PerformGestureWME)wmes[i]);
		}
	}
	
	/**
	 * Transitions to the GetADrink behavior tree.
	 */
	 
	//new style
	sequential behavior TransitionToGetDrink() {
		specificity 1; //specificity is only used to use the new style transition behavior instead of the old one -- remove when removing old behaviors
		subgoal CleanForTransition();
		mental_act {
			BehavingEntity.getBehavingEntity().addWME(new GetDrinkWME(""));
			Bot.println("TransitionToGetDrink() - cleaned for transition and GetDrinkWME registered.");
		}
	}

	//old style
		
	sequential behavior TransitionToGetDrink() {
		specificity 2;
		//subgoal CleanForTransition();
		
		mental_act {
			BehavingEntity.getBehavingEntity().addWME(new GetDrinkWME("foo"));
			Bot.println("SUBTREE TRANSITION: GetDrink");
			
		
			Object[] wmes;
			
			//last state WMEs
			wmes = BehavingEntity.getBehavingEntity().lookupWME("LastStateWME").toArray();
			if (wmes.length > 0)  
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((LastStateWME)wmes[i]);
			
			//subtree WMEs
			
			//clean ChatCircleWMEs
			wmes = BehavingEntity.getBehavingEntity().lookupWME("ChatCircleWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((ChatCircleWME)wmes[i]);
				BehavingEntity.getBehavingEntity().addWME(new LastStateWME("ChatCircle"));
			}
			//clean DanceCircleWMEs
			wmes = BehavingEntity.getBehavingEntity().lookupWME("DanceCircleWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((DanceCircleWME)wmes[i]);
				BehavingEntity.getBehavingEntity().addWME(new LastStateWME("DanceCircle"));
			}
			//clean FindDancePartnerWMEs
			wmes = BehavingEntity.getBehavingEntity().lookupWME("FindDancePartnerWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((FindDancePartnerWME)wmes[i]);
				BehavingEntity.getBehavingEntity().addWME(new LastStateWME("FindDancePartner"));
			}
			//clean StageDanceWMES
			wmes = BehavingEntity.getBehavingEntity().lookupWME("StageDanceWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((StageDanceWME)wmes[i]);
				BehavingEntity.getBehavingEntity().addWME(new LastStateWME("StageDanceWME"));
			}
			//clean GreetWMES
			wmes = BehavingEntity.getBehavingEntity().lookupWME("GreetWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((GreetWME)wmes[i]);
				BehavingEntity.getBehavingEntity().addWME(new LastStateWME("Greet"));
			}
			//clean SoloDanceWMES
			wmes = BehavingEntity.getBehavingEntity().lookupWME("SoloDanceWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((SoloDanceWME)wmes[i]);
				BehavingEntity.getBehavingEntity().addWME(new LastStateWME("SoloDance"));
			}
			//Utility WMEs
			
			//clean PerformGestureWMEs
			wmes = BehavingEntity.getBehavingEntity().lookupWME("PerformGestureWME").toArray();
			if (wmes.length > 0)  
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((PerformGestureWME)wmes[i]);
		}
	}
	
	
	
	 
	//new style
	atomic sequential behavior TransitionToFindDancePartner() {
		specificity 1; //specificity is only used to use the new style transition behavior instead of the old one -- remove when removing old behaviors
		subgoal CleanForTransition();
		mental_act {
			BehavingEntity.getBehavingEntity().addWME(new FindDancePartnerWME("", System.currentTimeMillis()));
			Bot.println("TransitionToFindDancePartner() - cleaned for transition and FindDancePartner registered.");
		}
	}

	atomic sequential behavior TransitionToFindDancePartner() {
		specificity 3;
		precondition {
			(FindDancePartnerWME name::initialTarget)
		}
		
		mental_act {
			Bot.println("SUBTREE TRANSITION: FindDancePartner with initial target of " + initialTarget + ".");
		
			Object[] wmes;
			
			//last state WMEs
			wmes = BehavingEntity.getBehavingEntity().lookupWME("LastStateWME").toArray();
			if (wmes.length > 0)  
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((LastStateWME)wmes[i]);
			
				
			//clean ChatCircleWMEs
			wmes = BehavingEntity.getBehavingEntity().lookupWME("ChatCircleWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((ChatCircleWME)wmes[i]);
				BehavingEntity.getBehavingEntity().addWME(new LastStateWME("ChatCircle"));
			}
			//clean DanceCircleWMEs
			wmes = BehavingEntity.getBehavingEntity().lookupWME("DanceCircleWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((DanceCircleWME)wmes[i]);
				BehavingEntity.getBehavingEntity().addWME(new LastStateWME("DanceCircle"));
			}
			//clean GetDrinkWMEs
			wmes = BehavingEntity.getBehavingEntity().lookupWME("GetDrinkWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((GetDrinkWME)wmes[i]);
				BehavingEntity.getBehavingEntity().addWME(new LastStateWME("GetDrink"));
			}
			//clean StageDanceWMES
			wmes = BehavingEntity.getBehavingEntity().lookupWME("StageDanceWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((StageDanceWME)wmes[i]);
				BehavingEntity.getBehavingEntity().addWME(new LastStateWME("StageDanceWME"));
			}
			//clean GreetWMES
			wmes = BehavingEntity.getBehavingEntity().lookupWME("GreetWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((GreetWME)wmes[i]);
				BehavingEntity.getBehavingEntity().addWME(new LastStateWME("Greet"));
			}
			//clean SoloDanceWMES
			wmes = BehavingEntity.getBehavingEntity().lookupWME("SoloDanceWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((SoloDanceWME)wmes[i]);
				BehavingEntity.getBehavingEntity().addWME(new LastStateWME("SoloDance"));
			}
			//Utility WMEs
			
			//clean PerformGestureWMEs
			wmes = BehavingEntity.getBehavingEntity().lookupWME("PerformGestureWME").toArray();
			if (wmes.length > 0)  
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((PerformGestureWME)wmes[i]);
		}
		
	}
	//old style
	atomic sequential behavior TransitionToFindDancePartner() {
		specificity 2;
		mental_act {
			
			
			
			Object[] wmes;
			
			//last state WMEs
			wmes = BehavingEntity.getBehavingEntity().lookupWME("LastStateWME").toArray();
			if (wmes.length > 0)  
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((LastStateWME)wmes[i]);
			
			//subtree WMEs
		
		
			wmes = BehavingEntity.getBehavingEntity().lookupWME("FindDancePartnerWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((FindDancePartnerWME)wmes[i]);
				BehavingEntity.getBehavingEntity().addWME(new LastStateWME("FindDancePartner"));
			}
			
			//create new last state
			FindDancePartnerWME dpWME = new FindDancePartnerWME("", System.currentTimeMillis());
			BehavingEntity.getBehavingEntity().addWME(dpWME);
			Bot.println("SUBTREE TRANSITION: FindDancePartner");
			
			//clean ChatCircleWMEs
			wmes = BehavingEntity.getBehavingEntity().lookupWME("ChatCircleWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((ChatCircleWME)wmes[i]);
				BehavingEntity.getBehavingEntity().addWME(new LastStateWME("ChatCircle"));
			}
			//clean DanceCircleWMEs
			wmes = BehavingEntity.getBehavingEntity().lookupWME("DanceCircleWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((DanceCircleWME)wmes[i]);
				BehavingEntity.getBehavingEntity().addWME(new LastStateWME("DanceCircle"));
			}
			//clean GetDrinkWMEs
			wmes = BehavingEntity.getBehavingEntity().lookupWME("GetDrinkWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((GetDrinkWME)wmes[i]);
				BehavingEntity.getBehavingEntity().addWME(new LastStateWME("GetDrink"));
			}
			//clean StageDanceWMES
			wmes = BehavingEntity.getBehavingEntity().lookupWME("StageDanceWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((StageDanceWME)wmes[i]);
				BehavingEntity.getBehavingEntity().addWME(new LastStateWME("StageDanceWME"));
			}
			//clean GreetWMES
			wmes = BehavingEntity.getBehavingEntity().lookupWME("GreetWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((GreetWME)wmes[i]);
				BehavingEntity.getBehavingEntity().addWME(new LastStateWME("Greet"));
			}
			//clean SoloDanceWMES
			wmes = BehavingEntity.getBehavingEntity().lookupWME("SoloDanceWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((SoloDanceWME)wmes[i]);
				BehavingEntity.getBehavingEntity().addWME(new LastStateWME("SoloDance"));
			}
			//Utility WMEs
			
			//clean PerformGestureWMEs
			wmes = BehavingEntity.getBehavingEntity().lookupWME("PerformGestureWME").toArray();
			if (wmes.length > 0)  
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((PerformGestureWME)wmes[i]);
					

		}
	}
	
  
	
	
	
	/**************************************************************************
	 * Determine Next Subtree
	 *
	 * Determines which behavior is best to do next -- a first cut of a volition process.
	 *************************************************************************/
	
	/**
	 * Stochastically chooses a subtree to perform next that was not the most recently-performend subtree.
	 */
	sequential behavior DetermineNextSubtree() {
		specificity 3;
		precondition { (LastStateWME stateName::lastSubtree) }
		int next;
		mental_act {
			Bot.println("Determining Next Subtree, with last subtree: " + lastSubtree);
			next = randomNumGen.nextInt(2); //the number of subtrees  - 1
			if(lastSubtree.equals("FindDancePartner"))
				++next; //1 or 2
			if(lastSubtree.equals("GetDrink"))
				next = (next==1)?2:0; //0 or 2
				//StageDance is 0 or 1
		}
		subgoal DetermineNextSubtreeByNumber(next);
	}
	
	sequential behavior DetermineNextSubtree() {
		specificity 2;
		int next;
		mental_act {
			Bot.println("No LastStateWME, Selecting random subtree");
			next = randomNumGen.nextInt(3); //the number of subtrees  - 1
		}
		subgoal DetermineNextSubtreeByNumber(next);
	}
	
	sequential behavior DetermineNextSubtreeByNumber(int n) {
		precondition {(n == 0)}
		subgoal TransitionToFindDancePartner();			
	}
	sequential behavior DetermineNextSubtreeByNumber(int n) {
		precondition {(n == 1)}
		subgoal TransitionToGetDrink();			
	}
	sequential behavior DetermineNextSubtreeByNumber(int n) {
		precondition {(n == 2)}
		subgoal TransitionToStageDance();			
	}
	
	/* sequential behavior DetermineNextSubtree() {
		specificity 1;
		precondition {
			(GetDrinkWME)
		}
		int next;
		mental_act {
			Bot.println("DetermineNextSubtree():  GetDrink -> FindDancePartner");
			switch(randomNumGen.nextInt(2)) {
				case 0:
					next = 0;
					break;
				case 1:
					next = 1;
					break;
				}
			
		}
		
		subgoal TransitionToFindDancePartner();
	}
	
	sequential behavior DetermineNextSubtree() {
		specificity 1;
		precondition {
			(StageDanceWME)
		}
		mental_act {
			Bot.println("DetermineNextSubtree(): StageDance -> GetDrink");
		}
		
		subgoal TransitionToGetDrink();
	}
	
	sequential behavior DetermineNextSubtree() {
		specificity 1;
		precondition {
			(FindDancePartnerWME)
		}
		mental_act {
			Bot.println("DetermineNextSubtree(): FindDancePartner -> StageDance");
		}
		
		subgoal TransitionToStageDance();
	}
	
	sequential behavior DetermineNextSubtree() {
		specificity 0;
		
		mental_act {
			Bot.println("DetermineNextSubtree():  no current subtree WME found - default of FindDancePartner");
		}
		
		subgoal TransitionToFindDancePartner();
	} */
	
	/**************************************************************************
	 * FindDancePartner
	 *
	 * Agent finds a dance partner and dances
	 *************************************************************************/
	sequential behavior EnterFindDancePartner() {
		FindDancePartnerWME dp;
		with (success_test {
			dp=(FindDancePartnerWME)
		} ) wait;
		mental_act {
			dp.setStartTime(System.currentTimeMillis());
		}
		
		subgoal FindDancePartnerMaster();
	}
	
	parallel behavior FindDancePartnerMaster() {	
		context_condition {
			(FindDancePartnerWME)
		}

		with (persistent) subgoal HumanLocationAdjustment();
		//with (persistent) subgoal MaintainMinSocialDistance(); 
		with (persistent) subgoal FDPPickTargetAndDance();
		subgoal FDPBored();
	}
	
	
	/**
	 * FDP with the participant if the participant is in range.
	 */
	sequential behavior FDPPickTargetAndDance() {
		specificity 2;
		precondition {
			self=(SelfWME)
			av = (AvatarWME name::avName isParticipant==true distanceFromSelf < 3.0)
			(randomNumGen.nextDouble() < 0.4)
		}
		
		subgoal CleanLastTarget();
		
		mental_act {
			BehavingEntity.getBehavingEntity().addWME(new LastTargetWME(avName, System.currentTimeMillis()));
			Bot.println("FDPPickTargetAndDance() for close participant: FindDancePartner with the nearby participant.");
		}
		
		subgoal FDPMaybeOfferDrinkThenDance();
		//A wait buffer to stop this behavior from spinning
		subgoal Wait(2000);
		
	}
	
	
	/**
	 * Pick a avatar to darget with dancing and boisterousness. Go to said target and be boisterous.
	 *
	 * Do not pick the last target again. If there was no last target, pick anyone.
	 * Generally, pick waiters very rarely (10%). Generally pick regulars less often (25%). 
	 * Everyone else (player, wallflower) is 65%.
	 */
	sequential behavior FDPPickTargetAndDance() {
		specificity 1;
		String lastTargetName;
		
		// with (success_test {
			// (last
			// (AvatarWME name::targetName)
			// (BehavingEntity.truePrintln("PickTargetAndDance:1:: targetName:  " + targetName))
		// } ) wait;
		
		subgoal CleanLastTarget();
		
		 mental_act {
			lastTargetName = "";
		 }

		subgoal FDPWeightedRandomTarget(lastTargetName);
		subgoal FDPMaybeOfferDrinkThenDance();
		//A wait buffer to stop this behavior from spinning
		subgoal Wait(2000);
	}

	/* sequential behavior FDPPickTargetAndDance() {
		specificity 1;
		precondition {
			(LastTargetWME name::lastTargetName)
		}
		
		subgoal FDPWeightedRandomTarget(lastTargetName);

		//A wait buffer to stop this behavior from spinning
		subgoal Wait(2000);
	} */
	
		 
	/**
	 * Go with the initial target.
	 */
	/*sequential behavior FDPPickTargetAndDance() {
		specificity 3;
		precondition {
			(FindDancePartnerWME name::initialTarget name != "")
			!(LastTargetWME)
		}
		
		mental_act {
			BehavingEntity.getBehavingEntity().addWME(new LastTargetWME(initialTarget, System.currentTimeMillis()));
			Bot.println("FDPPickTargetAndDance(): FindDancePartner with initial subtree target of " + initialTarget + ".");
		}
	
		//A wait buffer to stop this behavior from spinning
		subgoal Wait(2000);
	}*/
	
	
	
	/**
	 * Picks any target that was not the previous target.
	 */
	/*sequential behavior FDPWeightedRandomTarget(String lastTarget) {
		specificity 0;
		AvatarWME a;
		subgoal ShuffleWME("AvatarWME");
		with ( success_test {
				a=(AvatarWME name!=lastTarget isWaiter == false)
			} ) wait;
		subgoal CleanLastTarget();
		mental_act {
			BehavingEntity.getBehavingEntity().addWME(new LastTargetWME(a.getName(), System.currentTimeMillis()));
			Bot.println("FDPWeightedRandomTarget()dumb: target avatar: " + a.getName());
		}
		
		//A wait buffer to stop this behavior from spinning
		subgoal Wait(2000);
	}*/
	
	/**
	 * Smarter target chooser for a full scenario.
	 */
	sequential behavior FDPWeightedRandomTarget(String lastTarget) {
		specificity 1;
		String target;
		double pick;
		boolean repick;
		subgoal CleanLastTarget();
		
		//Chance ranges
		//participant 0 - 38
		//wallflower 38 - 47
		//other springbreaker 47-72
		//regular 72-85
		//waiter 85-90
		//random bot 90-100
		mental_act {
			target = lastTarget;
		
			//special case of if we pick roles with only one avatar
			while (lastTarget.equals(target)) {
				pick = randomNumGen.nextDouble();
				
				//participant
				if(pick < 0.22) {
					target = AvatarWME.Roles.NAME_PARTICIPANT;
				//wallflower
				}else if(pick  < 0.40) {
					target = AvatarWME.Roles.NAME_WALLFLOWER_BOT;
				//other springbreaker
				} else if (pick < 0.72) {
					
					target = AvatarWME.Roles.NAME_SPRINGBREAKER_HUMAN;
				//regular
				} else if (pick < 0.85) {
					switch (randomNumGen.nextInt(3)) {
					
						case 0:
							target = AvatarWME.Roles.NAME_REGULAR_AVATAR;
							break;
						case 1:
							target = AvatarWME.Roles.NAME_REGULAR_2;
							break;
						case 2: 
							target = AvatarWME.Roles.NAME_REGULAR_3;
							break;
					
					}
					
				//waiter
				} else if (pick < 0.90) {
					
					target = AvatarWME.Roles.NAME_WAITER_BOT;			
				//random bot			
				}else {
					target = AvatarWME.Roles.NAME_RANDOM_BOT;
				}
				
			}
			
			

			BehavingEntity.getBehavingEntity().addWME(new LastTargetWME(target, System.currentTimeMillis()));
			Bot.println("FDPWeightedRandomTarget()weighted selection: target avatar: " + target);	
		}
		//A wait buffer to stop this behavior from spinning
		subgoal Wait(1000);
	}
	
	/**
	 * Pick a avatar to darget with dancing and boisterousness. Go to said target and be boisterous.
	 *
	 * This is a more specific case of picking a target that is outside of the minimum social distance.
	 */
	
	
	sequential behavior FDPMaybeOfferDrinkThenDance() {
		precondition {
			(LastTargetWME name::targetName)
		}
		
		double offerDrinkRandom;
		mental_act { offerDrinkRandom = randomNumGen.nextDouble(); }
		
		subgoal TurnAndWait(targetName);
		subgoal WalkAndWait(targetName, 1.2d);
		with (ignore_failure) subgoal FDPMaybeOfferDrink(offerDrinkRandom);
		subgoal Wait(1500);
		subgoal GoToTargetAndDance();
	}
	
	parallel behavior GoToTargetAndDance() {
		context_condition {	
			(LastTargetWME startTime::time)
			((System.currentTimeMillis() - time) < 22000) 
		}
		precondition {
			ltWME = (LastTargetWME name::targetName)
		}

		with (priority 1) subgoal WalkAndWait(targetName);
		with (persistent) subgoal PerformRandomDance();
		with (persistent) subgoal FDPTargetPositiveResponse();
	}
	
	/**
	 * Offer a drink to the target some of the time.
	 */
	 sequential behavior FDPMaybeOfferDrink(double offerDrinkRandom) {
		precondition { 
			(offerDrinkRandom < 0.20)
			(BehavingEntity.truePrintln("FDPMaybeOfferDrink() precond. Random is: " + offerDrinkRandom))
			(LastTargetWME name::targetName)
		} //offer drink 20% of the time.
		String drinkName;
		mental_act {
			drinkName = DRINK_ITEMS[randomNumGen.nextInt(DRINK_ITEMS.length)];
		}
		subgoal Wait(2000);
		act giveItem(drinkName, targetName) ;
	}
	
	
	
	/**
	 * If the SB's participant target gestures back positively (dances, whistle, claps), stay longer on this target.
	 */
	sequential behavior FDPTargetPositiveResponse() {
		precondition {
			(LastTargetWME name::tName)
			(AvatarWME name==tName isParticipant == true)
		
		}
		AnimationWME anim;
		AvatarWME av;
		LastTargetWME l;
		SelfWME self;
		String type;
		String lastTarget;
		with (success_test {
			self=(SelfWME)
			l = (LastTargetWME name::lastTarget)
			av = (AvatarWME name==lastTarget isParticipant==true)
			anim= (AnimationWME avatarName==lastTarget animationName::type)
			(AvatarWME.gazeAngleBetween(av, self) < 45.0)
			(	anim.getIsDance() || 
				type.equals(AnimationWME.Gestures.WAVE) || 
				type.equals(AnimationWME.Gestures.WHISTLE) || 
				type.equals(AnimationWME.Gestures.WINK_BANG) ||
				type.equals(AnimationWME.Gestures.SMILEY_HAPPY) ||
				type.equals(AnimationWME.Gestures.CHUCKLE) ||
				type.equals(AnimationWME.Gestures.LAUGH) ||
				type.equals(AnimationWME.Gestures.YES) ||
				type.equals(AnimationWME.Gestures.YES_BANG) ||
				type.equals(AnimationWME.Gestures.CLAP) ||
				type.equals(AnimationWME.Gestures.BOW)
			)
			} ) wait;
		mental_act {
			l.setStartTime(l.getStartTime() + 4000);
			Bot.println("FDPTargetPositiveResponse(): positive response from participant " + type + " from " + lastTarget + " detected -- adding 4000ms to target dance time.");
			BehavingEntity.getBehavingEntity().deleteWME(anim);
		}
		subgoal WalkAndWait(lastTarget, 1.2d);
		subgoal Wait(1000);
	}
	
	
	//A more limited positive responder for non participants
	sequential behavior FDPTargetPositiveResponse() {
		precondition {
			(LastTargetWME name::tName)
			(AvatarWME name==tName isParticipant == false)
		
		}
		AnimationWME anim;
		AvatarWME av;
		LastTargetWME l;
		SelfWME self;
		String type;
		String lastTarget;
		with (success_test {
			self=(SelfWME)
			l = (LastTargetWME name::lastTarget)
			av = (AvatarWME name==lastTarget isParticipant==false)
			anim= (AnimationWME avatarName==lastTarget animationName::type)
			(AvatarWME.gazeAngleBetween(av, self) < 30.0)
			(	anim.getIsDance() || type.equals(AnimationWME.Gestures.WAVE) || 
				type.equals(AnimationWME.Gestures.LAUGH) ||
				type.equals(AnimationWME.Gestures.CLAP))
			} ) wait;
		mental_act {
			l.setStartTime(l.getStartTime() + 1500);
			Bot.println("FDPTargetPositiveResponse(): positive response from non participant " + type + " from " + lastTarget + " detected -- adding 1500ms to target dance time.");
			BehavingEntity.getBehavingEntity().deleteWME(anim);
		}
		subgoal WalkAndWait(lastTarget, 1.2d);
		subgoal Wait(3000);
	}
	
	sequential behavior PerformRandomDance() {
		precondition {
			(LastTargetWME name::targetName)
		}
		String danceGestureName;
		mental_act {
			int danceNumber = randomNumGen.nextInt(8) + 1;
			danceGestureName = "dance" + Integer.toString(danceNumber);
			Bot.println("PerformRandomDance() dance: " + danceGestureName);
			
		}
		
		act turnTowards(targetName);
		subgoal WalkAndWait(targetName, 1.2d);
		subgoal PlayGesture(danceGestureName);
		subgoal Wait(2000);
	}
	
	/**
	 * Bored/time out case for the FindDancePartner subtree.
	 */
	sequential behavior FDPBored() {
		//FindDancePartnerWME fdWME;
		long time;
	
		with ( success_test {
			(FindDancePartnerWME startTime::time)
			((System.currentTimeMillis() - time) > 80000)
		} ) wait;
		
		mental_act {
			Bot.println("FDPBored() 80 second timeout -- DetermineNextSubtree called.");
		}
		
		subgoal DetermineNextSubtree();
	}
	
	/**************************************************************************
	 * StageDance
	 *
	 * Agent goes to the stage and dances for a while.
	 *************************************************************************/
	sequential behavior EnterStageDance() {
		StageDanceWME sd;
		with (success_test {
			sd=(StageDanceWME)
		} ) wait;
		mental_act {
			sd.setStartTime(System.currentTimeMillis());
		}
		//go to the stage
		subgoal WalkAndWait(stageX, stageY, stageZ);
		//face the bar
		act turnTowards(faceBarFromStageX, faceBarFromStageY);
		//dance for a a while.
		subgoal StageDanceMaster();
	}
	
	parallel behavior StageDanceMaster() {
		context_condition {
			(StageDanceWME)
		}
		//int danceStartTime;
		
		with (priority 1, persistent) subgoal HumanLocationAdjustment();
		with (priority 1, persistent) subgoal MaintainMinSocialDistance(); 
		with (priority 1, persistent) subgoal StageDanceTransitionOut();
		with (priority 1, persistent) subgoal PerformStageDance();
		with (priority 1, persistent) subgoal ContinueDancing();
		
		/* with (success_test {
			
			//(BehavingEntity.truePrintln( ""+(System.currentTimeMillis() - danceStartTime) + " " + ((System.currentTimeMillis() - danceStartTime) > 60000.0)))
			((System.currentTimeMillis() - danceStartTime) > 60000.0)
			//(BehavingEntity.truePrintln( ""+danceStartTime ))
			//(BehavingEntity.truePrintln( ""+(int)(System.currentTimeMillis())))
		}) subgoal PerformStageDance(); */
		//go back to previous state.
		//subgoal TransitionToPreviousSubtree();
		
	}
	
	sequential behavior PerformStageDance() {
		String danceGestureName;
		mental_act {
			int danceNumber = randomNumGen.nextInt(8) + 1;
			danceGestureName = "dance" + Integer.toString(danceNumber);
			Bot.println("PerformStageDance() dance: " + danceGestureName);
			
		}
		subgoal PlayGesture(danceGestureName);
		subgoal Wait(3000);
	}
	
	sequential behavior ContinueDancing() {
		precondition {
			stageDanceWME = (StageDanceWME)
		}
		AnimationWME danceAnim;
		AvatarWME targetAvatar;
		SelfWME self;
		String avName;
		
		
		with (success_test {
			danceAnim = (AnimationWME avatarName::avName isDance==true)
			targetAvatar = (AvatarWME name == avName)
			self = (SelfWME)
			(AvatarWME.withinSocialDistance(AvatarWME.SocialDistance.SOCIAL, targetAvatar, self))
		} ) wait;
		
		
		mental_act {
		
			
			if((45000 - (System.currentTimeMillis() - stageDanceWME.getStartTime())) < 10000)
			{
				

				//Bump timer ahead to prevent ending of stage dance behaviors
				stageDanceWME.setStartTime(stageDanceWME.getStartTime() + 4000);
								Bot.println("Nearby dance detected! I'll keep dancing! Dancing Time left: " + (45000 - (System.currentTimeMillis() - stageDanceWME.getStartTime())));
			}
			
			//Consume dance event
			BehavingEntity.getBehavingEntity().deleteWME(danceAnim);
		}
		
		//Always turn towards last dancer
		subgoal TurnAndWait(avName);
		subgoal Wait(2000);
	
	}
	
	
	sequential behavior StageDanceTransitionOut() {
	

		with (success_test {
			(StageDanceWME startTime::sdStartTime)
			(System.currentTimeMillis() - sdStartTime > 35000)
		} ) wait;
		
		subgoal Wait(2000);
		subgoal DetermineNextSubtree();
		subgoal Wait(2000);
	}
	

	/**************************************************************************
	 * GetDrink
	 *
	 * Agent goes to the bar (or potentially a waiter) to get a drink.
	 *************************************************************************/
	sequential behavior EnterGetDrink() {
		with (success_test {
			(GetDrinkWME)
		} ) wait;
		with (priority 1) subgoal GD_Master();
	}
	
	parallel behavior GD_Master() {
		context_condition {
			(GetDrinkWME)
		}
		
		with (priority 50) subgoal ShuffleWME("AvatarWME");
		
		with (priority 1) subgoal GD_Performance();
		with (priority 1, persistent) subgoal HumanLocationAdjustment();
		with (priority 1, persistent) subgoal MaintainMinSocialDistance();
	
	}
	
	/**
	 * Get Drink at waiter/waitress - go to close waiter/waitress first
	 */
	 sequential behavior GD_Performance() {
		specificity 3;
		precondition {
			(AvatarWME name::targetName isWaiter == true distanceFromSelf < 3.0)
			(ObjectWME ownerName==targetName name=="BARTENDER hsr02" objectId::objId)
		
		}
		
		subgoal GD_PerformanceWithWaiter(targetName, objId);
		
		
	}
	
	 /**
	 * Get Drink at waiter/waitress - go to any waiter/waitress within a reasonable far distance
	 */
	sequential behavior GD_Performance() {
		specificity 2;
		precondition {
			(AvatarWME name::targetName isWaiter == true distanceFromSelf < 6.0)
			(ObjectWME ownerName==targetName name=="BARTENDER hsr02" objectId::objId)
		
		}
		
		subgoal GD_PerformanceWithWaiter(targetName, objId);
		
		
	}
	
	
	/**
	 * Get Drink at bar if no close waiter
	 */
	  
	sequential behavior GD_Performance() {
		precondition {
			(ObjectWME name=="BARTENDER hsr03" objectId::objId)
		
		}
		
		String boredGesture;
		String pointYouGesture;
		String winkBangGesture;
		String drinkName;
		

		mental_act {
			boredGesture = AnimationWME.Gestures.BORED;
			pointYouGesture = AnimationWME.Gestures.POINTYOU;
			winkBangGesture = AnimationWME.Gestures.WINK_BANG;
			
		}
		
		//go to the bar
		subgoal WalkAndWait(barFrontX, barFrontY, barFrontZ);
		//face the baar
		act turnTowards(barBehindX, barBehindY);
		//wait a bit, tap foot or something to show that we're deciding on a drink
		//subgoal Wait(3000);
		//subgoal PlayGesture(boredGesture);
		subgoal Wait(1500);
		act touchObjectById(objId);
		subgoal Wait(2500);
		act touchObjectById(); //stop touching
		subgoal Wait(250);
		act touchObjectById();
		subgoal Wait(300);
		act touchObjectById();
		
		mental_act {
			//String[] drinks = new String[] {"Margarita", "MANHATTAN", "Bloody Mary", "Pina Colada", "Cabernet"};
			
			int drinkIndex = randomNumGen.nextInt(DRINK_ITEMS.length);
			drinkName = DRINK_ITEMS[drinkIndex];
			
			BehavingEntity.getBehavingEntity().deleteAllWMEClass("HaveDrinkWME");
			
		
			BehavingEntity.getBehavingEntity().addWME(new HaveDrinkWME(drinkName, System.currentTimeMillis()));
			
		
		}
		subgoal Wait(3500);
		act wearItem(drinkName);
		subgoal Wait(1000);
		subgoal PlayGesture(winkBangGesture);
		//go back to previous behavior subtree
		subgoal TransitionToPreviousSubtree();
		
	}
	
	
	
	
	
	
	
	/**
	 * Do performance where we go to selected waiter/waitress and get a drink
	 */
	sequential behavior GD_PerformanceWithWaiter(String waiterName, String bartenderObjectId) {
		
		String boredGesture;
		String pointYouGesture;
		String winkBangGesture;
		String drinkName;
		String waveGesture;
		

		mental_act {
			boredGesture = AnimationWME.Gestures.BORED;
			pointYouGesture = AnimationWME.Gestures.POINTYOU;
			winkBangGesture = AnimationWME.Gestures.WINK_BANG;
			waveGesture = AnimationWME.Gestures.WAVE;
			
		}
		
		//go to the waiter
		subgoal TurnAndWait(waiterName);
		subgoal PlayGesture(waveGesture);
		subgoal Wait(500);
		subgoal WalkAndWait(waiterName, PERSONAL_BUFFER);
		//face the waiter
		subgoal TurnAndWait(waiterName);
		//wait a bit, tap foot or something to show that we're deciding on a drink
		subgoal Wait(500);
		act touchObjectById(bartenderObjectId);
		subgoal Wait(2500);
		act touchObjectById(); //stop touching
		subgoal Wait(250);
		act touchObjectById();
		subgoal Wait(300);
		act touchObjectById();
		//wear a drink
		
		mental_act {
			int drinkIndex = randomNumGen.nextInt(DRINK_ITEMS.length);
			drinkName = DRINK_ITEMS[drinkIndex];
			
			BehavingEntity.getBehavingEntity().deleteAllWMEClass("HaveDrinkWME");
			
			BehavingEntity.getBehavingEntity().addWME(new HaveDrinkWME(drinkName, System.currentTimeMillis()));
			
		}
		
		act wearItem(drinkName);
		subgoal Wait(200);
		subgoal PlayGesture(winkBangGesture);
		subgoal Wait(500);
		//go back to previous behavior subtree
		subgoal TransitionToPreviousSubtree();
		
	}
	
	
	
  

	
	
  
 	/**
	 * Remove LastTargetWMEs from working memory.
	 */
	sequential behavior CleanLastTarget() {
		Object[] wmes;
		mental_act {
			//clean LastTargetWMS
			wmes = BehavingEntity.getBehavingEntity().lookupWME("LastTargetWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((LastTargetWME)wmes[i]);
			}
		}
	}
 
  
	/**
	 * Anytime SB is given a drink, she immediate enters FindDancePartner subtree with the 
	 * drink giver as the target.
	 */
	 sequential behavior OfferedDrink() {
		String drinkName;
		String avName;
		ItemReceivedWME itemWME;
		with(success_test {
			//receive drink object -- get avatar sending drink
				itemWME=(ItemReceivedWME itemName::drinkName avatarName::avName)
				(ItemReceivedWME.isInList(drinkName, DRINK_ITEMS))
			}) wait;
			//starts FDP with an initial target
			mental_act {
				//remove old FDP WMEs
				Object[] wmes;
				wmes = BehavingEntity.getBehavingEntity().lookupWME("FindDancePartnerWME").toArray();
				if (wmes.length > 0)  {
					for(int i = 0; i < wmes.length; ++i)
						BehavingEntity.getBehavingEntity().deleteWME((FindDancePartnerWME)wmes[i]);
				}
				
				BehavingEntity.getBehavingEntity().deleteWME(itemWME);
				BehavingEntity.getBehavingEntity().deleteAllWMEClass("HaveDrinkWME");
				BehavingEntity.getBehavingEntity().addWME(new HaveDrinkWME(drinkName, System.currentTimeMillis()));
				
				BehavingEntity.getBehavingEntity().addWME(new FindDancePartnerWME(avName, System.currentTimeMillis()));
				Bot.println("OfferedDrink(): Drink recieved. Entering FindDancePartner with " + avName + " as the target.");
			}
			//transition to FDP
			subgoal Wait(3000);
			act wearItem(drinkName);
			subgoal TransitionToFindDancePartner();
			subgoal Wait(5000);
	 }
	 
	 /**
	 * When another avatar near the SB looks directly at the SB and dances, SB starts FindDancePartner
	 * with the other avatar as the target.
	 */
	 sequential behavior OfferedDance() {
		SelfWME self;
		AvatarWME a;
		String avName;
		AnimationWME anim;
		
		with(success_test { 
			self=(SelfWME)
			!(FindDancePartnerWME)
			a=(AvatarWME name::avName isParticipant==false)
			(AvatarWME.withinSocialDistance(AvatarWME.SocialDistance.PERSONAL, a,  self))
			anim=(AnimationWME avatarName==avName isDance==true)
			(AvatarWME.gazeAngleBetween(a,self) < 30)
		} ) wait;
		
		mental_act {
			//remove the dance wme found in the success test
			BehavingEntity.getBehavingEntity().deleteWME(anim);
		
			//remove old FDP WMEs
			Object[] wmes;
			wmes = BehavingEntity.getBehavingEntity().lookupWME("FindDancePartnerWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((FindDancePartnerWME)wmes[i]);
			}
			
			BehavingEntity.getBehavingEntity().addWME(new FindDancePartnerWME(avName, System.currentTimeMillis()));
			Bot.println("OfferedDance(): Dance offer recieved. Entering FindDancePartner with " + avName + " as the target.");
		}
		//transition to FDP
		subgoal TransitionToFindDancePartner();
		//Throttle detection
		subgoal Wait(20000);
	}
	
	sequential behavior OfferedDanceByParticipant() {
		SelfWME self;
		AvatarWME a;
		String avName;
		AnimationWME anim;
		
		with(success_test {
			!(FindDancePartnerWME)		
			self=(SelfWME)
			a=(AvatarWME name::avName isParticipant == true distanceFromSelf < 3.0)
			anim=(AnimationWME avatarName==avName isDance==true)
			(AvatarWME.gazeAngleBetween(a,self) < 45)
		} ) wait;
		
		mental_act {
			//remove the dance wme found in the success test
			BehavingEntity.getBehavingEntity().deleteWME(anim);
		
			//remove old FDP WMEs
			Object[] wmes;
			wmes = BehavingEntity.getBehavingEntity().lookupWME("FindDancePartnerWME").toArray();
			if (wmes.length > 0)  {
				for(int i = 0; i < wmes.length; ++i)
					BehavingEntity.getBehavingEntity().deleteWME((FindDancePartnerWME)wmes[i]);
			}
			
			BehavingEntity.getBehavingEntity().addWME(new FindDancePartnerWME(avName, System.currentTimeMillis()));
			Bot.println("OfferedDance(): Dance offer recieved by participant. Entering FindDancePartner with " + avName + " as the target.");
		}
		//transition to FDP
		subgoal TransitionToFindDancePartner();
		//Throttle detection
		subgoal Wait(20000);
	}
  
    initial_tree {
		
		with (priority 50) subgoal ClearDrinksInHand();
		
		with (priority 1) subgoal TransitionToFindDancePartner();

		//behavior subtree entry points
		with(priority 10, persistent) subgoal EnterGetDrink();
		with(priority 10, persistent) subgoal EnterStageDance();
		with(priority 10, persistent) subgoal EnterFindDancePartner();
		
		//general behaviors to be active at all times
		with (priority 10, persistent) subgoal OfferedDrink();
		with (priority 10, persistent) subgoal OfferedDance();
		with (priority 50, persistent) subgoal OfferedDanceByParticipant();
		with (priority 10, persistent) subgoal TimeoutDrink();
		
		//Test utility to deal with duplicate animation events coming in from libopenmetaverse
		//with (priority 100, persistent) subgoal EliminateDuplicateAnimationEvents();

    }
}